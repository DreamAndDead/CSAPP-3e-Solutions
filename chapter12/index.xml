<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrent Programming on CASPP 3e Solutions</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/</link><description>Recent content in Concurrent Programming on CASPP 3e Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Feb 2021 09:15:46 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/index.xml" rel="self" type="application/rss+xml"/><item><title>12.16</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.16/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.16/</guid><description>/* * 12.16.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; void *thread(void *vargp); #define DEFAULT 4 int main(int argc, char* argv[]) { int N; if (argc &amp;gt; 2) unix_error(&amp;#34;too many param&amp;#34;); else if (argc == 2) N = atoi(argv[1]); else N = DEFAULT; int i; pthread_t tid; for (i = 0; i &amp;lt; N; i++) { Pthread_create(&amp;amp;tid, NULL, thread, NULL); } Pthread_exit(NULL); } void *thread(void *vargp) { printf(&amp;#34;Hello, world\n&amp;#34;); return NULL; }</description></item><item><title>12.17</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.17/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.17/</guid><description>A.
main thread didn&amp;rsquo;t wait other thread.
B.
pthread_exit
/* * 12.17.c */ #include &amp;#34;csapp.h&amp;#34;void *thread(void *vargp); int main() { pthread_t tid; Pthread_create(&amp;amp;tid, NULL, thread, NULL); // exit(0); Pthread_exit(NULL); } /* Thread routine */ void *thread(void *vargp) { Sleep(1); printf(&amp;#34;Hello, world!\n&amp;#34;); return NULL; }</description></item><item><title>12.18</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.18/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.18/</guid><description>A unsafe
B safe
C unsafe</description></item><item><title>12.19</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.19/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.19/</guid><description>pay attention to static int reader_first
/* * 12.19.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; #define WRITE_LIMIT 100000 #define PEOPLE 4 static int readtimes; static int writetimes; static int readcnt; // if a reader is waiting when writing, reader first next round static int reader_first; sem_t mutex, w; void *reader(void *vargp) { while (1) { P(&amp;amp;mutex); readcnt++; if (readcnt == 1) P(&amp;amp;w); V(&amp;amp;mutex); /* Critical section */ readtimes++; reader_first = 0; /* Critical section */ P(&amp;amp;mutex); readcnt--; if (readcnt == 0) V(&amp;amp;w); V(&amp;amp;mutex); } } void *writer(void *vargp) { while (1) { if (reader_first == 1) continue; P(&amp;amp;w); /* Critical section */ writetimes++; if (writetimes == WRITE_LIMIT) { printf(&amp;#34;read/write: %d/%d\n&amp;#34;, readtimes, writetimes); exit(0); } /* Critical section */ // if a reader is waiting, reader first next round if (readcnt == 1) reader_first = 1; V(&amp;amp;w); } } void init(void) { readcnt = 0; readtimes = 0; writetimes = 0; reader_first = 0; Sem_init(&amp;amp;w, 0, 1); Sem_init(&amp;amp;mutex, 0, 1); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i &amp;lt; PEOPLE; i++) if (i%2 == 0) Pthread_create(&amp;amp;tid, NULL, reader, NULL); else Pthread_create(&amp;amp;tid, NULL, writer, NULL); Pthread_exit(NULL); exit(0); }</description></item><item><title>12.20</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.20/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.20/</guid><description>readercnt limits the readers number at the same time.
/* * 12.20.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; #define WRITE_LIMIT 100000 #define PEOPLE 20 // 10 reader and 10 writer #define N 5 static int readtimes; static int writetimes; sem_t mutex; sem_t readercnt; void *reader(void *vargp) { while (1) { P(&amp;amp;readercnt); P(&amp;amp;mutex); readtimes++; V(&amp;amp;mutex); V(&amp;amp;readercnt); } } void *writer(void *vargp) { while (1) { P(&amp;amp;mutex); writetimes++; if (writetimes == WRITE_LIMIT) { printf(&amp;#34;read/write: %d/%d\n&amp;#34;, readtimes, writetimes); exit(0); } V(&amp;amp;mutex); } } void init(void) { readtimes = 0; writetimes = 0; Sem_init(&amp;amp;mutex, 0, 1); Sem_init(&amp;amp;readercnt, 0, N); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i &amp;lt; PEOPLE; i++) { if (i%2 == 0) Pthread_create(&amp;amp;tid, NULL, reader, NULL); else Pthread_create(&amp;amp;tid, NULL, writer, NULL); } Pthread_exit(NULL); exit(0); }</description></item><item><title>12.21</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.21/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.21/</guid><description>writecnt record how many writers are waiting.
/* * 12.21.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; #define WRITE_LIMIT 100000 #define PEOPLE 4 static int readtimes; static int writetimes; static int writecnt; sem_t mutex, w; static int number; void *reader(void *vargp) { while (1) { // writer first if (writecnt &amp;gt; 0) continue; P(&amp;amp;w); /* Critical section */ readtimes++; /* Critical section */ V(&amp;amp;w); } } void *writer(void *vargp) { while (1) { P(&amp;amp;mutex); // one more writer wait to write writecnt++; V(&amp;amp;mutex); P(&amp;amp;w); /* Critical section */ writetimes++; if (writetimes == WRITE_LIMIT) { printf(&amp;#34;read/write: %d/%d\n&amp;#34;, readtimes, writetimes); exit(0); } /* Critical section */ V(&amp;amp;w); P(&amp;amp;mutex); // writer has written writecnt--; V(&amp;amp;mutex); } } void init(void) { writecnt = 0; readtimes = 0; writetimes = 0; Sem_init(&amp;amp;w, 0, 1); Sem_init(&amp;amp;mutex, 0, 1); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i &amp;lt; PEOPLE; i++) { if (i%2 == 0) Pthread_create(&amp;amp;tid, NULL, reader, NULL); else Pthread_create(&amp;amp;tid, NULL, writer, NULL); } Pthread_exit(NULL); exit(0); }</description></item><item><title>12.22</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.22/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.22/</guid><description>#include &amp;#34;csapp.h&amp;#34; /* read line from connfd and echo line to connfd */ int echo_line(int connfd); void command(void); int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; fd_set read_set, ready_set; if (argc != 2) { fprintf(stderr, &amp;#34;usage: %s &amp;lt;port&amp;gt;\nuse port 5000 here\n&amp;#34;, argv[0]); // default port 5000 listenfd = Open_listenfd(&amp;#34;5000&amp;#34;); } else { listenfd = Open_listenfd(argv[1]); //line:conc:select:openlistenfd } FD_ZERO(&amp;amp;read_set); /* Clear read set */ //line:conc:select:clearreadset FD_SET(STDIN_FILENO, &amp;amp;read_set); /* Add stdin to read set */ //line:conc:select:addstdin FD_SET(listenfd, &amp;amp;read_set); /* Add listenfd to read set */ //line:conc:select:addlistenfd // max n for select int n = listenfd+1; while (1) { ready_set = read_set; Select(n, &amp;amp;ready_set, NULL, NULL, NULL); //line:conc:select:select if (FD_ISSET(STDIN_FILENO, &amp;amp;ready_set)) //line:conc:select:stdinready command(); /* Read command line from stdin */ if (FD_ISSET(listenfd, &amp;amp;ready_set)) { //line:conc:select:listenfdready clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA *)&amp;amp;clientaddr, &amp;amp;clientlen); // listen to accepted io ports if (connfd+1 &amp;gt; FD_SETSIZE) { fprintf(stderr, &amp;#34;too many clients\n&amp;#34;); Close(connfd); } n = n &amp;gt; connfd+1 ?</description></item><item><title>12.23</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.23/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.23/</guid><description>code in pic 12-8 save as file 12.23.bug.c
run server
(cd ./site/content/chapter12/code; make &amp;amp;&amp;amp; ./12.23.bug) let&amp;rsquo;s figure out when server will fail, see code 12.23.client.c
/* * 12.23.client.c - An echo client */ #include &amp;#34;csapp.h&amp;#34; int main(int argc, char **argv) { int clientfd; char *host, *port; char *buf = &amp;#34;something to send\n&amp;#34;; rio_t rio; host = &amp;#34;127.0.0.1&amp;#34;; port = &amp;#34;5000&amp;#34;; clientfd = Open_clientfd(host, port); Rio_readinitb(&amp;amp;rio, clientfd); Rio_writen(clientfd, buf, strlen(buf)); /*Close(clientfd);*/ exit(0); } line 20 Close(clientfd) are commented.</description></item><item><title>12.24</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.24/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.24/</guid><description>if don&amp;rsquo;t pass pointer param which points to same data block, functions
rio_readn rio_writen rio_readinitb rio_readlineb rio_readnb are all implicitly reentrant functions</description></item><item><title>12.25</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.25/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.25/</guid><description>/* * A thread-safe version of echo that counts the total number * of bytes received from clients. */ /* $begin echo_cnt */ #include &amp;#34;csapp.h&amp;#34; static int byte_cnt; /* Byte counter */ static sem_t mutex; /* and the mutex that protects it */ static void init_echo_cnt(void) { Sem_init(&amp;amp;mutex, 0, 1); byte_cnt = 0; } void echo_cnt(int connfd) { int n; char buf[MAXLINE]; rio_t rio; static pthread_once_t once = PTHREAD_ONCE_INIT; Pthread_once(&amp;amp;once, init_echo_cnt); //line:conc:pre:pthreadonce Rio_readinitb(&amp;amp;rio, connfd); //line:conc:pre:rioinitb while((n = Rio_readlineb(&amp;amp;rio, buf, MAXLINE)) !</description></item><item><title>12.26</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.26/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.26/</guid><description>struct hostent *gethostbyname(const char *name) struct hostent { char *h_name; char **h_aliases; int h_addrtype; int h_length; char **h_addr_list; } copy int, copy char*, copy char** in struct hostent are 3 different ways.
/* * 12.26.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; /* * struct hostent *gethostbyname(const char *name) * * struct hostent { * char *h_name; * char **h_aliases; * int h_addrtype; * int h_length; * char **h_addr_list; * } */ static sem_t mutex; static void init_mutex(void) { Sem_init(&amp;amp;mutex, 0, 1); } struct hostent *gethostbyname_ts(const char *name, struct hostent *host) { struct hostent *sharehost; P(&amp;amp;mutex); sharehost = gethostbyname(name); // copy int host-&amp;gt;h_addrtype = sharehost-&amp;gt;h_addrtype; host-&amp;gt;h_length = sharehost-&amp;gt;h_length; // copy char * host-&amp;gt;h_name = (char*)Malloc(strlen(sharehost-&amp;gt;h_name)); strcpy(host-&amp;gt;h_name, sharehost-&amp;gt;h_name); // copy char ** int i; for (i = 0; sharehost-&amp;gt;h_aliases[i] !</description></item><item><title>12.27</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.27/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.27/</guid><description>FILE *fpin, *fpout; fpin = fdopen(sockfd, &amp;#34;r&amp;#34;); fpout = fdopen(sockfd, &amp;#34;w&amp;#34;); // read and write fclose(fpin); fclose(fpout); ref: 10.11
fdopen open 2 stream on same sockfd, fdclose will close sockfd under stream. if you call fclose 2 stream on the same sockfd, the second fclose will fail.
image one thread execute code and open 2 stream on fd N. after execution of line fclose(fpin);, program create another thread and execute the same code.</description></item><item><title>12.28</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.28/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.28/</guid><description>No effect on deadlock
1
thread 1 thread 2 P(s) P(s) P(t) P(t) V(s) V(s) V(t) V(t) + | | + +--------------------+ V(t)| | | | | | + | unsafe region t | | | | | | | + +---------+---------+ | V(s)| | | | | | | | | | + | | | | | | | | | | | | | | + | +---------+----------+ P(t)| | | | | unsafe region s | + | | | | | | | | + +-------------------+ P(s)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(s) P(t) V(s) V(t) 2</description></item><item><title>12.29</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.29/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.29/</guid><description>no deadlock
initial: a = 1, b = 1, c = 1
thread 1 thread 2 P(a) P(c) P(b) P(b) V(b) V(b) P(c) V(c) V(c) &amp;mdash;- V(a) &amp;mdash;- thread 2 doesn&amp;rsquo;t manipulate mutex a and initial a is 1, so P(a), V(a) don&amp;rsquo;t affect deadlock status.
thread 1 thread 2 P(b) P(c) V(b) P(b) P(c) V(b) V(c) V(c) + | | + +----------+ V(c)| | | | | | + | | | | | | | | + +----------+ | | V(b)| | | | | | | | | | + | | | | | | | | | | | | | | + +----------+ | | P(b)| | | | | | + | | | | | | | | + +----------+ P(c)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(b) V(b) P(c) V(c)</description></item><item><title>12.30</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.30/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.30/</guid><description>initial: a = 1, b = 1, c = 1
thread 1 thread 2 thread 3 P(a) P(c) P(c) P(b) P(b) V(c) V(b) V(b) P(b) P(c) V(c) P(a) V(c) P(a) V(a) V(a) V(a) V(b) A.
thread 1: a&amp;amp;b, a&amp;amp;c
thread 2: b&amp;amp;c
thread 3: a&amp;amp;b
B.
thread 2 and thread 3</description></item><item><title>12.31</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.31/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.31/</guid><description>/* * 12.31.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; sigjmp_buf buf; void sigchild_handler(int sig) { siglongjmp(buf, 1); } char *tfgets(char *s, int size, FILE *stream) { if (Fork() == 0) { Sleep(5); exit(0); } switch (sigsetjmp(buf, 1)) { case 0: Signal(SIGCHLD, sigchild_handler); return fgets(s, size, stream); case 1: return NULL; } } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(&amp;#34;BOOM!\n&amp;#34;); else printf(&amp;#34;%s&amp;#34;, buf); return 0; }</description></item><item><title>12.32</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.32/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.32/</guid><description>key is last param of select
/* * 12.32.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; char *tfgets(char *s, int size, FILE *stream) { fd_set read_set; FD_ZERO(&amp;amp;read_set); FD_SET(STDIN_FILENO, &amp;amp;read_set); struct timeval timeout; timeout.tv_sec = 5; timeout.tv_usec = 0; Select(1, &amp;amp;read_set, NULL, NULL, &amp;amp;timeout); if (FD_ISSET(STDIN_FILENO, &amp;amp;read_set)) return fgets(s, size, stream); else return NULL; } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(&amp;#34;BOOM!\n&amp;#34;); else printf(&amp;#34;%s&amp;#34;, buf); return 0; }</description></item><item><title>12.33</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.33/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.33/</guid><description>/* * 12.33.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; struct pack { char *s; int size; FILE *stream; }; char *ptr = NULL; int timeout = -1; void *thread_read(void *vargp) { struct pack p = *(struct pack *)vargp; ptr = fgets(p.s, p.size, p.stream); timeout = 0; } void *thread_sleep(void *vargp) { Sleep(5); timeout = 1; } char *tfgets(char *s, int size, FILE *stream) { pthread_t tid_read; pthread_t tid_sleep; struct pack p; p.s = s; p.</description></item><item><title>12.34</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.34/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.34/</guid><description>matrix size and thread number
/* * 12.34.h */ #define N 640 #define M 640 #define THREAD (1&amp;lt;&amp;lt;4) #define ROWS_PER_THREAD (N / THREAD) non concurrent version
/* * 12.34.non.concurrent.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34;#include &amp;#34;12.34.h&amp;#34; int M1[N][M]; int M2[N][M]; int MUL12[N][M]; void non_concurrent_mul(void) { int i, j, k; for (i = 0; i &amp;lt; N; i++) for (j = 0; j &amp;lt; N; j++) { int sum = 0; for (k = 0; k &amp;lt; M; k++) { sum += M1[i][k] * M2[k][j]; } MUL12[i][j] = sum; } } int main(int argc, char* argv[]) { non_concurrent_mul(); return 0; } concurrent version</description></item><item><title>12.35</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.35/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.35/</guid><description>see origin tiny server in section 11.6 on book
the key is close(connfd) in both parent and child process to ensure close fd and reuse it or it&amp;rsquo;ll failed: Accept error: too many open files
--- 12.tiny.c 2021-02-25 07:26:33.305926066 +0000 +++ 12.35.c 2021-02-25 07:26:33.302592754 +0000 @@ -1,6 +1,8 @@ /* - * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the + * 12.35.c - A simple, iterative HTTP/1.</description></item><item><title>12.36</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.36/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.36/</guid><description>check section 11.6 and 12.2.1, combine code pieces together
code directory: chapter12/code/12.36
origin tiny server: tiny.h tiny.c
select echoserver: echoserver.h echoserver.c
key points:
move main loop to main.c file check_clients in echoserver call doit(from tiny server) and close fd benchmark it
Running 4s test @ http://localhost:5000 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 62.72ms 91.68ms 368.55ms 82.94% Req/Sec 615.27 398.96 1.46k 65.91% 3649 requests in 4.</description></item><item><title>12.37</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.37/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.37/</guid><description>see origin tiny server in section 11.6 on book
the key is how to pass connfd into thread
--- 12.tiny.c 2021-02-25 07:26:33.305926066 +0000 +++ 12.37.c 2021-02-25 07:26:33.302592754 +0000 @@ -13,9 +13,13 @@ void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void *thread(void *vargp); + int main(int argc, char **argv) { int listenfd, connfd; + int *connfdp; + pthread_t tid; char hostname[MAXLINE], port[MAXLINE]; socklen_t clientlen; struct sockaddr_storage clientaddr; @@ -35,11 +39,23 @@ Getnameinfo((SA *) &amp;amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(&amp;#34;Accepted connection from (%s, %s)\n&amp;#34;, hostname, port); - doit(connfd); //line:netp:tiny:doit - Close(connfd); //line:netp:tiny:close + + connfdp = (int*)Malloc(sizeof(int)); + *connfdp = connfd; + Pthread_create(&amp;amp;tid, NULL, thread, connfdp); } } +void *thread(void *vargp) { + int connfd = *(int*)vargp; + Pthread_detach(Pthread_self()); + Free(vargp); + + doit(connfd); + Close(connfd); + return NULL; +} + /* * doit - handle one HTTP request/response transaction */ run server</description></item><item><title>12.38</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.38/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.38/</guid><description>code in directory chapter12/code/12.38
files:
sbuf.h, sbuf.c: prethreading package from section 12.5.4 in book. differences are that add new functions sbuf_full, sbuf_empty. tiny.h, tiny.c: origin tiny server from section 11.6 in book. differences are we seperate function declarations into a .h file main.c: listen new connections, create threads and adjust threads number dynamicly see new functions in sbuf, sbuf_full and sbuf_empty
/* Empty buf? */ int sbuf_empty(sbuf_t *sp) { int e; P(&amp;amp;sp-&amp;gt;mutex); /* Lock the buffer */ e = sp-&amp;gt;front == sp-&amp;gt;rear; V(&amp;amp;sp-&amp;gt;mutex); /* Lock the buffer */ return e; } /* Full buf?</description></item><item><title>12.39</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.39/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.39/</guid><description>+------+ +------+ +------+ | |-----&amp;gt;| |------&amp;gt;| | |client| |proxy | |server| | |&amp;lt;-----| |&amp;lt;------| | +------+ +------+ +------+ as server as client proxy play with client as a server, with server as a client, interesting.
the key point is when normal situation
+------+ +------+ | |-----&amp;gt;| | |client| |server| | |&amp;lt;-----| | +------+ +------+ HTTP request from client is something like
GET / HTTP/1.1 Host: address:port but with proxy, it&amp;rsquo;ll be</description></item></channel></rss>