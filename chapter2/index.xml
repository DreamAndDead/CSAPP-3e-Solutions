<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Representing and Manipulating Information on CASPP 3e Solutions</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/</link><description>Recent content in Representing and Manipulating Information on CASPP 3e Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Feb 2021 09:15:46 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/index.xml" rel="self" type="application/rss+xml"/><item><title>2.55</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.55/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.55/</guid><description>/* * show-bytes.c */ #include &amp;lt;stdio.h&amp;gt; typedef unsigned char* byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i &amp;lt; len; i++) { printf(&amp;#34; %.2x&amp;#34;, start[i]); } printf(&amp;#34;\n&amp;#34;); } void show_int(int x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(void*)); } void test_show_bytes(int val) { int ival = val; float fval = (float) ival; int* pval = &amp;amp;ival; show_int(ival); show_float(fval); show_pointer(pval); } int main(int argc, char* argv[]) { int test_num = 328; test_show_bytes(test_num); return 0; } run</description></item><item><title>2.56</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.56/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.56/</guid><description>change var test_num in show-bytes.c
int test_num = 1024; recompile and run
./show-bytes output
00 04 00 00 00 00 80 44 c8 fe 83 2f fc 7f 00 00 You can try more integers :)</description></item><item><title>2.57</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.57/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.57/</guid><description>/* * show-bytes.c */ #include &amp;lt;stdio.h&amp;gt; typedef unsigned char* byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i &amp;lt; len; i++) { printf(&amp;#34; %.2x&amp;#34;, start[i]); } printf(&amp;#34;\n&amp;#34;); } void show_int(int x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(void*)); } //============= // 2.57 changes //============= void show_short(short x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(short)); } void show_long(long x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(long)); } void show_double(double x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(double)); } //================== // 2.</description></item><item><title>2.58</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.58/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.58/</guid><description>/* * is-little-endian.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef unsigned char* byte_pointer; int is_little_endian() { int test_num = 0xff; byte_pointer byte_start = (byte_pointer) &amp;amp;test_num; if (byte_start[0] == 0xff) { return 1; } return 0; } int main(int argc, char* argv[]) { assert(is_little_endian()); return 0; }</description></item><item><title>2.59</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.59/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.59/</guid><description>expression
(x &amp;amp; 0xFF) | (y &amp;amp; ~0xFF) try it
/* * generate-a-word.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int main(int argc, char* argv[]) { size_t mask = 0xff; size_t x = 0x89ABCDEF; size_t y = 0x76543210; size_t res = (x &amp;amp; mask) | (y &amp;amp; ~mask); assert(res == 0x765432EF); return 0; }</description></item><item><title>2.60</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.60/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.60/</guid><description>/* * replace-byte.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; unsigned replace_byte(unsigned x, int i, unsigned char b) { if (i &amp;lt; 0) { printf(&amp;#34;error: i is negetive\n&amp;#34;); return x; } if (i &amp;gt; sizeof(unsigned)-1) { printf(&amp;#34;error: too big i&amp;#34;); return x; } // 1 byte has 8 bits, &amp;lt;&amp;lt; 3 means * 8 unsigned mask = ((unsigned) 0xFF) &amp;lt;&amp;lt; (i &amp;lt;&amp;lt; 3); unsigned pos_byte = ((unsigned) b) &amp;lt;&amp;lt; (i &amp;lt;&amp;lt; 3); return (x &amp;amp; ~mask) | pos_byte; } int main(int argc, char *argv[]) { unsigned rep_0 = replace_byte(0x12345678, 0, 0xAB); unsigned rep_3 = replace_byte(0x12345678, 3, 0xAB); assert(rep_0 == 0x123456AB); assert(rep_3 == 0xAB345678); return 0; }</description></item><item><title>2.61</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.61/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.61/</guid><description>A
!~x B
!x C
!~(x | ~0xff) D
!((x &amp;gt;&amp;gt; ((sizeof(int)-1) &amp;lt;&amp;lt; 3)) &amp;amp; 0xff) test it
/* * 2.61.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int A(int x) { return !~x; } int B(int x) { return !x; } int C(int x) { return A(x | ~0xff); } int D(int x) { return B((x &amp;gt;&amp;gt; ((sizeof(int)-1) &amp;lt;&amp;lt; 3)) &amp;amp; 0xff); } int main(int argc, char* argv[]) { int all_bit_one = ~0; int all_bit_zero = 0; assert(A(all_bit_one)); assert(!</description></item><item><title>2.62</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.62/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.62/</guid><description>/* * int-shifts-are-arithemetic.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int int_shifts_are_arithemetic() { int num = -1; return !(num ^ (num &amp;gt;&amp;gt; 1)); } int main(int argc, char* argv[]) { assert(int_shifts_are_arithemetic()); return 0; }</description></item><item><title>2.63</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.63/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.63/</guid><description>/* * srl-sra.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; unsigned srl(unsigned x, int k) { unsigned xsra = (int) x &amp;gt;&amp;gt; k; int w = sizeof(int) &amp;lt;&amp;lt; 3; int mask = (int) -1 &amp;lt;&amp;lt; (w - k); return xsra &amp;amp; ~mask; } int sra(int x, int k) { int xsrl = (unsigned) x &amp;gt;&amp;gt; k; int w = sizeof(int) &amp;lt;&amp;lt; 3; int mask = (int) -1 &amp;lt;&amp;lt; (w - k); //let mask remain unchanged when the first bit of x is 1, otherwise 0.</description></item><item><title>2.64</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.64/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.64/</guid><description>/* * any-odd-one.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int any_odd_one(unsigned x) { return !!(0xAAAAAAAA &amp;amp; x); } int main(int argc, char* argv[]) { assert(any_odd_one(0x2)); assert(!any_odd_one(0x4)); return 0; }</description></item><item><title>2.65</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.65/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.65/</guid><description>Thanks this answer from stackoverflow
/* * odd-ones.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int odd_ones(unsigned x) { x ^= x &amp;gt;&amp;gt; 16; x ^= x &amp;gt;&amp;gt; 8; x ^= x &amp;gt;&amp;gt; 4; x ^= x &amp;gt;&amp;gt; 2; x ^= x &amp;gt;&amp;gt; 1; x &amp;amp;= 0x1; return x; } int main(int argc, char* argv[]) { assert(odd_ones(0x10101011)); assert(!odd_ones(0x01010101)); return 0; }</description></item><item><title>2.66</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.66/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.66/</guid><description>/* * leftmost-one.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* * Generate mask indicating leftmost 1 in x. Assume w=32 * For example, 0xFF00 -&amp;gt; 0x8000, and 0x6000 -&amp;gt; 0x4000. * If x = 0, then return 0 */ int leftmost_one(unsigned x) { /* * first, generate a mask that all bits after leftmost one are one * e.g. 0xFF00 -&amp;gt; 0xFFFF, and 0x6000 -&amp;gt; 0x7FFF * If x = 0, get 0 */ x |= x &amp;gt;&amp;gt; 1; x |= x &amp;gt;&amp;gt; 2; x |= x &amp;gt;&amp;gt; 4; x |= x &amp;gt;&amp;gt; 8; x |= x &amp;gt;&amp;gt; 16; /* * then, do (mask &amp;gt;&amp;gt; 1) + (mask &amp;amp;&amp;amp; 1), in which mask &amp;amp;&amp;amp; 1 deals with case x = 0, reserve leftmost bit one * that&amp;#39;s we want */ return (x &amp;gt;&amp;gt; 1) + (x &amp;amp;&amp;amp; 1); } int main(int argc, char* argv[]) { assert(leftmost_one(0xFF00) == 0x8000); assert(leftmost_one(0x6000) == 0x4000); assert(leftmost_one(0x0) == 0x0); assert(leftmost_one(0x80000000) == 0x80000000); return 0; }</description></item><item><title>2.67</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.67/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.67/</guid><description>A.
In section 6.5.7 Bitwise shift operators of c11 standard, it said
If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior it undefined.
B.
check function int_size_is_32
C.
check function int_size_is_32_for_16bit
/* * int-size-is-32.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* The following function does not run properly on some machine */ /* int bad_int_size_is_32() { int set_msb = 1 &amp;lt;&amp;lt; 31; int beyond_msb = 1 &amp;lt;&amp;lt; 32; return set_msb &amp;amp;&amp;amp; !</description></item><item><title>2.68</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.68/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.68/</guid><description>/* * lower-one-mask.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* * Mask with least signficant n bits set to 1 * Example: n = 6 -&amp;gt; 0x3F, n = 17 -&amp;gt; 0x1FFFF * Assume 1 &amp;lt;= n &amp;lt;= w */ int lower_one_mask(int n) { int w = sizeof(int) &amp;lt;&amp;lt; 3; return (unsigned) -1 &amp;gt;&amp;gt; (w - n); } int main(int argc, char* argv[]) { assert(lower_one_mask(6) == 0x3F); assert(lower_one_mask(17) == 0x1FFFF); assert(lower_one_mask(32) == 0xFFFFFFFF); return 0; }</description></item><item><title>2.69</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.69/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.69/</guid><description>/* * rotate-left.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* * Do rotate left shift. Assume 0 &amp;lt;= n &amp;lt; w * Example when x = 0x12345678 and w = 32: * n = 4 -&amp;gt; 0x23456781, n = 20 -&amp;gt; 0x67812345 */ unsigned rotate_left(unsigned x, int n) { int w = sizeof(unsigned) &amp;lt;&amp;lt; 3; /* pay attention when n == 0 */ return x &amp;lt;&amp;lt; n | x &amp;gt;&amp;gt; (w - n - 1) &amp;gt;&amp;gt; 1; } int main(int argc, char* argv[]) { assert(rotate_left(0x12345678, 4) == 0x23456781); assert(rotate_left(0x12345678, 20) == 0x67812345); return 0; }</description></item><item><title>2.70</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.70/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.70/</guid><description>/* * fits-bits.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int fits_bits(int x, int n) { /* * 1 &amp;lt;= n &amp;lt;= w * * assume w = 8, n = 3 * if x &amp;gt; 0 * 0b00000010 is ok, 0b00001010 is not, and 0b00000110 is not yet (thanks itardc@163.com) * if x &amp;lt; 0 * 0b11111100 is ok, 0b10111100 is not, and 0b11111000 is not yet * * the point is * x &amp;lt;&amp;lt; (w-n) &amp;gt;&amp;gt; (w-n) must be equal to x itself.</description></item><item><title>2.71</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.71/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.71/</guid><description>A.
This function can&amp;rsquo;t extract a negetive byte number from word
B.
/* * xbyte.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef unsigned packet_t; int xbyte(packet_t word, int bytenum) { /* * pay attention when byte we want is negetive * * Assume sizeof(unsigned) is 4 * first shift left 8 * (4 - 1 - bytenum) * then arthemetic shift right 8 * (4 - 1) reserve signficant bit */ int size = sizeof(unsigned); int shift_left_val = (size - 1 - bytenum) &amp;lt;&amp;lt; 3; int shift_right_val = (size - 1) &amp;lt;&amp;lt; 3; return (int) word &amp;lt;&amp;lt; shift_left_val &amp;gt;&amp;gt; shift_right_val; } int main(int argc, char* argv[]) { assert(xbyte(0xAABBCCDD, 1) == 0xFFFFFFCC); assert(xbyte(0x00112233, 2) == 0x11); return 0; }</description></item><item><title>2.72</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.72/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.72/</guid><description>A.
sizeof(val) returns type size_t, it usually is a kind of unsigned type.
maxbytes - sizeof(val) returns value of type size_t, and it&amp;rsquo;s always &amp;gt;= 0
B.
/* * copy-int.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; void copy_int(int val, void* buf, int maxbytes) { /* compare two signed number, avoid someone set maxbytes a negetive value */ if (maxbytes &amp;gt;= (int) sizeof(val)) { memcpy(buf, (void*)&amp;amp;val, sizeof(val)); } } int main(int argc, char* argv[]) { int maxbytes = sizeof(int) * 10; void* buf = malloc(maxbytes); int val; val = 0x12345678; copy_int(val, buf, maxbytes); assert(*(int*)buf == val); val = 0xAABBCCDD; copy_int(val, buf, 0); assert(*(int*)buf !</description></item><item><title>2.73</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.73/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.73/</guid><description>I can&amp;rsquo;t figure out a elegant solution :(
thanks https://zhangjunphy.github.io/csapp/chap2.html :)
/* * saturating-add.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; int saturating_add(int x, int y) { int sum = x + y; int sig_mask = INT_MIN; /* * if x &amp;gt; 0, y &amp;gt; 0 but sum &amp;lt; 0, it&amp;#39;s a positive overflow * if x &amp;lt; 0, y &amp;lt; 0 but sum &amp;gt;= 0, it&amp;#39;s a negetive overflow */ int pos_over = !</description></item><item><title>2.74</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.74/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.74/</guid><description>/* * tsub-ok.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* Determine whether arguments can be substracted without overflow */ int tsub_ok(int x, int y) { int res = 1; (y == INT_MIN) &amp;amp;&amp;amp; (res = 0); // if (y == INT_MIN) res = 0; int sub = x - y; int pos_over = x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; 0 &amp;amp;&amp;amp; sub &amp;lt; 0; int neg_over = x &amp;lt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; sub &amp;gt; 0; res = res &amp;amp;&amp;amp; !</description></item><item><title>2.75</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.75/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.75/</guid><description>/* * unsigned-high-prod.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;inttypes.h&amp;gt; int signed_high_prod(int x, int y) { int64_t mul = (int64_t) x * y; return mul &amp;gt;&amp;gt; 32; } unsigned unsigned_high_prod(unsigned x, unsigned y) { /* TODO calculations */ int sig_x = x &amp;gt;&amp;gt; 31; int sig_y = y &amp;gt;&amp;gt; 31; int signed_prod = signed_high_prod(x, y); return signed_prod + x * sig_y + y * sig_x; } /* a theorically correct version to test unsigned_high_prod func */ unsigned another_unsigned_high_prod(unsigned x, unsigned y) { uint64_t mul = (uint64_t) x * y; return mul &amp;gt;&amp;gt; 32; } int main(int argc, char* argv[]) { unsigned x = 0x12345678; unsigned y = 0xFFFFFFFF; assert(another_unsigned_high_prod(x, y) == unsigned_high_prod(x, y)); return 0; }</description></item><item><title>2.76</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.76/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.76/</guid><description>/* * calloc.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;string.h&amp;gt; /* rename to avoid conflict */ void* another_calloc(size_t nmemb, size_t size) { if (nmemb == 0 || size == 0) { return NULL; } size_t buf_size = nmemb * size; /* a good way to check overflow or not */ if (nmemb == buf_size / size) { void* ptr = malloc(buf_size); if(ptr != NULL) { memset(ptr, 0, buf_size); } return ptr; } return NULL; } int main(int argc, char* argv[]) { void* p; p = another_calloc(0x1234, 1); assert(p !</description></item><item><title>2.77</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.77/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.77/</guid><description>/* * 2.77.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* K = 17 */ int A(int x) { return (x &amp;lt;&amp;lt; 4) + x; } /* K = -7 */ int B(int x) { return x - (x &amp;lt;&amp;lt; 3); } /* K = 60 */ int C(int x) { return (x &amp;lt;&amp;lt; 6) - (x &amp;lt;&amp;lt; 2); } /* K = -112 */ int D(int x) { return (x &amp;lt;&amp;lt; 4) - (x &amp;lt;&amp;lt; 7); } int main(int argc, char* argv[]) { int x = 0x87654321; assert(A(x) == 17 * x); assert(B(x) == -7 * x); assert(C(x) == 60 * x); assert(D(x) == -112 * x); return 0; }</description></item><item><title>2.78</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.78/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.78/</guid><description>/* * divide-power2.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* * Divide by power of 2, -&amp;gt; x/2^k * Assume 0 &amp;lt;= k &amp;lt; w-1 */ int divide_power2(int x, int k) { int is_neg = x &amp;amp; INT_MIN; (is_neg &amp;amp;&amp;amp; (x = x + (1 &amp;lt;&amp;lt; k) - 1)); return x &amp;gt;&amp;gt; k; } int main(int argc, char* argv[]) { int x = 0x80000007; assert(divide_power2(x, 1) == x / 2); assert(divide_power2(x, 2) == x / 4); return 0; }</description></item><item><title>2.79</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.79/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.79/</guid><description>/* * mul3div4.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* * code from 2.78 * * Divide by power of 2, -&amp;gt; x/2^k * Assume 0 &amp;lt;= k &amp;lt; w-1 */ int divide_power2(int x, int k) { int is_neg = x &amp;amp; INT_MIN; (is_neg &amp;amp;&amp;amp; (x = x + (1 &amp;lt;&amp;lt; k) - 1)); return x &amp;gt;&amp;gt; k; } int mul3div4(int x) { int mul3 = (x &amp;lt;&amp;lt; 1) + x; return divide_power2(mul3, 2); } int main(int argc, char* argv[]) { int x = 0x87654321; assert(mul3div4(x) == x * 3 / 4); return 0; }</description></item><item><title>2.80</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.80/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.80/</guid><description>/* * threeforths.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* * calculate 3/4x, no overflow, round to zero * * no overflow means divide 4 first, then multiple 3, diffrent from 2.79 here * * rounding to zero is a little complicated. * every int x, equals f(first 30 bit number) plus l(last 2 bit number) * * f = x &amp;amp; ~0x3 * l = x &amp;amp; 0x3 * x = f + l * threeforths(x) = f/4*3 + l*3/4 * * f doesn&amp;#39;t care about round at all, we just care about rounding from l*3/4 * * lm3 = (l &amp;lt;&amp;lt; 1) + l * * when x &amp;gt; 0, rounding to zero is easy * * lm3d4 = lm3 &amp;gt;&amp;gt; 2 * * when x &amp;lt; 0, rounding to zero acts like divide_power2 in 2.</description></item><item><title>2.81</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.81/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.81/</guid><description>A.
-1 &amp;lt;&amp;lt; k B.
~(-1 &amp;lt;&amp;lt; k) &amp;lt;&amp;lt; j /* * 2.81.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* Assume 0 &amp;lt;= k &amp;lt; w */ int A(int k) { return -1 &amp;lt;&amp;lt; k; } /* Assume 0 &amp;lt;= j,k &amp;lt; w */ int B(int k, int j) { return ~A(k) &amp;lt;&amp;lt; j; } int main(int argc, char* argv[]) { assert(A(8) == 0xFFFFFF00); assert(B(16, 8) == 0x00FFFF00); return 0; }</description></item><item><title>2.82</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.82/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.82/</guid><description>A.
wrong, when x == INT_MIN
B.
right
C.
right
D.
right
E.
right
/* * 2.82.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;lib/random.h&amp;#34; /* broken when x is INT_MIN */ int A(int x, int y) { return (x &amp;lt; y) == (-x &amp;gt; -y); } /* * right * * ((x + y) &amp;lt;&amp;lt; 4) + y - x * =&amp;gt; * x &amp;lt;&amp;lt; 4 - x + y &amp;lt;&amp;lt; 4 + y * =&amp;gt; * x*16 - x + y*16 + y * whether overflow or not, =&amp;gt; * x*15 + y*17 */ int B(int x, int y) { return ((x + y) &amp;lt;&amp;lt; 4) + y - x == 17 * y + 15 * x; } /* * right * * ~x + ~y + 1 * =&amp;gt; * ~x + 1 + ~y + 1 - 1 * =&amp;gt; * -x + -y - 1 * =&amp;gt; * -(x + y) - 1 * =&amp;gt; * ~(x + y) + 1 - 1 * =&amp;gt; * ~(x + y) */ int C(int x, int y) { return ~x + ~y + 1 == ~(x + y); } /* * right * * (ux - uy) == -(unsigned) (y - x) * =&amp;gt; * -(ux - uy) == (unsigned) (y - x) * =&amp;gt; * (ux - uy) == (unsigned) (x - y) */ int D(int x, int y) { unsigned ux = (unsigned) x; unsigned uy = (unsigned) y; return (ux - uy) == -(unsigned) (y - x); } /* * right * * x &amp;gt;&amp;gt; 2 &amp;lt;&amp;lt; 2 * =&amp;gt; * x &amp;amp; ~0x3 * =&amp;gt; * x - num(00/01/10/11) * =&amp;gt; * ((x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 2) &amp;lt;= x */ int E(int x, int y) { return ((x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 2) &amp;lt;= x; } int main(int argc, char* argv[]) { init_seed(); int x = random_int(); int y = random_int(); assert(!</description></item><item><title>2.83</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.83/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.83/</guid><description>A.
n = 0.yyyyy... n &amp;lt;&amp;lt; k = y.yyyyy... = Y + n n &amp;lt;&amp;lt; k - n = Y n = Y/(2^k - 1) B.
(a).
y = 101, Y = 5, k = 3
n = 5/7
(b).
y = 0110, Y = 6, k = 4
n = 2/5
(c).
y = 010011, Y = 19, k = 6
n = 19/63</description></item><item><title>2.84</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.84/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.84/</guid><description>Thanks czy1996
/* * float-le.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; unsigned f2u(float x) { return *(unsigned*)&amp;amp;x; } int float_le(float x, float y) { unsigned ux = f2u(x); unsigned uy = f2u(y); unsigned sx = ux &amp;gt;&amp;gt; 31; unsigned sy = uy &amp;gt;&amp;gt; 31; // ref: https://github.com/DreamAndDead/CSAPP-3e-Solutions/issues/1 return (ux &amp;lt;&amp;lt; 1 == 0 &amp;amp;&amp;amp; uy &amp;lt;&amp;lt; 1 == 0) || /* both zeros */ (sx &amp;amp;&amp;amp; !sy) || /* x &amp;lt; 0, y &amp;gt;= 0 or x &amp;lt;= 0, y &amp;gt; 0 */ (!</description></item><item><title>2.85</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.85/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.85/</guid><description>bias = 2^(k-1) - 1
V = 2^E * M
A.
7.0 = 0b111.000&amp;hellip;
M = 0b1.11, f = 0b0.11, E = 2, e = bias + E, V = 7.0
bits
0 10....01 110.... B.
Assume bias &amp;raquo; n
bigest odd number, M must be 0b1.111111&amp;hellip;., f = 0b0.11111111&amp;hellip;(n bits 1)
E = n, V = 0b11111111&amp;hellip;(n+1 bits 1) = 2^(n+1) - 1
bits
0 bias+n 11111.... C.</description></item><item><title>2.86</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.86/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.86/</guid><description>bias = 2^(15-1) - 1
description binary decimal least positive unstandard 0 0000&amp;hellip;(15) 0 000&amp;hellip;(62)1 2^(1-bias-63) least positive standard 0 000&amp;hellip;(14)1 1 000&amp;hellip;.(63) 2^(1-bias) bigest standard 0 111&amp;hellip;(14)0 1 111&amp;hellip;(63) 2^bias * (2-2^-63)</description></item><item><title>2.87</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.87/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.87/</guid><description> Desc Hex M E V D -0 0x8000 0 -14 -0 -0.0 &amp;gt;2 least 0x4001 1025/1024 1 1025/512 2.00195312 512 0x6000 1 9 512 512.0 bigest denormalized 0x03FF 1023/1024 -14 1023/(2^24) 6.09755516e-5 -∞ 0xFC00 - - -∞ -∞ ox3BB0 0x3BB0 123/64 -1 123/128 0.9609375</description></item><item><title>2.88</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.88/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.88/</guid><description> A bit A value B bit B value 1 01110 001 -9/16 1 0110 0010 -9/16 0 10110 101 13*2^4 0 1110 1010 13*2^4 1 00111 110 -7/2^10 1 0000 0111 -7/2^10 0 00000 101 5/2^11 0 0000 0001 1/2^10 1 11011 000 -2^12 1 1110 1111 -31*2^3 0 11000 100 3*2^8 0 1111 0000 +oo</description></item><item><title>2.89</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/</guid><description>/* * 2.89.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;lib/random.h&amp;#34; /* * most important thing is that all double number come from ints */ /* right */ int A(int x, double dx) { return (float)x == (float)dx; } /* wrong when y is INT_MIN */ int B(int x, double dx, int y, double dy) { return dx-dy == (double)(x-y); } /* right */ int C(double dx, double dy, double dz) { return (dx+dy)+dz == dx+(dy+dz); } /* * wrong * * FIXME I don&amp;#39;t know what conditions cause false */ int D(double dx, double dy, double dz) { return (dx*dy)*dz == dx*(dy*dz); } /* wrong when dx !</description></item><item><title>2.90</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.90/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.90/</guid><description>/* * fpwr2.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;math.h&amp;gt; float u2f(unsigned x) { return *(float*) &amp;amp;x; } /* 2^x */ float fpwr2(int x) { /* Result exponent and fraction */ unsigned exp, frac; unsigned u; if (x &amp;lt; 2-pow(2,7)-23) { /* too small. return 0.0 */ exp = 0; frac = 0; } else if (x &amp;lt; 2-pow(2,7)) { /* Denormalized result */ exp = 0; frac = 1 &amp;lt;&amp;lt; (unsigned)(x - (2-pow(2,7)-23)); } else if (x &amp;lt; pow(2,7)-1+1) { /* Normalized result */ exp = pow(2,7)-1+x; frac = 0; } else { /* Too big, return +oo */ exp = 0xFF; frac = 0; } /* pack exp and frac into 32 bits */ u = exp &amp;lt;&amp;lt; 23 | frac; /* Result as float */ return u2f(u); } int main(int argc, char* argv[]) { assert(fpwr2(0) == powf(2,0)); assert(fpwr2(100) == powf(2,100)); assert(fpwr2(-100) == powf(2,-100)); assert(fpwr2(10000) == powf(2,10000)); assert(fpwr2(-10000) == powf(2,-10000)); return 0; }</description></item><item><title>2.91</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.91/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.91/</guid><description>A.
0x40490FDB 0 10000000 10010010000111111011011 float number
0b11.0010010000111111011011 B.
ref 2.83
0b11.001001(001)... C.
9th</description></item><item><title>2.92</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.92/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.92/</guid><description>/* * float-negate.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-negate.h&amp;#34; float_bits float_negate(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) &amp;amp;&amp;amp; (frac != 0); if (is_NAN) { return f; } return ~sig &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.93</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.93/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.93/</guid><description>/* * float-absval.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-absval.h&amp;#34; float_bits float_absval(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) &amp;amp;&amp;amp; (frac != 0); if (is_NAN) { return f; } return 0 &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.94</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.94/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.94/</guid><description>/* * float-twice.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-twice.h&amp;#34; float_bits float_twice(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN_or_oo = (exp == 0xFF); if (is_NAN_or_oo) { return f; } if (exp == 0) { /* Denormalized */ frac &amp;lt;&amp;lt;= 1; } else if (exp == 0xFF - 1) { /* twice to oo */ exp = 0xFF; frac = 0; } else { /* Normalized */ exp += 1; } return sig &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.95</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.95/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.95/</guid><description>/* * float-half.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-half.h&amp;#34; float_bits float_half(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned rest = f &amp;amp; 0x7FFFFFFF; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN_or_oo = (exp == 0xFF); if (is_NAN_or_oo) { return f; } /* * round to even, we care about last 2 bits of frac * * 00 =&amp;gt; 0 just &amp;gt;&amp;gt;1 * 01 =&amp;gt; 0 (round to even) just &amp;gt;&amp;gt;1 * 10 =&amp;gt; 1 just &amp;gt;&amp;gt;1 * 11 =&amp;gt; 1 + 1 (round to even) just &amp;gt;&amp;gt;1 and plus 1 */ int addition = (frac &amp;amp; 0x3) == 0x3; if (exp == 0) { /* Denormalized */ frac &amp;gt;&amp;gt;= 1; frac += addition; } else if (exp == 1) { /* Normalized to denormalized */ rest &amp;gt;&amp;gt;= 1; rest += addition; exp = rest &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; frac = rest &amp;amp; 0x7FFFFF; } else { /* Normalized */ exp -= 1; } return sig &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.96</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.96/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.96/</guid><description>/* * float-f2i.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-f2i.h&amp;#34; /* * Compute (float) f * If conversion cause overflow or f is NaN, return 0x80000000 */ int float_f2i(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; unsigned bias = 0x7F; int num; unsigned E; unsigned M; /* * consider positive numbers * * 0 00000000 00000000000000000000000 * ===&amp;gt; * 0 01111111 00000000000000000000000 * 0 &amp;lt;= f &amp;lt; 1 * get integer 0 * * 0 01111111 00000000000000000000000 * ===&amp;gt; * 0 (01111111+31) 00000000000000000000000 * 1 &amp;lt;= f &amp;lt; 2^31 * integer round to 0 * * 0 (01111111+31) 00000000000000000000000 * ===&amp;gt; * greater * 2^31 &amp;lt;= f &amp;lt; oo * return 0x80000000 */ if (exp &amp;gt;= 0 &amp;amp;&amp;amp; exp &amp;lt; 0 + bias) { /* number less than 1 */ num = 0; } else if (exp &amp;gt;= 31 + bias) { /* number overflow */ /* or f &amp;lt; 0 and (int)f == INT_MIN */ num = 0x80000000; } else { E = exp - bias; M = frac | 0x800000; if (E &amp;gt; 23) { num = M &amp;lt;&amp;lt; (E - 23); } else { /* whether sig is 1 or 0, round to zero */ num = M &amp;gt;&amp;gt; (23 - E); } } return sig ?</description></item><item><title>2.97</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.97/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.97/</guid><description>/* * float-i2f.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;float-i2f.h&amp;#34; /* * Assume i &amp;gt; 0 * calculate i&amp;#39;s bit length * * e.g. * 0x3 =&amp;gt; 2 * 0xFF =&amp;gt; 8 * 0x80 =&amp;gt; 8 */ int bits_length(int i) { if ((i &amp;amp; INT_MIN) != 0) { return 32; } unsigned u = (unsigned)i; int length = 0; while (u &amp;gt;= (1&amp;lt;&amp;lt;length)) { length++; } return length; } /* * generate mask * 00000.</description></item></channel></rss>