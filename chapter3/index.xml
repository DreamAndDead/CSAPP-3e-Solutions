<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Machine-Level Representation of Programs on CASPP 3e Solutions</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/</link><description>Recent content in Machine-Level Representation of Programs on CASPP 3e Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Feb 2021 09:15:46 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/index.xml" rel="self" type="application/rss+xml"/><item><title>3.58</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.58/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.58/</guid><description>/* * decode.c */ long decode(long x, long y, long z) { long tmp = y - z; return (tmp * x) ^ (tmp &amp;lt;&amp;lt; 63 &amp;gt;&amp;gt; 63); }</description></item><item><title>3.59</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.59/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.59/</guid><description>assume
multiple
2^128 overflows, so we don&amp;rsquo;t care about it
# void store_prod(int128_t* dest, int64_t x, int64_t y) # dest in %rdi, x in %rsi, y in %rdx store_prod: movq %rdx, %rax # %rax = y cqto # (int128_t)y, %rdx = (-1)y_63 movq %rsi, %rcx # %rcx = x # x &amp;gt;&amp;gt; 63, if x == 1, %rcx = -1; if x_63 == 0, %rcx = 0 # %rcx = (-1)x_63 sarq $63, %rcx # pay attention, imulq behaves differently according to param number(1/2) imulq %rax, %rcx # %rcx = y * -x_63 imulq %rsi, %rdx # %rdx = x * -y_63 addq %rdx, %rcx # %rcx = x * -y_63 + y * -x_63 mulq %rsi # %rdx:%rax &amp;lt;= ux * uy # lower 64 bits are same for x * y and ux * uy.</description></item><item><title>3.60</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.60/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.60/</guid><description>A.
val reg x %rdi n %esi result %rax mask %rdx B.
result = 0 mask = 1 C.
mask != 0 D.
mask = mask &amp;lt;&amp;lt; n E.
/* * loop2.c */ long loop2(long x, int n) { long result = 0; long mask; for (mask = 1; mask != 0; mask &amp;lt;&amp;lt;= n) { result |= (x &amp;amp; mask); } return result; }</description></item><item><title>3.61</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.61/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.61/</guid><description>function cread_alt should be
/* * cread-alt.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; long cread(long *xp) { return (xp ? *xp : 0); } long cread_alt(long *xp) { return (!xp ? 0 : *xp); } int main(int argc, char* argv[]) { long a = 0; assert(cread(&amp;amp;a) == cread_alt(&amp;amp;a)); assert(cread(NULL) == cread_alt(NULL)); return 0; } compile function cread in book sample and get
# long cread(long *xp) # xp in %rdi cread: movq (%rdi), %rax testq %rdi, %rdi movl $0, %edx cmove %rdx, %rax ret the result of compiling cread_alt may be</description></item><item><title>3.62</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.62/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.62/</guid><description>/* * 3.62.c */ /* Enumerated type creates set of contants numbered 0 and upward */ typedef enum { MODE_A, MODE_B, MODE_C, MODE_D, MODE_E } mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: *p1 = *p1 + *p2; result = *p1; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; result = 27; break; case MODE_E: result = 27; break; default: result = 12; break; } return result; }</description></item><item><title>3.63</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.63/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.63/</guid><description>/* * 3.63.c */ long switch_prob(long x, long n) { long result = x; switch(n) { /* Fill in code here */ case 60: case 62: result = x * 8; break; case 63: result = x &amp;gt;&amp;gt; 3; break; case 64: x = x &amp;lt;&amp;lt; 4 - x; case 65: x = x * x; default: result = x + 0x4B; } return result; }</description></item><item><title>3.64</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.64/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.64/</guid><description>A.
3.1 in book
T D[R][C]; &amp;amp;D[i][j] = Xd + L(C*i + j) T means type, D means data, R means row, C means column L means sizeof(T), Xd means address of D similarly, in 3d array
TYPE D[R][S][T] &amp;amp;D[i][j][k] = Xd + L(S*T*i + T*j + k) B.
.section .data .global A A: .fill 3640/8, 8, 121 # fill data 121 .section .text .global store_ele # long store_ele(long i, long j, long k, long *dest) # i in %rdi, j in %rsi, k in %rdx, dest in %rcx store_ele: leaq (%rsi, %rsi, 2), %rax # t1 = j*3 leaq (%rsi, %rax, 4), %rax # t1 = j*13 movq %rdi, %rsi # t2 = i salq $6, %rsi # t2 = i*64 addq %rsi, %rdi # t3 = i*65 addq %rax, %rdi # t3 = i*65 + j*13 addq %rdi, %rdx # t4 = i*65 + j*13 + k movq A(,%rdx,8), %rax # t1 = *(A + 8*t4) movq %rax, (%rcx) # *dest = t1 movl $3640, %eax # return 3640 ret base on comments,</description></item><item><title>3.65</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.65/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.65/</guid><description>A.
&amp;amp;A[i][j] in %rdx B.
&amp;amp;A[j][i] in %rax C.
addq $8, %rdx # means A[i][j] -&amp;gt; A[i][j+1] addq $120, %rax # means A[j][i] -&amp;gt; A[j+1][i], 120 == 8*M M = 15</description></item><item><title>3.66</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.66/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.66/</guid><description>.section .text .global sum_col # long sum_col(long n, long A[NR(n)][NC(n)], long j) # n in %rdi, A in %rsi, j in %rdx sum_col: leaq 1(,%rdi,4), %r8 # t1 = n*4 + 1 leaq (%rdi,%rdi,2), %rax # t2 = n*3 movq %rax, %rdi # t3 = n*3 testq %rax, %rax # test n*3 jle .L4 # n*3 &amp;lt;= 0, jump .L4 salq $3, %r8 # t1 = t1*8 = 8*(n*4 + 1) leaq (%rsi,%rdx,8), %rcx # t4 = j*8 + A movl $0, %eax # t2 = 0 movl $0, %edx # t5 = 0 .</description></item><item><title>3.67</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.67/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.67/</guid><description>3.67
/* * 3.67.c */ typedef struct { long a[2]; long *p; } strA; typedef struct { long u[2]; long q; } strB; strB process(strA a) { strB r; r.u[0] = s.a[1]; r.u[1] = s.a[0]; r.q = *s.p; return r; } long eval(long x, long y, long z) { strA s; s.a[0] = x; s.a[1] = y; s.p = &amp;amp;z; strB r = process(s); return r.u[0] + r.u[1] + r.q; } # strB process(strA s) # s in %rdi process: movq %rdi, %rax movq 24(%rsp), %rdx movq (%rdx), %rdx movq 16(%rsp), %rcx movq %rcx, (%rdi) movq 8(%rsp), %rcx movq %rcx, 8(%rdi) movq %rdx, 16(%rdi) ret # long eval(long x, long y, long z) # x in %rdi, y in %rsi, z in %rdx eval: subq $104, %rsp movq %rdx, 24(%rsp) leaq 24(%rsp), %rax movq %rdi, (%rsp) movq %rsi, 8(%rsp) movq %rax, 16(%rsp) leaq 64(%rsp), %rdi call process movq 72(%rsp), %rax addq 64(%rsp), %rax addq 80(%rsp), %rax addq $104, %rsp ret A.</description></item><item><title>3.68</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.68/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.68/</guid><description># void setVal(str1* p, str2* q) # p in %rdi, q in %rsi setVal: # 8(%rsi) fetch q-&amp;gt;t, int t is aligned by 4, so 4 &amp;lt; B &amp;lt;=8 movslq 8(%rsi), %rax # 32(%rsi) fetch q-&amp;gt;u, long u is aligned by 8 # offset q-&amp;gt;s is offset q-&amp;gt;t + 4, so 24 &amp;lt; 12 + A*2 &amp;lt;= 32 addq 32(%rsi), %rax # 184(%rdi) fetch p-&amp;gt;v, long y is aligned by 8, so 176 &amp;lt; A*B*4 &amp;lt;= 184 movq %rax, 184(%rdi) ret 4 &amp;lt; B &amp;lt;= 8 5 &amp;lt; A &amp;lt;= 10 44 &amp;lt; A*B &amp;lt;= 46 only</description></item><item><title>3.69</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.69/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.69/</guid><description>/* * 3.69.c */ typedef struct { int first; a_struct a[CNT]; int last; } b_struct; void test(long i, b_struct *bp) { int n = bp-&amp;gt;first + bp-&amp;gt;last; a_struct *ap = &amp;amp;bp-&amp;gt;a[i]; ap-&amp;gt;x[ap-&amp;gt;idx] = n; } # void test(long i, b_struct *bp) # i in %rdi, bp in %rsi test: mov 0x120(%rsi), %ecx # bp+0x120 fetch bp-&amp;gt;last add (%rsi), %ecx # bp-&amp;gt;first + bp-&amp;gt;last lea (%rdi,%rdi,4), %rax # i*5 lea (%rsi,%rax,8), %rax # bp+i*40 # ap = &amp;amp;bp-&amp;gt;a[i] = bp+i*40+8, +8 means skip int first # so a_struct is aligned by 8, size is 40 # check last instrction, %rdx here saves value ap-&amp;gt;idx!</description></item><item><title>3.70</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.70/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.70/</guid><description>A.
val offset e1.p 0 e1.y 8 e2.x 0 e2.next 8 B.
16
C.
# void proc(union ele *up) # up in %rdi proc: # %rax = *(up+8), don&amp;#39;t know it&amp;#39;s next or y movq 8(%rdi), %rax # %rdx = *( *(up+8) ), %rax stands for a pointer # so *( *(up+8) ) means *(up-&amp;gt;e2.</description></item><item><title>3.71</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.71/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.71/</guid><description>/* * good-echo.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#define BUF_SIZE 12 void good_echo(void) { char buf[BUF_SIZE]; while(1) { /* function fgets is interesting */ char* p = fgets(buf, BUF_SIZE, stdin); if (p == NULL) { break; } printf(&amp;#34;%s&amp;#34;, p); } return; } int main(int argc, char* argv[]) { good_echo(); return 0; }</description></item><item><title>3.72</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.72/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.72/</guid><description>/* * 3.72.c */ #include &amp;lt;alloca.h&amp;gt; long aframe(long n, long idx, long *q) { long i; long **p = alloca(n * sizeof(long*)); p[0] = &amp;amp;i; for (i = 1; i &amp;lt; n; i++) { p[i] = q; } return *p[idx]; } # long aframe(long n, long idx, long *q) # n in %rdi, idx in %rsi, q in %rdx aframe: pushq %rbp movq %rsp, %rbp subq $16, %rsp leaq 30(,%rdi,8), %rax andq $-16, %rax subq %rax, %rsp leaq 15(%rsp), %r8 andq $-16, %r8 A.</description></item><item><title>3.73</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.73/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.73/</guid><description>/* * 3.73.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x) { __asm__( &amp;#34;vxorps %xmm1, %xmm1, %xmm1\n\t&amp;#34; &amp;#34;vucomiss %xmm1, %xmm0\n\t&amp;#34; &amp;#34;jp .P\n\t&amp;#34; &amp;#34;ja .A\n\t&amp;#34; &amp;#34;jb .B\n\t&amp;#34; &amp;#34;je .E\n\t&amp;#34; &amp;#34;.A:\n\t&amp;#34; &amp;#34;movl $2, %eax\n\t&amp;#34; &amp;#34;jmp .Done\n\t&amp;#34; &amp;#34;.B:\n\t&amp;#34; &amp;#34;movl $0, %eax\n\t&amp;#34; &amp;#34;jmp .Done\n\t&amp;#34; &amp;#34;.E:\n\t&amp;#34; &amp;#34;movl $1, %eax\n\t&amp;#34; &amp;#34;jmp .Done\n\t&amp;#34; &amp;#34;.P:\n\t&amp;#34; &amp;#34;movl $3, %eax\n\t&amp;#34; &amp;#34;.Done:\n\t&amp;#34; ); } int main(int argc, char* argv[]) { range_t n = NEG, z = ZERO, p = POS, o = OTHER; assert(o == find_range(0.</description></item><item><title>3.74</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.74/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.74/</guid><description>/* * 3.74.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x) { __asm__( &amp;#34;vxorps %xmm1, %xmm1, %xmm1\n\t&amp;#34; &amp;#34;movq $1, %rax\n\t&amp;#34; &amp;#34;movq $2, %r8\n\t&amp;#34; &amp;#34;movq $0, %r9\n\t&amp;#34; &amp;#34;movq $3, %r10\n\t&amp;#34; &amp;#34;vucomiss %xmm1, %xmm0\n\t&amp;#34; &amp;#34;cmovaq %r8, %rax\n\t&amp;#34; &amp;#34;cmovbq %r9, %rax\n\t&amp;#34; &amp;#34;cmovpq %r10, %rax\n\t&amp;#34; ); } int main(int argc, char* argv[]) { range_t n = NEG, z = ZERO, p = POS, o = OTHER; assert(o == find_range(0.</description></item><item><title>3.75</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.75/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.75/</guid><description>A.
param n real img 1 %xmm0 %xmm1 2 %xmm2 %xmm3 3 %xmm4 %xmm5 n &amp;hellip; &amp;hellip; B.
return %xmm0 as real part, %xmm1 as img part</description></item></channel></rss>