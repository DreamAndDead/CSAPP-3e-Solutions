<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Processor Architecture on CASPP 3e Solutions</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/</link><description>Recent content in Processor Architecture on CASPP 3e Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Feb 2021 09:15:46 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/index.xml" rel="self" type="application/rss+xml"/><item><title>4.45</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.45/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.45/</guid><description>subq $8, %rsp movq REG, (%rsp) A.
No
if REG is %rsp, we push %rsp-8 instead of %rsp into stack
B.
movq REG, -8(%rsp) subq $8, %rsp</description></item><item><title>4.46</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.46/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.46/</guid><description>movq (%rsp), REG addq $8, %rsp A.
No
if REG is %rsp, movq (%rsp), REG pop the right value into %rsp, but addq $8, %rsp modify it
B.
addq $8, %rsp movq 8(%rsp), REG</description></item><item><title>4.47</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.47/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.47/</guid><description>A.
Change into pointer version
/* * bubble-sort-pointer.c */ void bubble_p(long* data, long count) { long *i, *last; for (last = data+count-1; last &amp;gt; data; last--) { for (i = data; i &amp;lt; last; i++) { if (*(i+1) &amp;lt; *i) { /* swap adjacent elements */ long t = *(i+1); *(i+1) = *i; *i = t; } } } } B.
Compile bubble-sort-pointer.c
gcc -S -Og bubble-sort-pointer.c get gas file</description></item><item><title>4.48</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.48/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.48/</guid><description>a little easy changes.
/* bubble-sort-pointer.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 data: .quad 0x0000000000000004 .quad 0x0000000000000003 .quad 0x0000000000000002 data_end: .quad 0x0000000000000001 main: irmovq data,%rdi irmovq data_end,%rsi call ysBubbleP ret # long ys_bubble_p(long *data, long *end) # data in %rdi, end in %rsi ysBubbleP: jmp L2 L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 ############################################################## # begin differences ############################################################## cmovl %r9, %r11 cmovl %r10, %r9 cmovl %r11, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax) ############################################################## # end ############################################################## irmovq $8, %r8 addq %r8, %rax jmp L5 L6: rrmovq %rdi, %rax L5: rrmovq %rsi, %r8 subq %rax, %r8 jg L4 irmovq $8, %r8 subq %r8, %rsi L2: rrmovq %rsi, %r8 subq %rdi, %r8 jg L6 ret .</description></item><item><title>4.49</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.49/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.49/</guid><description>it&amp;rsquo;s a brilliant idea, 3 xor is a normal swap
if x = 9, y = 10
x = x ^ y x:9^10; y:10 y = x ^ y x:9^10; y:9 x = x ^ y x:10; y:9 if change y after step 1
tmp = x x:9; y:10; tmp:9 # store x x = x ^ y x:9^10; y:10 y = tmp x:9^10; y:9 # set y to origin x y = x ^ y x:9^10; y:10 x = x ^ y x:9; y:10 no swap happens.</description></item><item><title>4.50</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.50/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.50/</guid><description>/* switch.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 array: .quad 0x0000000000000000 .quad 0x0000000000000000 .quad 0x0000000000000000 .quad 0x0000000000000000 main: # test number 1, -1, 3, 5 irmovq array, %r10 irmovq $1,%rdi call switchv rmmovq %rax, (%r10) irmovq $-1,%rdi call switchv rmmovq %rax, 8(%r10) irmovq $3,%rdi call switchv rmmovq %rax, 16(%r10) irmovq $5,%rdi call switchv rmmovq %rax, 24(%r10) ret table: .quad LD # default branch .</description></item><item><title>4.51</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.51/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.51/</guid><description> phase iaddq V,rB F icode:ifun = M1[PC]; rA:rB = M1[PC+1]; valC = M8[PC+2]; valP = PC + 10; D valB = R[rB] E valE = valB + valC; set CC M W R[rB] = valE PC PC = valP</description></item><item><title>4.52</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.52/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.52/</guid><description>easy changes if you make 4.51 right.
check whole file ./chapter4/code/sim/seq/seq-full.hcl with iaddq functionality
only watch changes with origin seq-full.hcl file
(cd ./site/content/chapter4/code/sim/seq; diff -u origin-seq-full.hcl seq-full.hcl) --- origin-seq-full.hcl 2021-02-25 07:26:33.312592690 +0000 +++ seq-full.hcl 2021-02-25 07:26:33.312592690 +0000 @@ -107,16 +107,16 @@ bool instr_valid = icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, - IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; + IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ }; # Does fetched instruction require a regid byte?</description></item><item><title>4.53</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.53/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.53/</guid><description>1. data hazard something handled by data-forward must be handled by stall if no data-forward anymore. so when
d_srcA in { e_dstE, M_dstM, M_dstE, W_dstM, W_dstE } || d_srcB in { e_dstE, M_dstM, M_dstE, W_dstM, W_dstE } data hazard happens, we have to insert bubble in phase E and stall phase F&amp;amp;D
load/use hazard
load/use hazard only happens when we use data-forward. no load/use hazard if no data-forward.
pay attention</description></item><item><title>4.54</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.54/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.54/</guid><description>almost same like 4.51 seq-full.hcl
check file ./site/content/chapter4/code/sim/pipe/pipe-full.hcl with iaddq functionality
watch changes with origin pipe-full.hcl file
(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-full.hcl pipe-full.hcl) --- origin-pipe-full.hcl 2021-02-25 07:26:33.309259378 +0000 +++ pipe-full.hcl 2021-02-25 07:26:33.309259378 +0000 @@ -158,7 +158,7 @@ # Is instruction valid? bool instr_valid = f_icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, - IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; + IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ }; # Determine status code for fetched instruction word f_stat = [ @@ -171,11 +171,11 @@ # Does fetched instruction require a regid byte?</description></item><item><title>4.55</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.55/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.55/</guid><description>Problem mismatch with skeleton code, we follow the code here: change J_YES to UNCOND
one point is
M_icode == IJXX &amp;amp;&amp;amp; M_ifun != UNCOND means all jxx except jmp instruction
another important point is Mispredicted branch condition
origin
(E_icode == IJXX &amp;amp;&amp;amp; !e_Cnd) now
(E_icode == IJXX &amp;amp;&amp;amp; E_ifun != UNCOND &amp;amp;&amp;amp; e_Cnd) if e_Cnd means misprediction
check file ./site/content/chapter4/code/sim/pipe/pipe-nt.hcl
watch changes with origin pipe-nt.hcl
(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-nt.</description></item><item><title>4.56</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.56/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.56/</guid><description>Problem mismatch with skeleton code, we follow the code here: change J_YES to UNCOND
almost same like 4.55. main differences are
pay attention to whether valC is greater or lower than valP pass both valC and valP back by M registers because if misprediction happens we need judge jumping back to valC or valP check file ./site/content/chapter4/code/sim/pipe/pipe-btfnt.hcl
only watch changes with origin pipe-btfnt.hcl
(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-btfnt.hcl pipe-btfnt.</description></item><item><title>4.57</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.57/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.57/</guid><description>A.
consider load/use hazard
E_icode in { IMRMOVQ, IPOPQ } &amp;amp;&amp;amp; E_dstM in { d_srcA, d_srcB }; situation 1 2 3 4 E_dstM == d_srcA 1 1 0 0 E_dstM == d_srcB 1 0 1 0 situation 4:
normal, no hazard happens
situation 1,2,3:
load/use hazard happens
if E_icode in { IMRMOVQ, IPOPQ }, then E_dstM must not be RNONE</description></item><item><title>4.58</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.58/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.58/</guid><description>it&amp;rsquo;s not a hard problem, focus on key points:
fetch popq instruction twice. first time fetch popq, works like iaddq; second time fetch popq2, works like mrmovq load/use condition should be popq2 not popq. phase popq rA popq2 rA works like iadd $8, %rsp mrmovq -8(%rsp), rA F valP = PC valP = PC + 2 D valB=R[rsp] valB=R[rsp] E valE=valB+8 valE=valB-8 M valM=M8[valE] W R[rsp]=valE R[rA]=valM check file .</description></item><item><title>4.59</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.59/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.59/</guid><description>4.47 is the better one
loop part in 4.47
L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 jge L3 rmmovq %r10, 8(%rax) rmmovq %r9, (%rax) 50% jge is right, run 5 instructions; 50% jge is wrong, run 7 instructions and 2 nop bubble. so Cycles Per Loop is 50% * 5 + (7 + 2) * 50% = 7
loop part in 4.48
L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 cmovl %r9, %r11 cmovl %r10, %r9 cmovl %r11, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax) Cycles Per Loop is 9</description></item></channel></rss>