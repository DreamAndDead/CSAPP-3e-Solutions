<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Optimizing Program Performance on CASPP 3e Solutions</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/</link><description>Recent content in Optimizing Program Performance on CASPP 3e Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Feb 2021 09:15:46 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/index.xml" rel="self" type="application/rss+xml"/><item><title>5.13</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.13/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.13/</guid><description>A.
+----+----+----+----+-----+-----+ |%rbp|%rcx|%rax|%rbx|%xmm1|%xmm0| +----+----+----+----+-----+-----++----+ +----|----|----|----------|---&amp;gt;| | | +----|----|----------|---&amp;gt;|load| vmovad 0(%rbp,%rcx,8),%xmm1 | | | | +-----|----| | | | | | | | +----+ | +----|----|----------|---&amp;gt;| | | | | | | | |load|---+ | | +----|----------|---&amp;gt;| | | | | | | | | +----+ | vmulsd (%rax,%rcx,8),%xmm1,%xmm0 | | | | | | | |&amp;lt;--+ | | | | +-----|---&amp;gt;|mul | | | | | +-----|----| | | | | | | | +----+ | | | | +-----|---&amp;gt;| | | | | | | +---&amp;gt;|add | vaddsd %xmm1,%xmm0,%xmm0 | | | | | +----| | | | | | | | +----+ | +----|----|----------|---&amp;gt;| | | | | | | |add | addq $1, %rcx | +----|----|----------|----| | | | | | | | +----+ | +----|----|----------|---&amp;gt;| | | | | | | | |cmp |---+ cmpq %rbx, %rcx | | | +----|-----|---&amp;gt;| | | | | | | | | +----+ | | | | | | | | | | | | | | | | |jne |&amp;lt;--+ jne .</description></item><item><title>5.14</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.14/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.14/</guid><description>+----+ +----+ |sum | | i | +----+ +----+ | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | | v | +----+ | |add | | &amp;lt;------- key path +----+ | | | | v v +----+ +-+--+ |sum | | i | +----+ +----+ A.</description></item><item><title>5.15</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.15/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.15/</guid><description>maybe
float mul capatity limit(less than 6) register renaming limit /* * 5.15.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;./lib/vec.h&amp;#34; #define LEN 24 /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; data_t sum1 = (data_t) 0; data_t sum2 = (data_t) 0; data_t sum3 = (data_t) 0; data_t sum4 = (data_t) 0; data_t sum5 = (data_t) 0; for (i = 0; i &amp;lt; length-6; i+=6) { sum = sum + udata[i] * vdata[i]; sum1 = sum1 + udata[i+1] * vdata[i+1]; sum2 = sum2 + udata[i+2] * vdata[i+2]; sum3 = sum3 + udata[i+3] * vdata[i+3]; sum4 = sum4 + udata[i+4] * vdata[i+4]; sum5 = sum5 + udata[i+5] * vdata[i+5]; } for(; i &amp;lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum + sum1 + sum2 + sum3 + sum4 + sum5; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[11] = 1; arr[2] = 2; arr[23] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, &amp;amp;res); assert(res == 1+4+9); return 0; }</description></item><item><title>5.16</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.16/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.16/</guid><description>/* * 5.16.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;./lib/vec.h&amp;#34; #define LEN 24 /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; for (i = 0; i &amp;lt; length-6; i+=6) { sum = sum + ( udata[i] * vdata[i] + udata[i+1] * vdata[i+1] + udata[i+2] * vdata[i+2] + udata[i+3] * vdata[i+3] + udata[i+4] * vdata[i+4] + udata[i+5] * vdata[i+5] ); } for(; i &amp;lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[11] = 1; arr[2] = 2; arr[23] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, &amp;amp;res); assert(res == 1+4+9); return 0; }</description></item><item><title>5.17</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.17/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.17/</guid><description>/* * 5.17.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;assert.h&amp;gt; void* basic_memset(void *s, int c, size_t n) { size_t cnt = 0; unsigned char *schar = s; while (cnt &amp;lt; n) { *schar++ = (unsigned char) c; cnt++; } return s; } /* * K = sizeof(unsigned long) * cs store K chars for memset */ void* effective_memset(void *s, unsigned long cs, size_t n) { /* align to K */ size_t K = sizeof(unsigned long); size_t cnt = 0; unsigned char *schar = s; while (cnt &amp;lt; n) { if ((size_t)schar % K == 0) { break; } *schar++ = (unsigned char)cs; cnt++; } /* set K chars one time */ unsigned long *slong = (unsigned long *)schar; size_t rest = n - cnt; size_t loop = rest / K; size_t tail = rest % K; for (size_t i = 0; i &amp;lt; loop; i++) { *slong++ = cs; } /* pad the tail part */ schar = (unsigned char *)slong; for (size_t i = 0; i &amp;lt; tail; i++) { *schar++ = (unsigned char)cs; } return s; } int main(int argc, char* argv[]) { size_t space = sizeof(char) * 65537; // careful!</description></item><item><title>5.18</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.18/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.18/</guid><description>try to write 6*3a version for function holy.
this solution is not fully tested on my machine, sorry for that :(
uname -p Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz
if your machine core is Intel Core i7 Haswell like book, you can try install google gperftools for profile
(cd ./site/content/chapter5/code; make 5.18.prof) loop more times is a good idea :)
/* * 5.18.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.</description></item><item><title>5.19</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.19/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.19/</guid><description>this solution&amp;rsquo;s performance is not fully meassured.
if you&amp;rsquo;re interested, you can try install google&amp;rsquo;s gperftools for profile
(cd ./site/content/chapter5/code; make 5.19.prof) loop more times is a good idea :)
/* * 5.19.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; void psum1a(float a[], float p[], long n) { long i; float last_val, val; last_val = p[0] = a[0]; for (i = 1; i &amp;lt; n; i++) { val = last_val + a[i]; p[i] = val; last_val = val; } } /* version 4*1a */ void psum_4_1a(float a[], float p[], long n) { long i; float val, last_val; float tmp, tmp1, tmp2, tmp3; last_val = p[0] = a[0]; for (i = 1; i &amp;lt; n - 4; i++) { tmp = last_val + a[i]; tmp1 = tmp + a[i+1]; tmp2 = tmp1 + a[i+2]; tmp3 = tmp2 + a[i+3]; p[i] = tmp; p[i+1] = tmp1; p[i+2] = tmp2; p[i+3] = tmp3; /* key point */ last_val = last_val + (a[i] + a[i+1] + a[i+2] + a[i+3]); } for (; i &amp;lt; n; i++) { last_val += a[i]; p[i] = last_val; } } #define LOOP 1000 #define LEN 1000 int main(int argc, char* argv[]) { float a[5] = { 1, 2, 3, 4, 5 }; float p[5]; psum1a(a, p, 5); assert(p[4] == 15); float q[5]; psum_4_1a(a, q, 5); assert(q[4] == 15); /* for prof */ for (int i = 0; i &amp;lt; LOOP; i++) { float s[LEN]; float d[LEN]; psum1a(s, d, LEN); psum_4_1a(s, d, LEN); } return 0; }</description></item></channel></rss>