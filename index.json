[{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter1/","title":"A Tour of Computer Systems","tags":[],"description":"","content":"Chapter 1 A Tour of Computer Systems  Computer science is no more about computers than astronomy is about telescopes.\nby Edsger Dijkstra\n No homework in this chapter.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/","title":"Representing and Manipulating Information","tags":[],"description":"","content":"Chapter 2 Representing and Manipulating Information  Everything is physics and math.\nby Katherine Johnson\n    solution code file test way     2.55 show-bytes.c output   2.56 show-bytes.c output   2.57 show-bytes-more.c output   2.58 is-little-endian.c assert   2.59 generate-a-word.c assert   2.60 replace-byte.c assert   2.61 2.61.c assert   2.62 int-shifts-are-arithemetic.c assert   2.63 srl-sra.c assert   2.64 any-odd-one.c assert   2.65 odd-ones.c assert   2.66 leftmost-one.c assert   2.67 int-size-is-32.c assert   2.68 lower-one-mask.c assert   2.69 rotate-left.c assert   2.70 fits-bits.c assert   2.71 xbyte.c assert   2.72 copy-int.c assert   2.73 saturating-add.c assert   2.74 tsub-ok.c assert   2.75 unsigned-high-prod.c assert   2.76 calloc.c assert   2.77 2.77.c assert   2.78 divide-power2.c assert   2.79 mul3div4.c assert   2.80 threeforths.c assert   2.81 2.81.c assert   2.82 2.81.c assert   2.83 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;   2.84 float-le.c assert   2.85 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;   2.86 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;   2.87 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;   2.88 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;   2.89 2.89.c assert   2.90 fpwr2.c assert   2.91 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;   2.92 floats/float-negate.c assert   2.93 floats/float-absval.c assert   2.94 floats/float-twice.c assert   2.95 floats/float-half.c assert   2.96 floats/float-f2i.c assert   2.97 floats/float-i2f.c assert    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/","title":"Machine-Level Representation of Programs","tags":[],"description":"","content":"Chapter 3 Machine-Level Representation of Programs  To understand a program, you must become both the machine and the program.\nby Alan Perlis\n    solution code file test way     3.58 decode2/(decode.c, decode2.s. main.c) assert   3.59 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.60 loop/loop.s, loop2.c, main.c assert   3.61 cread/(cread-alt.c, cread-alt.s, cread.s) assert   3.62 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.63 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.64 store-ele/(store-ele.s, store-ele2.c, main.c) assert   3.65 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.66 sum-col/(sum-col.s, sum-col2.c, main.c) assert   3.67 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.68 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.69 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.70 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.71 good-echo/good-echo.c output   3.72 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   3.73 3.73.c assert   3.74 3.74.c assert   3.75 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/","title":"Processor Architecture","tags":[],"description":"","content":"Chapter 4 Processor Architecture  The speed at which modern CPUs perform computations still blows my mind daily.\nby Markus Persson\n This chapter focus on processor architecture and design a little simple processor and yas \u0026ndash; a assemble language \u0026ndash; designed running on it.\nyou can access the processor simulation code and simulation manual from csapp official site.\nsimulation code\nsimulator manual\nI have saved the simulation code in directory chapter4/code/sim.\nHighly recommend you read the manual and README in code to know how it works and how to test yas code.\n   solution code file test way     4.45 \u0026ndash; \u0026ndash;   4.46 \u0026ndash; \u0026ndash;   4.47 bubble-sort/bubble-sort-pointer.* output, assert   4.48 bubble-sort/bubble-sort-pointer-3-cmove.* output   4.49 bubble-sort/bubble-sort-pointer-1-cmove.* output   4.50 switch/* output   4.51 \u0026ndash; \u0026ndash;   4.52 sim/seq/seq-full.hcl yas   4.53 sim/pipe/pip-stall.hcl yas   4.54 sim/pipe/pip-full.hcl yas   4.55 sim/pipe/pip-nt.hcl yas   4.56 sim/pipe/pip-btfnt.hcl yas   4.57 sim/pipe/pip-lf.hcl yas   4.58 sim/pipe/pip-1w.hcl yas   4.59 \u0026ndash; \u0026ndash;    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/","title":"Optimizing Program Performance","tags":[],"description":"","content":"Chapter 5 Optimizing Program Performance  We are all tasked to balance and optimize ourselves.\nby Mae Jemison\n    solution code file test way     5.13 5.13.c assert   5.14 5.14.c assert   5.15 5.15.c assert   5.16 5.16.c assert   5.17 5.17.c assert   5.18 5.18.c assert   5.19 5.19.c assert    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.6/","title":"10.6","tags":[],"description":"","content":"fd = 4  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.6/","title":"11.6","tags":[],"description":"","content":"A.\n--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.6.c\t2021-02-25 07:26:33.302592754 +0000 @@ -13,6 +13,8 @@  void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void echo(int connfd); +  int main(int argc, char **argv) { int listenfd, connfd; @@ -33,11 +35,24 @@  Getnameinfo((SA *) \u0026amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(\u0026#34;Accepted connection from (%s, %s)\\n\u0026#34;, hostname, port); - doit(connfd); //line:netp:tiny:doit + echo(connfd);  Close(connfd); //line:netp:tiny:close } } +void echo(int connfd) { + size_t n; + char buf[MAXLINE]; + rio_t rio; + + Rio_readinitb(\u0026amp;rio, connfd); + while ((n = Rio_readlineb(\u0026amp;rio, buf, MAXLINE)) != 0) { + if (strcmp(buf, \u0026#34;\\r\\n\u0026#34;) == 0) + break; + Rio_writen(connfd, buf, n); + } +} +  /* * doit - handle one HTTP request/response transaction */  B.\n./tiny.6 5000 run server and firefox visit localhost:5000\nGET / HTTP/1.1 Host: localhost:5000 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive C.\nHTTP 1.1\nD.\nvisit rfc section 14 Header Field Definitions\nAccept: 14.1\nThe Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.\nAccept-Encoding: 14.3\nThe Accept-Encoding request-header field is similar to Accept, but restricts the content-codings that are acceptable in the response.\nAccept-Language: 14.4\nThe Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Language tags are defined in section 3.10.\nConnection: 14.10\nThe Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.\nHost: 14.23\nThe Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from the original URI given by the user or referring resource. The Host field value MUST represent the naming authority of the origin server or gateway given by the original URL. This allows the origin server or gateway to differentiate between internally-ambiguous URLs, such as the root “/” URL of a server for multiple host names on a single IP address.\nUser-Agent: 14.43\nThe User-Agent request-header field contains information about the user agent originating the request. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens (section 3.8) and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.6/","title":"7.6","tags":[],"description":"","content":"/* * swap.c */ extern int buf[]; int* bufp0 = \u0026amp;buf[0]; static int* bufp1; static void incr() { static int count=0; count++; } void swap() { int temp; incr(); bufp1 = \u0026amp;buf[1]; temp = *bufp0; *bufp0 = *bufp1; *bufp1 = temp; }      in .symtab? type module section     buf Yes external m .data   bufp0 Yes global swap .data   bufp1 Yes local swap .bss   swap Yes global swap .text   temp No \u0026mdash;\u0026mdash; \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;   incr Yes local swap .text   count Yes local swap .bss    (cd ./site/content/chapter7/code/7.6; make \u0026amp;\u0026amp; make sym)  output:\ngcc -c swap.c objdump -t swap.o swap.o： 文件格式 elf64-x86-64 SYMBOL TABLE: 0000000000000000 l O .bss\t0000000000000008 bufp1 0000000000000000 l F .text\t0000000000000015 incr 0000000000000008 l O .bss\t0000000000000004 count.1747 0000000000000000 g O .data\t0000000000000008 bufp0 0000000000000000 *UND*\t0000000000000000 buf 0000000000000015 g F .text\t0000000000000049 swap  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/","title":"The Memory Hierarchy","tags":[],"description":"","content":"Chapter 6 The Memory Hierarchy  The more storage you have, the more stuff you accumulate.\nby Alexis Stewart\n    solution code file test way     6.22 \u0026mdash;- \u0026mdash;-   6.23 \u0026mdash;- \u0026mdash;-   6.24 \u0026mdash;- \u0026mdash;-   6.25 \u0026mdash;- \u0026mdash;-   6.26 \u0026mdash;- \u0026mdash;-   6.27 \u0026mdash;- \u0026mdash;-   6.28 \u0026mdash;- \u0026mdash;-   6.29 \u0026mdash;- \u0026mdash;-   6.30 \u0026mdash;- \u0026mdash;-   6.31 \u0026mdash;- \u0026mdash;-   6.32 \u0026mdash;- \u0026mdash;-   6.33 \u0026mdash;- \u0026mdash;-   6.34 \u0026mdash;- \u0026mdash;-   6.35 \u0026mdash;- \u0026mdash;-   6.36 \u0026mdash;- \u0026mdash;-   6.37 \u0026mdash;- \u0026mdash;-   6.38 \u0026mdash;- \u0026mdash;-   6.39 \u0026mdash;- \u0026mdash;-   6.40 \u0026mdash;- \u0026mdash;-   6.41 \u0026mdash;- \u0026mdash;-   6.42 \u0026mdash;- \u0026mdash;-   6.43 \u0026mdash;- \u0026mdash;-   6.44 \u0026mdash;- \u0026mdash;-   6.45 transpose.c no test, mainly measure performance   6.46 convert.c no test, mainly measure performance    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.7/","title":"10.7","tags":[],"description":"","content":"/* * 10.7.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; int main(int argc, char* argv[]) { int n; char buf[MAXBUF]; while ((n = Rio_readn(STDIN_FILENO, buf, MAXBUF)) != 0) Rio_writen(STDOUT_FILENO, buf, n); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.7/","title":"11.7","tags":[],"description":"","content":"visit mdn to check all mime type\n--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.7.c\t2021-02-25 07:26:33.302592754 +0000 @@ -173,6 +173,8 @@  strcpy(filetype, \u0026#34;image/png\u0026#34;); else if (strstr(filename, \u0026#34;.jpg\u0026#34;)) strcpy(filetype, \u0026#34;image/jpeg\u0026#34;); + else if (strstr(filename, \u0026#34;.mpeg\u0026#34;)) + strcpy(filetype, \u0026#34;video/mpeg\u0026#34;);  else strcpy(filetype, \u0026#34;text/plain\u0026#34;); }  run server\n(cd ./site/content/chapter11/code; make \u0026amp;\u0026amp; ./tiny.7 5000)  browser visit\nhttp://localhost:5000/ghost-in-shell.mpeg  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.7/","title":"7.7","tags":[],"description":"","content":"/* * bar5.c */ double x; void f() { /*x = -0.0;*/ }  delete line\nx = -0.0;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/","title":"Linking","tags":[],"description":"","content":"Chapter 7 Linking  Our ultimate goal is extensible programming. By this, we mean the construction of hierarchies of modules, each module adding new functionality to the system.\nby Niklaus Wirth\n    solution code file test way     7.6 7.6/swap.c \u0026mdash;-   7.7 7.7/* output   7.8 \u0026mdash;- \u0026mdash;-   7.9 7.9/* output   7.10 \u0026mdash;- \u0026mdash;-   7.11 \u0026mdash;- \u0026mdash;-   7.12 \u0026mdash;- \u0026mdash;-   7.13 7.13/* \u0026mdash;-    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.8/","title":"10.8","tags":[],"description":"","content":"/* * 10.8.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; int main(int argc, char* argv[]) { struct stat stat; char *type, *readok; int fd; if (argc \u0026lt;= 1) fd = 0; // stdin  else fd = atoi(argv[1]); Fstat(fd, \u0026amp;stat); if (S_ISREG(stat.st_mode)) type = \u0026#34;regular\u0026#34;; else if (S_ISDIR(stat.st_mode)) type = \u0026#34;dir\u0026#34;; else type = \u0026#34;other\u0026#34;; if ((stat.st_mode \u0026amp; S_IRUSR)) readok = \u0026#34;yes\u0026#34;; else readok = \u0026#34;no\u0026#34;; printf(\u0026#34;type: %s, read: %s\\n\u0026#34;, type, readok); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.8/","title":"11.8","tags":[],"description":"","content":"--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.8.c\t2021-02-25 07:26:33.302592754 +0000 @@ -12,6 +12,7 @@  void serve_dynamic(int fd, char *filename, char *cgiargs); void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void sigchild_handler(int sig);  int main(int argc, char **argv) { @@ -26,6 +27,9 @@  exit(1); } + if (Signal(SIGCHLD, sigchild_handler) == SIG_ERR) + unix_error(\u0026#34;signal child handler error\u0026#34;); +  listenfd = Open_listenfd(argv[1]); while (1) { clientlen = sizeof(clientaddr); @@ -38,6 +42,15 @@  } } +void sigchild_handler(int sig) { + int old_errno = errno; + int status; + pid_t pid; + while ((pid = waitpid(-1, \u0026amp;status, WNOHANG)) \u0026gt; 0) { + } + errno = old_errno; +} +  /* * doit - handle one HTTP request/response transaction */ @@ -196,7 +209,6 @@  Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */ //line:netp:servedynamic:dup2 Execve(filename, emptylist, environ); /* Run CGI program */ //line:netp:servedynamic:execve } - Wait(NULL); /* Parent waits for and reaps child */ //line:netp:servedynamic:wait  } /*  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.8/","title":"7.8","tags":[],"description":"","content":"A.\nmain.1\nmain.2\nB.\nunknown\nunknown\nC.\nerror\nerror\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/","title":"Exceptional Control Flow","tags":[],"description":"","content":"Chapter 8 Exceptional Control Flow  Nature provides exceptions to every rule.\nby Margaret Fuller\n csapp.h \u0026amp; csapp.c is downloaded from csapp official site\n   solution code file test way     8.9 \u0026mdash;- \u0026mdash;-   8.10 \u0026mdash;- \u0026mdash;-   8.11 8.11.c output   8.12 8.12.c output   8.13 8.13.c output   8.14 8.14.c output   8.15 8.15.c output   8.16 8.16.c output   8.17 \u0026mdash;- \u0026mdash;-   8.18 8.18.c output   8.19 8.19.c output   8.20 8.20.c output   8.21 8.21.c output   8.22 mysystem.c, exit-code.c, wait-sig.c output   8.23 8.23.c output   8.24 8.24.c output   8.25 8.25.c output   8.26 shell/* output    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.9/","title":"10.9","tags":[],"description":"","content":"if (Fork() == 0) { Dup2(0, 3); Execve(\u0026#34;fstatcheck\u0026#34;, argv, envp); } "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.9/","title":"11.9","tags":[],"description":"","content":"--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.9.c\t2021-02-25 07:26:33.302592754 +0000 @@ -152,12 +152,12 @@  printf(\u0026#34;Response headers:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, buf); - /* Send response body to client */  srcfd = Open(filename, O_RDONLY, 0); //line:netp:servestatic:open - srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);//line:netp:servestatic:mmap + srcp = (char*)Malloc(filesize); + Rio_readn(srcfd, srcp, filesize);  Close(srcfd); //line:netp:servestatic:close Rio_writen(fd, srcp, filesize); //line:netp:servestatic:write - Munmap(srcp, filesize); //line:netp:servestatic:munmap + free(srcp);  } /*  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.9/","title":"7.9","tags":[],"description":"","content":"function main print 0x55 on my machine.\nmodify char main to unsigned int main here\n/* * bar6.c */ #include \u0026lt;stdio.h\u0026gt; unsigned int main; void p2() { printf(\u0026#34;0x%x\\n\u0026#34;, main); }  /* * foo6.c */ void p2(void); void offset(void) { return; } int main(int argc, char* argv[]) { p2(); return 0; } \n(cd ./site/content/chapter7/code/7.9; make \u0026amp;\u0026amp; ./main)  output:\ngcc foo6.c bar6.c -o main /usr/lib/gcc/x86_64-pc-linux-gnu/4.9.4/../../../../x86_64-pc-linux-gnu/bin/ld: Warning: alignment 1 of symbol `main' in /tmp/ccTBhRjm.o is smaller than 4 in /tmp/ccc3SjbF.o 0xe5894855  using objdump inspect\nobjdump -d main  find function main\n000000000040055d \u0026lt;main\u0026gt;: 40055d:\t55 push %rbp 40055e:\t48 89 e5 mov %rsp,%rbp 400561:\t48 83 ec 10 sub $0x10,%rsp 400565:\t89 7d fc mov %edi,-0x4(%rbp) 400568:\t48 89 75 f0 mov %rsi,-0x10(%rbp) 40056c:\te8 07 00 00 00 callq 400578 \u0026lt;p2\u0026gt; 400571:\tb8 00 00 00 00 mov $0x0,%eax 400576:\tc9 leaveq 400577:\tc3 retq  0xe5894855 is first 2 instructions content of function main.\nworks same like\n/* * another-bar6.c */ #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]); void p2() { printf(\u0026#34;0x%x\\n\u0026#34;, * (unsigned int *)main); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.9/","title":"8.9","tags":[],"description":"","content":"   process pair cocurrent?     AB No   AC Yes   AD Yes   BC Yes   BD Yes   CD Yes    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/","title":"Virtual Memory","tags":[],"description":"","content":"Chapter 9 Virtual Memory  I wanted to have virtual memory, at least as it\u0026rsquo;s coupled with file systems.\nby Ken Thompson\n    solution code file test way     9.11 \u0026mdash;- \u0026mdash;-   9.12 \u0026mdash;- \u0026mdash;-   9.13 \u0026mdash;- \u0026mdash;-   9.14 9.14.c assert   9.15 \u0026mdash;- \u0026mdash;-   9.16 \u0026mdash;- \u0026mdash;-   9.17 vm/(mm.9.17, 9.17.c) assert   9.18 vm/(mm.9.18, 9.18.c) assert   9.19 \u0026mdash;- \u0026mdash;-   9.20 malloc/* measure performance with std malloc    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.10/","title":"10.10","tags":[],"description":"","content":"/* * 10.10.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; int main(int argc, char* argv[]) { int n; rio_t rio; char buf[MAXLINE]; if (argc == 2) { int fd = Open(argv[1], O_RDONLY, 0); while ((n = Rio_readn(fd, buf, MAXBUF)) != 0) Rio_writen(STDOUT_FILENO, buf, n); exit(0); } Rio_readinitb(\u0026amp;rio, STDIN_FILENO); while ((n = Rio_readlineb(\u0026amp;rio, buf, MAXLINE)) != 0) Rio_writen(STDOUT_FILENO, buf, n); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.10/","title":"7.10","tags":[],"description":"","content":"A.\ngcc p.o libx.a  B.\ngcc p.o libx.a liby.a libx.a  C.\ngcc p.o libx.a liby.a libx.a libz.a  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/","title":"System-Level I/O","tags":[],"description":"","content":"Chapter 10 System-Level I/O  I think the major good idea in Unix was its clean and simple interface: open, close, read, and write.\nby Ken Thompson\n    solution code file test way     10.6 10.6.c output   10.7 10.7.c output   10.8 10.8.c output   10.9 \u0026mdash;- \u0026mdash;-   10.10 10.10.c output    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.11/","title":"7.11","tags":[],"description":"","content":"space for section .bss\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/","title":"Network Programming","tags":[],"description":"","content":"Chapter 11 Network Programming  640k is enough for anyone, and by the way, what’s a network?\nby William Gates III\n    solution code file test way     11.6 tiny.6.c browser   11.7 tiny.7.c browser   11.8 tiny.8.c browser   11.9 tiny.9.c browser   11.10 cgi-bin/form-adder.c, tiny.origin.c browser   11.11 cgi-bin/head-adder.c, tiny.11.c browser   11.12 cgi-bin/post-adder.c, tiny.12.c browser   11.13 tiny.13.c browser    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.12/","title":"7.12","tags":[],"description":"","content":"A.\nADDR(s) = ADDR(.text) = 0x4004e0\nADDR(r.symbol) = ADDR(swap) = 0x4004f8\nrefaddr = ADDR(s) + r.offset = 0x4004ea\n*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr) = 0xa\nB.\nADDR(s) = ADDR(.text) = 0x4004d0\nADDR(r.symbol) = ADDR(swap) = 0x400500\nrefaddr = ADDR(s) + r.offset = 0x4004da\n*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr) = 0x22\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/","title":"Concurrent Programming","tags":[],"description":"","content":"Chapter 12 Concurrent Programming  Multi-tasking arises out of distraction itself.\nby Marilyn vos Savant\n  need wrk to benchmark server in 35, 36, 37, 38 need package apache2-utils(required by command line ab) to benchmark proxy server     solution code file test way     12.16 12.16.c output   12.17 12.17.c output   12.18 \u0026mdash;- \u0026mdash;-   12.19 12.19.c output   12.20 12.20.c output   12.21 12.21.c output   12.22 12.22.c using telnet, more visit 12.22.md   12.23 12.23.c visit 12.23.md   12.24 \u0026mdash;- \u0026mdash;-   12.25 \u0026mdash;- \u0026mdash;-   12.26 12.26.c output   12.27 \u0026mdash;- \u0026mdash;-   12.28 \u0026mdash;- \u0026mdash;-   12.29 \u0026mdash;- \u0026mdash;-   12.30 \u0026mdash;- \u0026mdash;-   12.31 12.31.c run and input or BOOM after 5 seconds   12.32 12.32.c run and input or BOOM after 5 seconds   12.33 12.33.c run and input or BOOM after 5 seconds   12.34 12.34.c visit 12.34.md, how to measure performance   12.35 12.35.c benchmark   12.36 12.36/* benchmark   12.37 12.37.c benchmark   12.38 12.38/* benchmark   12.39 12.39/* benchmark, more see 12.39.md    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.13/","title":"7.13","tags":[],"description":"","content":"A.\nlibm.a path\nwhereis libm.a  output:\nlibm: /usr/lib64/libm.a /usr/lib64/libm.so  libm.a files\nar t /usr/lib64/libm.a  output:\ns_lib_version.o s_matherr.o s_signgam.o fclrexcpt.o fgetexcptflg.o fraiseexcpt.o fsetexcptflg.o ftestexcept.o fegetround.o fesetround.o fegetenv.o feholdexcpt.o fesetenv.o feupdateenv.o t_exp.o fedisblxcpt.o feenablxcpt.o fegetexcept.o powl_helper.o e_acos.o e_acosh.o e_asin.o e_atan2.o e_atanh.o ....  similar way for libc.a\nB.\ncompile code with -Og and -Og -g\n/* * little.c */ int main(int argc, char* argv[]) { return 0; }  (cd chapter7/code/7.13; make \u0026amp;\u0026amp; make dump-exe-code) # objdump -d og-little # objdump -d dog-little  they are same\nC.\nldd og-little  output:\nlinux-vdso.so.1 (0x00007ffef51d3000) libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00007f27c6b8b000) /lib64/ld-linux-x86-64.so.2 (0x00007f27c6f24000)  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.10/","title":"11.10","tags":[],"description":"","content":"A.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Tiny Server\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/cgi-bin/form-adder\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; \u0026lt;p\u0026gt;first number: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;first\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;second number: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;second\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  browser should visit localhost:5000/cgi-bin/form-adder?first=222\u0026amp;second=333\nB.\nform-adder handle query string like first=ddd\u0026amp;second=dddd\n/* * form-adder.c - a minimal CGI program that adds two numbers together */ #include \u0026#34;../csapp.h\u0026#34; int main(void) { char *buf, *p; char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE]; int n1=0, n2=0; /* Extract the two arguments */ if ((buf = getenv(\u0026#34;QUERY_STRING\u0026#34;)) != NULL) { p = strchr(buf, \u0026#39;\u0026amp;\u0026#39;); *p = \u0026#39;\\0\u0026#39;; sscanf(buf, \u0026#34;first=%d\u0026#34;, \u0026amp;n1); sscanf(p+1, \u0026#34;second=%d\u0026#34;, \u0026amp;n2); } /* Make the response body */ sprintf(content, \u0026#34;Welcome to add.com: \u0026#34;); sprintf(content, \u0026#34;%sTHE Internet addition portal.\\r\\n\u0026lt;p\u0026gt;\u0026#34;, content); sprintf(content, \u0026#34;%sThe answer is: %d + %d = %d\\r\\n\u0026lt;p\u0026gt;\u0026#34;, content, n1, n2, n1 + n2); sprintf(content, \u0026#34;%sThanks for visiting!\\r\\n\u0026#34;, content); /* Generate the HTTP response */ printf(\u0026#34;Connection: close\\r\\n\u0026#34;); printf(\u0026#34;Content-length: %d\\r\\n\u0026#34;, (int)strlen(content)); printf(\u0026#34;Content-type: text/html\\r\\n\\r\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, content); fflush(stdout); exit(0); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.11/","title":"11.11","tags":[],"description":"","content":"from rfc2626 section 9.4 HEAD\nThe HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.\ntiny.c changes\n--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.11.c\t2021-02-25 07:26:33.302592754 +0000 @@ -7,9 +7,9 @@  void doit(int fd); void read_requesthdrs(rio_t *rp); int parse_uri(char *uri, char *filename, char *cgiargs); -void serve_static(int fd, char *filename, int filesize); +void serve_static(int fd, char *filename, int filesize, char *method);  void get_filetype(char *filename, char *filetype); -void serve_dynamic(int fd, char *filename, char *cgiargs); +void serve_dynamic(int fd, char *filename, char *cgiargs, char *method);  void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); @@ -55,7 +55,7 @@  return; printf(\u0026#34;%s\u0026#34;, buf); sscanf(buf, \u0026#34;%s %s %s\u0026#34;, method, uri, version); //line:netp:doit:parserequest - if (strcasecmp(method, \u0026#34;GET\u0026#34;)) { //line:netp:doit:beginrequesterr + if (!(strcasecmp(method, \u0026#34;GET\u0026#34;) == 0 || strcasecmp(method, \u0026#34;HEAD\u0026#34;) == 0)) {  clienterror(fd, method, \u0026#34;501\u0026#34;, \u0026#34;Not Implemented\u0026#34;, \u0026#34;Tiny does not implement this method\u0026#34;); return; @@ -76,7 +76,7 @@  \u0026#34;Tiny couldn\u0026#39;t read the file\u0026#34;); return; } - serve_static(fd, filename, sbuf.st_size); //line:netp:doit:servestatic + serve_static(fd, filename, sbuf.st_size, method); //line:netp:doit:servestatic  } else { /* Serve dynamic content */ if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR \u0026amp; sbuf.st_mode)) { //line:netp:doit:executable @@ -84,7 +84,7 @@  \u0026#34;Tiny couldn\u0026#39;t run the CGI program\u0026#34;); return; } - serve_dynamic(fd, filename, cgiargs); //line:netp:doit:servedynamic + serve_dynamic(fd, filename, cgiargs, method); //line:netp:doit:servedynamic  } } @@ -136,7 +136,7 @@  /* * serve_static - copy a file back to the client */ -void serve_static(int fd, char *filename, int filesize) +void serve_static(int fd, char *filename, int filesize, char *method)  { int srcfd; char *srcp, filetype[MAXLINE], buf[MAXBUF]; @@ -152,6 +152,9 @@  printf(\u0026#34;Response headers:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, buf); + if (strcasecmp(method, \u0026#34;HEAD\u0026#34;) == 0) + return; +  /* Send response body to client */ srcfd = Open(filename, O_RDONLY, 0); //line:netp:servestatic:open srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);//line:netp:servestatic:mmap @@ -180,7 +183,7 @@  /* * serve_dynamic - run a CGI program on behalf of the client */ -void serve_dynamic(int fd, char *filename, char *cgiargs) +void serve_dynamic(int fd, char *filename, char *cgiargs, char *method)  { char buf[MAXLINE], *emptylist[] = { NULL }; @@ -193,6 +196,7 @@  if (Fork() == 0) { /* Child */ //line:netp:servedynamic:fork /* Real server would set all CGI vars here */ setenv(\u0026#34;QUERY_STRING\u0026#34;, cgiargs, 1); //line:netp:servedynamic:setenv + setenv(\u0026#34;REQUEST_METHOD\u0026#34;, method, 1);  Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */ //line:netp:servedynamic:dup2 Execve(filename, emptylist, environ); /* Run CGI program */ //line:netp:servedynamic:execve }  adder.c changes\n/* * head-adder.c - a minimal CGI program that adds two numbers together */ #include \u0026#34;../csapp.h\u0026#34; int main(void) { char *buf, *p, *method; char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE]; int n1=0, n2=0; /* Extract the two arguments */ if ((buf = getenv(\u0026#34;QUERY_STRING\u0026#34;)) != NULL) { p = strchr(buf, \u0026#39;\u0026amp;\u0026#39;); *p = \u0026#39;\\0\u0026#39;; strcpy(arg1, buf); strcpy(arg2, p+1); n1 = atoi(arg1); n2 = atoi(arg2); } method = getenv(\u0026#34;REQUEST_METHOD\u0026#34;); /* Make the response body */ sprintf(content, \u0026#34;Welcome to add.com: \u0026#34;); sprintf(content, \u0026#34;%sTHE Internet addition portal.\\r\\n\u0026lt;p\u0026gt;\u0026#34;, content); sprintf(content, \u0026#34;%sThe answer is: %d + %d = %d\\r\\n\u0026lt;p\u0026gt;\u0026#34;, content, n1, n2, n1 + n2); sprintf(content, \u0026#34;%sThanks for visiting!\\r\\n\u0026#34;, content); /* Generate the HTTP response */ printf(\u0026#34;Connection: close\\r\\n\u0026#34;); printf(\u0026#34;Content-length: %d\\r\\n\u0026#34;, (int)strlen(content)); printf(\u0026#34;Content-type: text/html\\r\\n\\r\\n\u0026#34;); if (strcasecmp(method, \u0026#34;HEAD\u0026#34;) != 0) printf(\u0026#34;%s\u0026#34;, content); fflush(stdout); exit(0); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.12/","title":"11.12","tags":[],"description":"","content":"run server\n(cd ./site/content/chapter11/code; make \u0026amp;\u0026amp; ./tiny.12 5000)  visit http://localhost:5000/post-home.html and submit\nPOST method pass param by message-body behind Headers part. When we input 9 and 10 and submit, socket pass content\nPOST /cgi-bin/post-adder HTTP/1.1 Host: localhost:5000 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 16 Referer: http://localhost:5000/post-home.html Cookie: _ga=GA1.1.1286836072.1494744693 Connection: keep-alive Upgrade-Insecure-Requests: 1 (CRLF here, message-body below) first=9\u0026amp;second=10  Content-Length marks the length of message-body. use readnb to fetch post param.\n--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.12.c\t2021-02-25 07:26:33.302592754 +0000 @@ -5,7 +5,7 @@  #include \u0026#34;csapp.h\u0026#34; void doit(int fd); -void read_requesthdrs(rio_t *rp); +int read_requesthdrs(rio_t *rp, char *method);  int parse_uri(char *uri, char *filename, char *cgiargs); void serve_static(int fd, char *filename, int filesize); void get_filetype(char *filename, char *filetype); @@ -55,12 +55,14 @@  return; printf(\u0026#34;%s\u0026#34;, buf); sscanf(buf, \u0026#34;%s %s %s\u0026#34;, method, uri, version); //line:netp:doit:parserequest - if (strcasecmp(method, \u0026#34;GET\u0026#34;)) { //line:netp:doit:beginrequesterr + if (!(strcasecmp(method, \u0026#34;GET\u0026#34;) == 0 || strcasecmp(method, \u0026#34;POST\u0026#34;) == 0)) {  clienterror(fd, method, \u0026#34;501\u0026#34;, \u0026#34;Not Implemented\u0026#34;, \u0026#34;Tiny does not implement this method\u0026#34;); return; } //line:netp:doit:endrequesterr - read_requesthdrs(\u0026amp;rio); //line:netp:doit:readrequesthdrs + int param_len = read_requesthdrs(\u0026amp;rio, method); + + Rio_readnb(\u0026amp;rio, buf, param_len);  /* Parse URI from GET request */ is_static = parse_uri(uri, filename, cgiargs); //line:netp:doit:staticcheck @@ -84,24 +86,29 @@  \u0026#34;Tiny couldn\u0026#39;t run the CGI program\u0026#34;); return; } - serve_dynamic(fd, filename, cgiargs); //line:netp:doit:servedynamic + if (strcasecmp(method, \u0026#34;GET\u0026#34;) == 0) + serve_dynamic(fd, filename, cgiargs); + else + serve_dynamic(fd, filename, buf);  } } /* * read_requesthdrs - read HTTP request headers */ -void read_requesthdrs(rio_t *rp) +int read_requesthdrs(rio_t *rp, char *method)  { char buf[MAXLINE]; + int len = 0;  - Rio_readlineb(rp, buf, MAXLINE); - printf(\u0026#34;%s\u0026#34;, buf); - while(strcmp(buf, \u0026#34;\\r\\n\u0026#34;)) { //line:netp:readhdrs:checkterm + do {  Rio_readlineb(rp, buf, MAXLINE); printf(\u0026#34;%s\u0026#34;, buf); - } - return; + if (strcasecmp(method, \u0026#34;POST\u0026#34;) == 0 \u0026amp;\u0026amp; strncasecmp(buf, \u0026#34;Content-Length:\u0026#34;, 15) == 0) + sscanf(buf, \u0026#34;Content-Length: %d\u0026#34;, \u0026amp;len); + } while(strcmp(buf, \u0026#34;\\r\\n\u0026#34;)); + + return len;  } /* * parse_uri - parse URI into filename and CGI args  post-adder code\n/* * post-adder.c - a minimal CGI program that adds two numbers together */ #include \u0026#34;../csapp.h\u0026#34; int main(void) { char *buf, *p; char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE]; int n1=0, n2=0; /* Extract the two arguments */ if ((buf = getenv(\u0026#34;QUERY_STRING\u0026#34;)) != NULL) { p = strchr(buf, \u0026#39;\u0026amp;\u0026#39;); *p = \u0026#39;\\0\u0026#39;; sscanf(buf, \u0026#34;first=%d\u0026#34;, \u0026amp;n1); sscanf(p+1, \u0026#34;second=%d\u0026#34;, \u0026amp;n2); } /* Make the response body */ sprintf(content, \u0026#34;Welcome to add.com: \u0026#34;); sprintf(content, \u0026#34;%sTHE Internet addition portal.\\r\\n\u0026lt;p\u0026gt;\u0026#34;, content); sprintf(content, \u0026#34;%sThe answer is: %d + %d = %d\\r\\n\u0026lt;p\u0026gt;\u0026#34;, content, n1, n2, n1 + n2); sprintf(content, \u0026#34;%sThanks for visiting!\\r\\n\u0026#34;, content); /* Generate the HTTP response */ printf(\u0026#34;Connection: close\\r\\n\u0026#34;); printf(\u0026#34;Content-length: %d\\r\\n\u0026#34;, (int)strlen(content)); printf(\u0026#34;Content-type: text/html\\r\\n\\r\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, content); fflush(stdout); exit(0); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.13/","title":"11.13","tags":[],"description":"","content":"--- tiny.origin.c\t2021-02-25 07:26:33.302592754 +0000 +++ tiny.13.c\t2021-02-25 07:26:33.302592754 +0000 @@ -13,6 +13,17 @@  void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +// improved rio written +void Im_rio_writen(int fd, void *usrbuf, size_t n) { + if (rio_writen(fd, usrbuf, n) != n) { + if (errno == EPIPE) + fprintf(stderr, \u0026#34;EPIPE error\u0026#34;); + + fprintf(stderr, \u0026#34;%s \u0026#34;, strerror(errno)); + unix_error(\u0026#34;client side has ended connection\u0026#34;); + } +} +  int main(int argc, char **argv) { int listenfd, connfd; @@ -26,6 +37,9 @@  exit(1); } + if (Signal(SIGPIPE, SIG_IGN) == SIG_ERR) + unix_error(\u0026#34;mask signal pipe error\u0026#34;); +  listenfd = Open_listenfd(argv[1]); while (1) { clientlen = sizeof(clientaddr); @@ -148,7 +162,7 @@  sprintf(buf, \u0026#34;%sConnection: close\\r\\n\u0026#34;, buf); sprintf(buf, \u0026#34;%sContent-length: %d\\r\\n\u0026#34;, buf, filesize); sprintf(buf, \u0026#34;%sContent-type: %s\\r\\n\\r\\n\u0026#34;, buf, filetype); - Rio_writen(fd, buf, strlen(buf)); //line:netp:servestatic:endserve + Im_rio_writen(fd, buf, strlen(buf)); //line:netp:servestatic:endserve  printf(\u0026#34;Response headers:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, buf); @@ -156,7 +170,7 @@  srcfd = Open(filename, O_RDONLY, 0); //line:netp:servestatic:open srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);//line:netp:servestatic:mmap Close(srcfd); //line:netp:servestatic:close - Rio_writen(fd, srcp, filesize); //line:netp:servestatic:write + Im_rio_writen(fd, srcp, filesize); //line:netp:servestatic:write  Munmap(srcp, filesize); //line:netp:servestatic:munmap } @@ -186,11 +200,13 @@  /* Return first part of HTTP response */ sprintf(buf, \u0026#34;HTTP/1.0 200 OK\\r\\n\u0026#34;); - Rio_writen(fd, buf, strlen(buf)); + Im_rio_writen(fd, buf, strlen(buf));  sprintf(buf, \u0026#34;Server: Tiny Web Server\\r\\n\u0026#34;); - Rio_writen(fd, buf, strlen(buf)); + Im_rio_writen(fd, buf, strlen(buf));  if (Fork() == 0) { /* Child */ //line:netp:servedynamic:fork + if (Signal(SIGPIPE, SIG_DFL) == SIG_ERR) + unix_error(\u0026#34;unmask signal pipe error\u0026#34;);  /* Real server would set all CGI vars here */ setenv(\u0026#34;QUERY_STRING\u0026#34;, cgiargs, 1); //line:netp:servedynamic:setenv Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */ //line:netp:servedynamic:dup2 @@ -216,10 +232,10 @@  /* Print the HTTP response */ sprintf(buf, \u0026#34;HTTP/1.0 %s %s\\r\\n\u0026#34;, errnum, shortmsg); - Rio_writen(fd, buf, strlen(buf)); + Im_rio_writen(fd, buf, strlen(buf));  sprintf(buf, \u0026#34;Content-type: text/html\\r\\n\u0026#34;); - Rio_writen(fd, buf, strlen(buf)); + Im_rio_writen(fd, buf, strlen(buf));  sprintf(buf, \u0026#34;Content-length: %d\\r\\n\\r\\n\u0026#34;, (int)strlen(body)); - Rio_writen(fd, buf, strlen(buf)); - Rio_writen(fd, body, strlen(body)); + Im_rio_writen(fd, buf, strlen(buf)); + Im_rio_writen(fd, body, strlen(body));  }  ignore SIGPIPE and show more friendly errer message.\nunmask SIGPIPE, leave child process to handle it.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.16/","title":"12.16","tags":[],"description":"","content":"/* * 12.16.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; void *thread(void *vargp); #define DEFAULT 4  int main(int argc, char* argv[]) { int N; if (argc \u0026gt; 2) unix_error(\u0026#34;too many param\u0026#34;); else if (argc == 2) N = atoi(argv[1]); else N = DEFAULT; int i; pthread_t tid; for (i = 0; i \u0026lt; N; i++) { Pthread_create(\u0026amp;tid, NULL, thread, NULL); } Pthread_exit(NULL); } void *thread(void *vargp) { printf(\u0026#34;Hello, world\\n\u0026#34;); return NULL; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.17/","title":"12.17","tags":[],"description":"","content":"A.\nmain thread didn\u0026rsquo;t wait other thread.\nB.\npthread_exit\n/* * 12.17.c */ #include \u0026#34;csapp.h\u0026#34;void *thread(void *vargp); int main() { pthread_t tid; Pthread_create(\u0026amp;tid, NULL, thread, NULL); // exit(0);  Pthread_exit(NULL); } /* Thread routine */ void *thread(void *vargp) { Sleep(1); printf(\u0026#34;Hello, world!\\n\u0026#34;); return NULL; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.18/","title":"12.18","tags":[],"description":"","content":"A unsafe\nB safe\nC unsafe\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.19/","title":"12.19","tags":[],"description":"","content":"pay attention to static int reader_first\n/* * 12.19.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; #define WRITE_LIMIT 100000 #define PEOPLE 4  static int readtimes; static int writetimes; static int readcnt; // if a reader is waiting when writing, reader first next round static int reader_first; sem_t mutex, w; void *reader(void *vargp) { while (1) { P(\u0026amp;mutex); readcnt++; if (readcnt == 1) P(\u0026amp;w); V(\u0026amp;mutex); /* Critical section */ readtimes++; reader_first = 0; /* Critical section */ P(\u0026amp;mutex); readcnt--; if (readcnt == 0) V(\u0026amp;w); V(\u0026amp;mutex); } } void *writer(void *vargp) { while (1) { if (reader_first == 1) continue; P(\u0026amp;w); /* Critical section */ writetimes++; if (writetimes == WRITE_LIMIT) { printf(\u0026#34;read/write: %d/%d\\n\u0026#34;, readtimes, writetimes); exit(0); } /* Critical section */ // if a reader is waiting, reader first next round  if (readcnt == 1) reader_first = 1; V(\u0026amp;w); } } void init(void) { readcnt = 0; readtimes = 0; writetimes = 0; reader_first = 0; Sem_init(\u0026amp;w, 0, 1); Sem_init(\u0026amp;mutex, 0, 1); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i \u0026lt; PEOPLE; i++) if (i%2 == 0) Pthread_create(\u0026amp;tid, NULL, reader, NULL); else Pthread_create(\u0026amp;tid, NULL, writer, NULL); Pthread_exit(NULL); exit(0); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.20/","title":"12.20","tags":[],"description":"","content":"readercnt limits the readers number at the same time.\n/* * 12.20.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; #define WRITE_LIMIT 100000 #define PEOPLE 20 // 10 reader and 10 writer #define N 5  static int readtimes; static int writetimes; sem_t mutex; sem_t readercnt; void *reader(void *vargp) { while (1) { P(\u0026amp;readercnt); P(\u0026amp;mutex); readtimes++; V(\u0026amp;mutex); V(\u0026amp;readercnt); } } void *writer(void *vargp) { while (1) { P(\u0026amp;mutex); writetimes++; if (writetimes == WRITE_LIMIT) { printf(\u0026#34;read/write: %d/%d\\n\u0026#34;, readtimes, writetimes); exit(0); } V(\u0026amp;mutex); } } void init(void) { readtimes = 0; writetimes = 0; Sem_init(\u0026amp;mutex, 0, 1); Sem_init(\u0026amp;readercnt, 0, N); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i \u0026lt; PEOPLE; i++) { if (i%2 == 0) Pthread_create(\u0026amp;tid, NULL, reader, NULL); else Pthread_create(\u0026amp;tid, NULL, writer, NULL); } Pthread_exit(NULL); exit(0); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.21/","title":"12.21","tags":[],"description":"","content":"writecnt record how many writers are waiting.\n/* * 12.21.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; #define WRITE_LIMIT 100000 #define PEOPLE 4  static int readtimes; static int writetimes; static int writecnt; sem_t mutex, w; static int number; void *reader(void *vargp) { while (1) { // writer first  if (writecnt \u0026gt; 0) continue; P(\u0026amp;w); /* Critical section */ readtimes++; /* Critical section */ V(\u0026amp;w); } } void *writer(void *vargp) { while (1) { P(\u0026amp;mutex); // one more writer wait to write  writecnt++; V(\u0026amp;mutex); P(\u0026amp;w); /* Critical section */ writetimes++; if (writetimes == WRITE_LIMIT) { printf(\u0026#34;read/write: %d/%d\\n\u0026#34;, readtimes, writetimes); exit(0); } /* Critical section */ V(\u0026amp;w); P(\u0026amp;mutex); // writer has written  writecnt--; V(\u0026amp;mutex); } } void init(void) { writecnt = 0; readtimes = 0; writetimes = 0; Sem_init(\u0026amp;w, 0, 1); Sem_init(\u0026amp;mutex, 0, 1); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i \u0026lt; PEOPLE; i++) { if (i%2 == 0) Pthread_create(\u0026amp;tid, NULL, reader, NULL); else Pthread_create(\u0026amp;tid, NULL, writer, NULL); } Pthread_exit(NULL); exit(0); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.22/","title":"12.22","tags":[],"description":"","content":"#include \u0026#34;csapp.h\u0026#34; /* read line from connfd and echo line to connfd */ int echo_line(int connfd); void command(void); int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; fd_set read_set, ready_set; if (argc != 2) { fprintf(stderr, \u0026#34;usage: %s \u0026lt;port\u0026gt;\\nuse port 5000 here\\n\u0026#34;, argv[0]); // default port 5000  listenfd = Open_listenfd(\u0026#34;5000\u0026#34;); } else { listenfd = Open_listenfd(argv[1]); //line:conc:select:openlistenfd  } FD_ZERO(\u0026amp;read_set); /* Clear read set */ //line:conc:select:clearreadset  FD_SET(STDIN_FILENO, \u0026amp;read_set); /* Add stdin to read set */ //line:conc:select:addstdin  FD_SET(listenfd, \u0026amp;read_set); /* Add listenfd to read set */ //line:conc:select:addlistenfd  // max n for select  int n = listenfd+1; while (1) { ready_set = read_set; Select(n, \u0026amp;ready_set, NULL, NULL, NULL); //line:conc:select:select  if (FD_ISSET(STDIN_FILENO, \u0026amp;ready_set)) //line:conc:select:stdinready  command(); /* Read command line from stdin */ if (FD_ISSET(listenfd, \u0026amp;ready_set)) { //line:conc:select:listenfdready  clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA *)\u0026amp;clientaddr, \u0026amp;clientlen); // listen to accepted io ports  if (connfd+1 \u0026gt; FD_SETSIZE) { fprintf(stderr, \u0026#34;too many clients\\n\u0026#34;); Close(connfd); } n = n \u0026gt; connfd+1 ? n : connfd+1; FD_SET(connfd, \u0026amp;read_set); } // echo one line every time  int fd; for (fd = listenfd+1; fd \u0026lt; n; fd++) if (FD_ISSET(fd, \u0026amp;ready_set)) if (echo_line(fd) == -1) { Close(fd); FD_CLR(fd, \u0026amp;read_set); } } } void command(void) { char buf[MAXLINE]; if (!Fgets(buf, MAXLINE, stdin)) exit(0); /* EOF */ printf(\u0026#34;%s\u0026#34;, buf); /* Process the input command */ } int echo_line(int connfd) { ssize_t n; char buf[1]; while ((n = Rio_readn(connfd, buf, 1)) \u0026gt; 0) { Rio_writen(connfd, buf, n); if (buf[0] = \u0026#39;\\n\u0026#39;) return 0; } return -1; }  run server\n(cd ./site/content/chapter12/code; make \u0026amp;\u0026amp; ./12.22 5000)  input command in terminal or telnet to test server\ntelnet 127.0.0.1 5000  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.23/","title":"12.23","tags":[],"description":"","content":"code in pic 12-8 save as file 12.23.bug.c\nrun server\n(cd ./site/content/chapter12/code; make \u0026amp;\u0026amp; ./12.23.bug)  let\u0026rsquo;s figure out when server will fail, see code 12.23.client.c\n/* * 12.23.client.c - An echo client */ #include \u0026#34;csapp.h\u0026#34; int main(int argc, char **argv) { int clientfd; char *host, *port; char *buf = \u0026#34;something to send\\n\u0026#34;; rio_t rio; host = \u0026#34;127.0.0.1\u0026#34;; port = \u0026#34;5000\u0026#34;; clientfd = Open_clientfd(host, port); Rio_readinitb(\u0026amp;rio, clientfd); Rio_writen(clientfd, buf, strlen(buf)); /*Close(clientfd);*/ exit(0); }  line 20 Close(clientfd) are commented. when server is running, open another terminal and run ./12.23.client, server will exit with error\nRio_readlineb error: Connection reset by peer  server can\u0026rsquo;t read EOF because client doesn\u0026rsquo;t call Close\nhow to fix:\njust output error infomation and doesn\u0026rsquo;t exit\n--- 12.23.bug.c\t2021-02-25 07:26:33.302592754 +0000 +++ 12.23.c\t2021-02-25 07:26:33.302592754 +0000 @@ -1,7 +1,5 @@  /* - * 12.23.bug.c - A concurrent echo server based on select - * - * bug in this file + * 12.23.c - A concurrent echo server based on select  */ #include \u0026#34;csapp.h\u0026#34; @@ -105,15 +103,21 @@  /* If the descriptor is ready, echo a text line from it */ if ((connfd \u0026gt; 0) \u0026amp;\u0026amp; (FD_ISSET(connfd, \u0026amp;p-\u0026gt;ready_set))) { p-\u0026gt;nready--; - if ((n = Rio_readlineb(\u0026amp;rio, buf, MAXLINE)) != 0) { + if ((n = rio_readlineb(\u0026amp;rio, buf, MAXLINE)) \u0026gt; 0) {  byte_cnt += n; //line:conc:echoservers:beginecho printf(\u0026#34;Server received %d (%d total) bytes on fd %d\\n\u0026#34;, n, byte_cnt, connfd); Rio_writen(connfd, buf, n); //line:conc:echoservers:endecho } -  /* EOF detected, remove descriptor from pool */ + else if (n == 0) { + Close(connfd); //line:conc:echoservers:closeconnfd + FD_CLR(connfd, \u0026amp;p-\u0026gt;read_set); //line:conc:echoservers:beginremove + p-\u0026gt;clientfd[i] = -1; //line:conc:echoservers:endremove + } + /* n == -1, it\u0026#39;s an error */  else { + fprintf(stderr, \u0026#34;error in fd %d, close fd %d connection\\n\u0026#34;, connfd, connfd);  Close(connfd); //line:conc:echoservers:closeconnfd FD_CLR(connfd, \u0026amp;p-\u0026gt;read_set); //line:conc:echoservers:beginremove p-\u0026gt;clientfd[i] = -1; //line:conc:echoservers:endremove  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.24/","title":"12.24","tags":[],"description":"","content":"if don\u0026rsquo;t pass pointer param which points to same data block, functions\nrio_readn rio_writen rio_readinitb rio_readlineb rio_readnb  are all implicitly reentrant functions\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.25/","title":"12.25","tags":[],"description":"","content":"/* * A thread-safe version of echo that counts the total number * of bytes received from clients. */ /* $begin echo_cnt */ #include \u0026#34;csapp.h\u0026#34; static int byte_cnt; /* Byte counter */ static sem_t mutex; /* and the mutex that protects it */ static void init_echo_cnt(void) { Sem_init(\u0026amp;mutex, 0, 1); byte_cnt = 0; } void echo_cnt(int connfd) { int n; char buf[MAXLINE]; rio_t rio; static pthread_once_t once = PTHREAD_ONCE_INIT; Pthread_once(\u0026amp;once, init_echo_cnt); //line:conc:pre:pthreadonce  Rio_readinitb(\u0026amp;rio, connfd); //line:conc:pre:rioinitb  while((n = Rio_readlineb(\u0026amp;rio, buf, MAXLINE)) != 0) { P(\u0026amp;mutex); byte_cnt += n; //line:conc:pre:cntaccess1 \tprintf(\u0026#34;server received %d (%d total) bytes on fd %d\\n\u0026#34;, n, byte_cnt, connfd); //line:conc:pre:cntaccess2 \tV(\u0026amp;mutex); Rio_writen(connfd, buf, n); } } /* $end echo_cnt */  thread safe?\nYes, mutex make it safe\nreentrant?\nNo, share the same mutex\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.26/","title":"12.26","tags":[],"description":"","content":"struct hostent *gethostbyname(const char *name) struct hostent { char *h_name; char **h_aliases; int h_addrtype; int h_length; char **h_addr_list; } copy int, copy char*, copy char** in struct hostent are 3 different ways.\n/* * 12.26.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; /* * struct hostent *gethostbyname(const char *name) * * struct hostent { * char *h_name; * char **h_aliases; * int h_addrtype; * int h_length; * char **h_addr_list; * } */ static sem_t mutex; static void init_mutex(void) { Sem_init(\u0026amp;mutex, 0, 1); } struct hostent *gethostbyname_ts(const char *name, struct hostent *host) { struct hostent *sharehost; P(\u0026amp;mutex); sharehost = gethostbyname(name); // copy int  host-\u0026gt;h_addrtype = sharehost-\u0026gt;h_addrtype; host-\u0026gt;h_length = sharehost-\u0026gt;h_length; // copy char *  host-\u0026gt;h_name = (char*)Malloc(strlen(sharehost-\u0026gt;h_name)); strcpy(host-\u0026gt;h_name, sharehost-\u0026gt;h_name); // copy char **  int i; for (i = 0; sharehost-\u0026gt;h_aliases[i] != NULL; i++) {} host-\u0026gt;h_aliases = (char**)Malloc(sizeof(char*) * (i+1)); for (i = 0; sharehost-\u0026gt;h_aliases[i] != NULL; i++) { // copy every char *  host-\u0026gt;h_aliases[i] = (char*)Malloc(strlen(sharehost-\u0026gt;h_aliases[i])); strcpy(host-\u0026gt;h_aliases[i], sharehost-\u0026gt;h_aliases[i]); } host-\u0026gt;h_aliases[i] = NULL; for (i = 0; sharehost-\u0026gt;h_addr_list[i] != NULL; i++) {} host-\u0026gt;h_addr_list = (char**)Malloc(sizeof(char*) * (i+1)); for (i = 0; sharehost-\u0026gt;h_addr_list[i] != NULL; i++) { // copy every char *  host-\u0026gt;h_addr_list[i] = (char*)Malloc(strlen(sharehost-\u0026gt;h_addr_list[i])); strcpy(host-\u0026gt;h_addr_list[i], sharehost-\u0026gt;h_addr_list[i]); } host-\u0026gt;h_addr_list[i] = NULL; V(\u0026amp;mutex); return host; } int main(int argc, char* argv[]) { init_mutex(); struct hostent host; gethostbyname_ts(\u0026#34;127.0.0.1\u0026#34;, \u0026amp;host); // result in \u0026amp;host  return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.27/","title":"12.27","tags":[],"description":"","content":"FILE *fpin, *fpout; fpin = fdopen(sockfd, \u0026#34;r\u0026#34;); fpout = fdopen(sockfd, \u0026#34;w\u0026#34;); // read and write  fclose(fpin); fclose(fpout); ref: 10.11\nfdopen open 2 stream on same sockfd, fdclose will close sockfd under stream. if you call fclose 2 stream on the same sockfd, the second fclose will fail.\nimage one thread execute code and open 2 stream on fd N. after execution of line fclose(fpin);, program create another thread and execute the same code.\nbut\nafter fclose(fpin); in thread 1, fd N is reusable again. assume thread 2 use the fd N again: thread 1 execute line fclose(fpout); close the fd that thread 2 is using. it\u0026rsquo;ll cause something unpredicted.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.28/","title":"12.28","tags":[],"description":"","content":"No effect on deadlock\n1\n   thread 1 thread 2     P(s) P(s)   P(t) P(t)   V(s) V(s)   V(t) V(t)     + | | + +--------------------+ V(t)| | | | | | + | unsafe region t | | | | | | | + +---------+---------+ | V(s)| | | | | | | | | | + | | | | | | | | | | | | | | + | +---------+----------+ P(t)| | | | | unsafe region s | + | | | | | | | | + +-------------------+ P(s)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(s) P(t) V(s) V(t)  2\n   thread 1 thread 2     P(s) P(s)   P(t) P(t)   V(s) V(t)   V(t) V(s)     + | | + +-------------------+ V(s)| | | | | | + | | | | | | | | + | +---------+----------+ V(t)| | | | | | | | | unsafe | + | | | region | | | | | t | | | | | | + | +---------+----------+ P(t)| | | | | | + | unsafe region s | | | | | | | + +-------------------+ P(s)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(s) P(t) V(s) V(t)  3\n   thread 1 thread 2     P(s) P(s)   P(t) P(t)   V(t) V(s)   V(s) V(t)     + | | + +---------+ V(t)| | unsafe | | | region | + | t | | | | | | | + +---------+---------+----------+ V(s)| | | | | | | | | | + | | | | | | | | | | | | | | + | +---------+ | P(t)| | | | | | + | unsafe region s | | | | | | | + +------------------------------+ P(s)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(s) P(t) V(t) V(s)  4\n   thread 1 thread 2     P(s) P(s)   P(t) P(t)   V(t) V(t)   V(s) V(s)     + | | + +------------------------------+ V(s)| | | | | | + | | | | | | | | + | +----------+ | V(t)| | | unsafe | | | | | region | | + | | t | | | | | | | | | | | | + | +----------+ | P(t)| | | | | | + | unsafe region s | | | | | | | + +------------------------------+ P(s)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(s) P(t) V(t) V(s)  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.29/","title":"12.29","tags":[],"description":"","content":"no deadlock\ninitial: a = 1, b = 1, c = 1\n   thread 1 thread 2     P(a) P(c)   P(b) P(b)   V(b) V(b)   P(c) V(c)   V(c) \u0026mdash;-   V(a) \u0026mdash;-    thread 2 doesn\u0026rsquo;t manipulate mutex a and initial a is 1, so P(a), V(a) don\u0026rsquo;t affect deadlock status.\n   thread 1 thread 2     P(b) P(c)   V(b) P(b)   P(c) V(b)   V(c) V(c)     + | | + +----------+ V(c)| | | | | | + | | | | | | | | + +----------+ | | V(b)| | | | | | | | | | + | | | | | | | | | | | | | | + +----------+ | | P(b)| | | | | | + | | | | | | | | + +----------+ P(c)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(b) V(b) P(c) V(c)  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.30/","title":"12.30","tags":[],"description":"","content":"initial: a = 1, b = 1, c = 1\n   thread 1 thread 2 thread 3     P(a) P(c) P(c)   P(b) P(b) V(c)   V(b) V(b) P(b)   P(c) V(c) P(a)   V(c) P(a) V(a)   V(a) V(a) V(b)    A.\nthread 1: a\u0026amp;b, a\u0026amp;c\nthread 2: b\u0026amp;c\nthread 3: a\u0026amp;b\nB.\nthread 2 and thread 3\nC.\nkeep same order P(a), P(b), P(c) in every thread\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.31/","title":"12.31","tags":[],"description":"","content":"/* * 12.31.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; sigjmp_buf buf; void sigchild_handler(int sig) { siglongjmp(buf, 1); } char *tfgets(char *s, int size, FILE *stream) { if (Fork() == 0) { Sleep(5); exit(0); } switch (sigsetjmp(buf, 1)) { case 0: Signal(SIGCHLD, sigchild_handler); return fgets(s, size, stream); case 1: return NULL; } } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(\u0026#34;BOOM!\\n\u0026#34;); else printf(\u0026#34;%s\u0026#34;, buf); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.32/","title":"12.32","tags":[],"description":"","content":"key is last param of select\n/* * 12.32.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; char *tfgets(char *s, int size, FILE *stream) { fd_set read_set; FD_ZERO(\u0026amp;read_set); FD_SET(STDIN_FILENO, \u0026amp;read_set); struct timeval timeout; timeout.tv_sec = 5; timeout.tv_usec = 0; Select(1, \u0026amp;read_set, NULL, NULL, \u0026amp;timeout); if (FD_ISSET(STDIN_FILENO, \u0026amp;read_set)) return fgets(s, size, stream); else return NULL; } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(\u0026#34;BOOM!\\n\u0026#34;); else printf(\u0026#34;%s\u0026#34;, buf); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.33/","title":"12.33","tags":[],"description":"","content":"/* * 12.33.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; struct pack { char *s; int size; FILE *stream; }; char *ptr = NULL; int timeout = -1; void *thread_read(void *vargp) { struct pack p = *(struct pack *)vargp; ptr = fgets(p.s, p.size, p.stream); timeout = 0; } void *thread_sleep(void *vargp) { Sleep(5); timeout = 1; } char *tfgets(char *s, int size, FILE *stream) { pthread_t tid_read; pthread_t tid_sleep; struct pack p; p.s = s; p.size = size; p.stream = stream; Pthread_create(\u0026amp;tid_read, NULL, thread_read, (void*)\u0026amp;p); Pthread_create(\u0026amp;tid_sleep, NULL, thread_sleep, NULL); // wait 2 thread race result  while(timeout == -1) {} if (timeout == 1) { Pthread_cancel(tid_read); return NULL; } else { Pthread_cancel(tid_sleep); return ptr; } } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(\u0026#34;BOOM!\\n\u0026#34;); else printf(\u0026#34;%s\u0026#34;, buf); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.34/","title":"12.34","tags":[],"description":"","content":"matrix size and thread number\n/* * 12.34.h */ #define N 640 #define M 640  #define THREAD (1\u0026lt;\u0026lt;4) #define ROWS_PER_THREAD (N / THREAD)   non concurrent version\n/* * 12.34.non.concurrent.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34;#include \u0026#34;12.34.h\u0026#34; int M1[N][M]; int M2[N][M]; int MUL12[N][M]; void non_concurrent_mul(void) { int i, j, k; for (i = 0; i \u0026lt; N; i++) for (j = 0; j \u0026lt; N; j++) { int sum = 0; for (k = 0; k \u0026lt; M; k++) { sum += M1[i][k] * M2[k][j]; } MUL12[i][j] = sum; } } int main(int argc, char* argv[]) { non_concurrent_mul(); return 0; }  concurrent version\n/* * 12.34.concurrent.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34;#include \u0026#34;12.34.h\u0026#34; int M1[N][M]; int M2[N][M]; int MUL12[N][M]; void *thread_mul(void *vargp) { int idx = *(int*)vargp; int start = ROWS_PER_THREAD * idx; int i, j, k; for (i = start; i \u0026lt; start+ROWS_PER_THREAD; i++) for (j = 0; j \u0026lt; N; j++) { int sum = 0; for (k = 0; k \u0026lt; M; k++) { sum += M1[i][k] * M2[k][j]; } MUL12[i][j] = sum; } } void concurrent_mul(void) { pthread_t tid[THREAD]; int param[THREAD]; int i; for (i = 0; i \u0026lt; THREAD; i++) { param[i] = i; Pthread_create(\u0026amp;tid[i], NULL, thread_mul, \u0026amp;param[i]); } for (i = 0; i \u0026lt; THREAD; i++) { Pthread_join(tid[i], NULL); } } int main(int argc, char* argv[]) { concurrent_mul(); return 0; }  measure performance\n(cd ./site/content/chapter12/code; make clean \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make measure)  output\n(time ./12.34.non.concurrent) 0.90user 0.00system 0:00.90elapsed 99%CPU (0avgtext+0avgdata 3704maxresident)k 0inputs+0outputs (0major+756minor)pagefaults 0swaps // single cpu run time 0.9s (time ./12.34.concurrent) 2.20user 0.00system 0:00.64elapsed 341%CPU (0avgtext+0avgdata 3896maxresident)k 0inputs+0outputs (0major+1462minor)pagefaults 0swaps // 4 cpu, total run time 2.2s(every cpu run 0.55s, concurrent!!)  more detialed\n   thread(t) 1 2 4 8 16     core(p) 1 2 4 4 4   time(Tp) 0.86 0.466 0.626 0.627 0.628   speedup(Sp) 1 1.84 1.37 1.37 1.37   efficiency(Ep) 100% 92.2% 34.3% 34.3% 34.3%    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.35/","title":"12.35","tags":[],"description":"","content":"see origin tiny server in section 11.6 on book\nthe key is close(connfd) in both parent and child process to ensure close fd and reuse it or it\u0026rsquo;ll failed: Accept error: too many open files\n--- 12.tiny.c\t2021-02-25 07:26:33.305926066 +0000 +++ 12.35.c\t2021-02-25 07:26:33.302592754 +0000 @@ -1,6 +1,8 @@  /* - * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the + * 12.35.c - A simple, iterative HTTP/1.0 Web server that uses the  * GET method to serve static and dynamic content. + * + * concurrent server in multi process way.  */ #include \u0026#34;csapp.h\u0026#34; @@ -35,8 +37,14 @@  Getnameinfo((SA *) \u0026amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(\u0026#34;Accepted connection from (%s, %s)\\n\u0026#34;, hostname, port); - doit(connfd); //line:netp:tiny:doit - Close(connfd); //line:netp:tiny:close + + if (Fork() == 0) { + Close(listenfd); + doit(connfd); //line:netp:tiny:doit + Close(connfd); //line:netp:tiny:close + exit(0); + } + Close(connfd);  } }  run server\n(cd ./site/content/chapter12/code; make \u0026amp;\u0026amp; ./12.35)  open another terminal and benchmark it\nwrk -d4 http://localhost:5000  output\nRunning 4s test @ http://localhost:5000 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 62.20ms 87.89ms 348.01ms 82.24% Req/Sec 397.69 184.95 767.00 58.33% 2585 requests in 4.00s, 578.09KB read Requests/sec: 645.64 Transfer/sec: 144.39KB  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.36/","title":"12.36","tags":[],"description":"","content":"check section 11.6 and 12.2.1, combine code pieces together\ncode directory: chapter12/code/12.36\norigin tiny server: tiny.h tiny.c\nselect echoserver: echoserver.h echoserver.c\nkey points:\n move main loop to main.c file check_clients in echoserver call doit(from tiny server) and close fd  benchmark it\nRunning 4s test @ http://localhost:5000 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 62.72ms 91.68ms 368.55ms 82.94% Req/Sec 615.27 398.96 1.46k 65.91% 3649 requests in 4.00s, 816.04KB read Requests/sec: 911.45 Transfer/sec: 203.83KB  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.37/","title":"12.37","tags":[],"description":"","content":"see origin tiny server in section 11.6 on book\nthe key is how to pass connfd into thread\n--- 12.tiny.c\t2021-02-25 07:26:33.305926066 +0000 +++ 12.37.c\t2021-02-25 07:26:33.302592754 +0000 @@ -13,9 +13,13 @@  void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void *thread(void *vargp); +  int main(int argc, char **argv) { int listenfd, connfd; + int *connfdp; + pthread_t tid;  char hostname[MAXLINE], port[MAXLINE]; socklen_t clientlen; struct sockaddr_storage clientaddr; @@ -35,11 +39,23 @@  Getnameinfo((SA *) \u0026amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(\u0026#34;Accepted connection from (%s, %s)\\n\u0026#34;, hostname, port); - doit(connfd); //line:netp:tiny:doit - Close(connfd); //line:netp:tiny:close + + connfdp = (int*)Malloc(sizeof(int)); + *connfdp = connfd; + Pthread_create(\u0026amp;tid, NULL, thread, connfdp);  } } +void *thread(void *vargp) { + int connfd = *(int*)vargp; + Pthread_detach(Pthread_self()); + Free(vargp); + + doit(connfd); + Close(connfd); + return NULL; +} +  /* * doit - handle one HTTP request/response transaction */  run server\n(cd ./site/content/chapter12/code; make \u0026amp;\u0026amp; ./12.37)  open another terminal and benchmark it\nwrk -d4 http://localhost:5000  output\nRunning 4s test @ http://localhost:5000 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 60.24ms 87.59ms 354.24ms 82.32% Req/Sec 481.88 276.48 1.09k 66.67% 3151 requests in 4.10s, 704.67KB read Requests/sec: 768.63 Transfer/sec: 171.89KB  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.38/","title":"12.38","tags":[],"description":"","content":"code in directory chapter12/code/12.38\nfiles:\n sbuf.h, sbuf.c: prethreading package from section 12.5.4 in book. differences are that add new functions sbuf_full, sbuf_empty. tiny.h, tiny.c: origin tiny server from section 11.6 in book. differences are we seperate function declarations into a .h file main.c: listen new connections, create threads and adjust threads number dynamicly  see new functions in sbuf, sbuf_full and sbuf_empty\n/* Empty buf? */ int sbuf_empty(sbuf_t *sp) { int e; P(\u0026amp;sp-\u0026gt;mutex); /* Lock the buffer */ e = sp-\u0026gt;front == sp-\u0026gt;rear; V(\u0026amp;sp-\u0026gt;mutex); /* Lock the buffer */ return e; } /* Full buf? */ int sbuf_full(sbuf_t *sp) { int f; P(\u0026amp;sp-\u0026gt;mutex); /* Lock the buffer */ f = (sp-\u0026gt;rear - sp-\u0026gt;front) == sp-\u0026gt;n; V(\u0026amp;sp-\u0026gt;mutex); /* Lock the buffer */ return f; } main.c\n/* * main.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;../csapp.h\u0026#34;#include \u0026#34;tiny.h\u0026#34;#include \u0026#34;sbuf.h\u0026#34; #define SBUFSIZE 4 #define INIT_THREAD_N 1 #define THREAD_LIMIT 4096  static int nthreads; static sbuf_t sbuf; /* Shared buffer of connected descriptors */ // thread info typedef struct { pthread_t tid; sem_t mutex; } ithread; static ithread threads[THREAD_LIMIT]; // init work void init(void); // function for create server thread void *serve_thread(void *vargp); /* * creating thread that adjust total thread count according to sbuf situation * * if sbuf is empty, double threads * if sbuf is full, half threads */ void *adjust_threads(void *); // from start to end, create (end - start) new server threads void create_threads(int start, int end); int main(int argc, char **argv) { int i, listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; pthread_t tid; if (argc != 2) { fprintf(stderr, \u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, argv[0]); fprintf(stderr, \u0026#34;use default port 5000\\n\u0026#34;); listenfd = Open_listenfd(\u0026#34;5000\u0026#34;); } else { listenfd = Open_listenfd(argv[1]); } init(); Pthread_create(\u0026amp;tid, NULL, adjust_threads, NULL); while (1) { clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA *) \u0026amp;clientaddr, \u0026amp;clientlen); sbuf_insert(\u0026amp;sbuf, connfd); /* Insert connfd in buffer */ } } void init(void) { nthreads = INIT_THREAD_N; sbuf_init(\u0026amp;sbuf, SBUFSIZE); // create initail server threads  create_threads(0, nthreads); } void *serve_thread(void *vargp) { int idx = *(int*)vargp; Free(vargp); while (1) { // get lock first  // thread can\u0026#39;t be kill now  P(\u0026amp;(threads[idx].mutex)); int connfd = sbuf_remove(\u0026amp;sbuf); doit(connfd); Close(connfd); // service ends and release lock  // so thread can be kill at this time  V(\u0026amp;(threads[idx].mutex)); } } void create_threads(int start, int end) { int i; for (i = start; i \u0026lt; end; i++) { // init mutex for every new thread  Sem_init(\u0026amp;(threads[i].mutex), 0, 1); // create thread  int *arg = (int*)Malloc(sizeof(int)); *arg = i; // pass thread index in array into thread inside  Pthread_create(\u0026amp;(threads[i].tid), NULL, serve_thread, arg); } } void *adjust_threads(void *vargp) { sbuf_t *sp = \u0026amp;sbuf; while (1) { // if sbuf is full, double threads  if (sbuf_full(sp)) { if (nthreads == THREAD_LIMIT) { fprintf(stderr, \u0026#34;too many threads, can\u0026#39;t double\\n\u0026#34;); continue; } // double n  int dn = 2 * nthreads; create_threads(nthreads, dn); nthreads = dn; continue; } // half threads  if (sbuf_empty(sp)) { if (nthreads == 1) continue; // half n  int hn = nthreads / 2; /* * all server thread are divide to 2 parts * * keep [0, hn] running * kill [hn, nthreads] threads * * if you want to kill a thread, you must get the lock before it so you * won\u0026#39;t kill a thread which is offering service. */ int i; for (i = hn; i \u0026lt; nthreads; i++) { P(\u0026amp;(threads[i].mutex)); Pthread_cancel(threads[i].tid); V(\u0026amp;(threads[i].mutex)); } nthreads = hn; continue; } } }  run server\n(cd ./site/content/chapter12/code/12.38; make \u0026amp;\u0026amp; ./main)  open another terminal and benchmark it\nwrk -d4 http://localhost:5000  output\nRunning 4s test @ http://localhost:5000 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 130.44us 183.40us 9.03ms 98.06% Req/Sec 11.08k 5.09k 17.78k 53.66% 90380 requests in 4.10s, 19.74MB read Requests/sec: 22039.72 Transfer/sec: 4.81MB  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.39/","title":"12.39","tags":[],"description":"","content":" +------+ +------+ +------+ | |-----\u0026gt;| |------\u0026gt;| | |client| |proxy | |server| | |\u0026lt;-----| |\u0026lt;------| | +------+ +------+ +------+ as server as client  proxy play with client as a server, with server as a client, interesting.\nthe key point is when normal situation\n +------+ +------+ | |-----\u0026gt;| | |client| |server| | |\u0026lt;-----| | +------+ +------+  HTTP request from client is something like\nGET / HTTP/1.1 Host: address:port  but with proxy, it\u0026rsquo;ll be\nGET http://address:port/ HTTP/1.1 Host: address:port  so proxy have to separate host from uri\nA.\n/* * proxy.c * * visited url log to file log.list * block url base on entry from file block.list */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;../csapp.h\u0026#34; // block.list limit entry num #define MAXENTRY 100  int separate_uri(char *uri, char *host, char *port, char *path); void parse_block_file(char *filename, char list[MAXENTRY][MAXLINE], int limit); int blocked_uri(char *uri, char list[MAXENTRY][MAXLINE]); int main(int argc, char **argv) { int i, listenfd, connfd; int clientfd; socklen_t clientlen; struct sockaddr_storage clientaddr; rio_t client_rio, server_rio; char c_buf[MAXLINE], s_buf[MAXLINE]; ssize_t sn, cn; char method[MAXLINE], uri[MAXLINE], version[MAXLINE]; char host[MAXLINE], port[MAXLINE], path[MAXLINE]; char block_list[MAXENTRY][MAXLINE]; int logfd; char log_buf[MAXLINE]; if (argc != 2) { fprintf(stderr, \u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, argv[0]); fprintf(stderr, \u0026#34;use default port 5000\\n\u0026#34;); listenfd = Open_listenfd(\u0026#34;5000\u0026#34;); } else { listenfd = Open_listenfd(argv[1]); } logfd = Open(\u0026#34;log.list\u0026#34;, O_WRONLY | O_APPEND, 0); memset(block_list, \u0026#39;\\0\u0026#39;, MAXLINE * MAXENTRY); parse_block_file(\u0026#34;block.list\u0026#34;, block_list, MAXENTRY); while (1) { // wait for connection as a server  clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA *) \u0026amp;clientaddr, \u0026amp;clientlen); Rio_readinitb(\u0026amp;server_rio, connfd); /* * if uri is full path url like http://localhost:8000/server.c * remove host part http://localhost:8000 * only pass /server.c to server */ // parse HTTP request first line  if (!Rio_readlineb(\u0026amp;server_rio, s_buf, MAXLINE)) { Close(connfd); continue; } sscanf(s_buf, \u0026#34;%s %s %s\u0026#34;, method, uri, version); // if uri is blocked?  if (blocked_uri(uri, block_list)) { printf(\u0026#34;%s is blocked\\n\u0026#34;, uri); Close(connfd); continue; } // log visit  sprintf(log_buf, \u0026#34;visit url: %s\\n\u0026#34;, uri); Write(logfd, log_buf, strlen(log_buf)); memset(host, \u0026#39;\\0\u0026#39;, MAXLINE); memset(port, \u0026#39;\\0\u0026#39;, MAXLINE); memset(path, \u0026#39;\\0\u0026#39;, MAXLINE); int res; if ((res = separate_uri(uri, host, port, path)) == -1) { fprintf(stderr, \u0026#34;not http protocol\\n\u0026#34;); Close(connfd); continue; } else if (res == 0) { fprintf(stderr, \u0026#34;not a abslute request path\\n\u0026#34;); Close(connfd); continue; } // connect server as a client  clientfd = Open_clientfd(host, port); Rio_readinitb(\u0026amp;client_rio, clientfd); /* * browser --\u0026gt; proxy --\u0026gt; server * * send requests */ // write first request line  sprintf(s_buf, \u0026#34;%s %s %s\\n\u0026#34;, method, path, version); Rio_writen(clientfd, s_buf, strlen(s_buf)); printf(\u0026#34;%s\u0026#34;, s_buf); do { // pass next http requests  sn = Rio_readlineb(\u0026amp;server_rio, s_buf, MAXLINE); printf(\u0026#34;%s\u0026#34;, s_buf); Rio_writen(clientfd, s_buf, sn); } while(strcmp(s_buf, \u0026#34;\\r\\n\u0026#34;)); /* * server --\u0026gt; proxy --\u0026gt; browser * * server send response back */ while ((cn = Rio_readlineb(\u0026amp;client_rio, c_buf, MAXLINE)) != 0) Rio_writen(connfd, c_buf, cn); Close(connfd); Close(clientfd); } Close(logfd); } /* * if uri is abslute path url like * http://localhost:8888/something * or * http://localhost/something (port default is 80) * separate into three part and return 1 * * if uri is relative path like /something * do nothing and return 0 * * if uri is abslute path and not http protocal like https/ftp/etc * do nothing, return -1, it\u0026#39;s error */ int separate_uri(char *uri, char *host, char *port, char *path) { // relative path  if (uri[0] == \u0026#39;/\u0026#39;) return 0; // abslute path  char *prefix = \u0026#34;http://\u0026#34;; int prelen = strlen(prefix); // if not http protocal, error  if (strncmp(uri, prefix, prelen) != 0) return -1; char *start, *end; start = uri + prelen; end = start; // copy host  while (*end != \u0026#39;:\u0026#39; \u0026amp;\u0026amp; *end != \u0026#39;/\u0026#39;) { end++; } strncpy(host, start, end-start); // port is provided  if (*end == \u0026#39;:\u0026#39;) { // skip \u0026#39;:\u0026#39;  ++end; start = end; // copy port  while (*end != \u0026#39;/\u0026#39;) end++; strncpy(port, start, end-start); } else { // port is not provided, defualt 80  strncpy(port, \u0026#34;80\u0026#34;, 2); } // copy path  strcpy(path, end); } /* * read block file, parse all the entries and save into list * entries count no more than limit */ void parse_block_file(char *filename, char list[MAXENTRY][MAXLINE], int limit) { int blockfd; char block_buf[MAXLINE]; rio_t block_rio; ssize_t block_n; blockfd = Open(filename, O_RDONLY, 0); Rio_readinitb(\u0026amp;block_rio, blockfd); memset(block_buf, \u0026#39;\\0\u0026#39;, MAXLINE); int num = 0; while ((block_n = Rio_readlineb(\u0026amp;block_rio, block_buf, MAXLINE)) != 0) { // exceed limit  if (num == limit) break; // right entry  if (strncmp(block_buf, \u0026#34;http://\u0026#34;, 7) == 0) { strcpy(list[num], block_buf); num++; } // comment or not right format entry  // do nothing  } Close(blockfd); } /* * if uri is in list, return true * if not, return false */ int blocked_uri(char *uri, char list[MAXENTRY][MAXLINE]) { int i; for (i = 0; list[i][0] != \u0026#39;\\0\u0026#39;; i++) if (strncmp(uri, list[i], strlen(uri)) == 0) return 1; return 0; }  B.\nmove process into thread function\n/* * proxy-thread.c multi thread deal with concurrent * * visited url log to file log.list * block url base on entry from file block.list */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;../csapp.h\u0026#34; // block.list limit entry num #define MAXENTRY 100  int separate_uri(char *uri, char *host, char *port, char *path); void parse_block_file(char *filename, char list[MAXENTRY][MAXLINE], int limit); int blocked_uri(char *uri, char list[MAXENTRY][MAXLINE]); void *proxy_thread(void *vargp); // url black list static char block_list[MAXENTRY][MAXLINE]; // log file fd static int logfd; int main(int argc, char **argv) { int listenfd; socklen_t clientlen; struct sockaddr_storage clientaddr; int *connfdp; pthread_t tid; if (argc != 2) { fprintf(stderr, \u0026#34;usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, argv[0]); fprintf(stderr, \u0026#34;use default port 5000\\n\u0026#34;); listenfd = Open_listenfd(\u0026#34;5000\u0026#34;); } else { listenfd = Open_listenfd(argv[1]); } logfd = Open(\u0026#34;log.list\u0026#34;, O_WRONLY | O_APPEND, 0); memset(block_list, \u0026#39;\\0\u0026#39;, MAXLINE * MAXENTRY); parse_block_file(\u0026#34;block.list\u0026#34;, block_list, MAXENTRY); while (1) { // wait for connection as a server  clientlen = sizeof(struct sockaddr_storage); connfdp = Malloc(sizeof(int)); *connfdp = Accept(listenfd, (SA *) \u0026amp;clientaddr, \u0026amp;clientlen); // new thread  Pthread_create(\u0026amp;tid, NULL, proxy_thread, connfdp); } Close(logfd); } void *proxy_thread(void *vargp) { pthread_t tid = Pthread_self(); Pthread_detach(tid); int connfd = *(int*)vargp; Free(vargp); rio_t client_rio, server_rio; char c_buf[MAXLINE], s_buf[MAXLINE]; ssize_t sn, cn; char method[MAXLINE], uri[MAXLINE], version[MAXLINE]; char host[MAXLINE], port[MAXLINE], path[MAXLINE]; char log_buf[MAXLINE]; int clientfd; Rio_readinitb(\u0026amp;server_rio, connfd); /* * if uri is full path url like http://localhost:8000/server.c * remove host part http://localhost:8000 * only pass /server.c to server */ // parse HTTP request first line  if (!Rio_readlineb(\u0026amp;server_rio, s_buf, MAXLINE)) { Close(connfd); return NULL; } sscanf(s_buf, \u0026#34;%s %s %s\u0026#34;, method, uri, version); // if uri is blocked?  if (blocked_uri(uri, block_list)) { printf(\u0026#34;thread %ld: %s is blocked\\n\u0026#34;, tid, uri); Close(connfd); return NULL; } // log visit  sprintf(log_buf, \u0026#34;thread %ld: visit url: %s\\n\u0026#34;, tid, uri); Write(logfd, log_buf, strlen(log_buf)); memset(host, \u0026#39;\\0\u0026#39;, MAXLINE); memset(port, \u0026#39;\\0\u0026#39;, MAXLINE); memset(path, \u0026#39;\\0\u0026#39;, MAXLINE); int res; if ((res = separate_uri(uri, host, port, path)) == -1) { fprintf(stderr, \u0026#34;tid %ld: not http protocol\\n\u0026#34;, tid); Close(connfd); return NULL; } else if (res == 0) { fprintf(stderr, \u0026#34;tid %ld: not a abslute request path\\n\u0026#34;, tid); Close(connfd); return NULL; } // connect server as a client  clientfd = Open_clientfd(host, port); Rio_readinitb(\u0026amp;client_rio, clientfd); /* * browser --\u0026gt; proxy --\u0026gt; server * * send requests */ // write first request line  sprintf(s_buf, \u0026#34;%s %s %s\\n\u0026#34;, method, path, version); Rio_writen(clientfd, s_buf, strlen(s_buf)); printf(\u0026#34;tid %ld: %s\u0026#34;, tid, s_buf); do { // pass next http requests  sn = Rio_readlineb(\u0026amp;server_rio, s_buf, MAXLINE); printf(\u0026#34;tid %ld: %s\u0026#34;, tid, s_buf); Rio_writen(clientfd, s_buf, sn); } while(strcmp(s_buf, \u0026#34;\\r\\n\u0026#34;)); /* * server --\u0026gt; proxy --\u0026gt; browser * * server send response back */ while ((cn = Rio_readlineb(\u0026amp;client_rio, c_buf, MAXLINE)) != 0) Rio_writen(connfd, c_buf, cn); Close(connfd); Close(clientfd); } /* * if uri is abslute path url like * http://localhost:8888/something * or * http://localhost/something (port default is 80) * separate into three part and return 1 * * if uri is relative path like /something * do nothing and return 0 * * if uri is abslute path and not http protocal like https/ftp/etc * do nothing, return -1, it\u0026#39;s error */ int separate_uri(char *uri, char *host, char *port, char *path) { // relative path  if (uri[0] == \u0026#39;/\u0026#39;) return 0; // abslute path  char *prefix = \u0026#34;http://\u0026#34;; int prelen = strlen(prefix); // if not http protocal, error  if (strncmp(uri, prefix, prelen) != 0) return -1; char *start, *end; start = uri + prelen; end = start; // copy host  while (*end != \u0026#39;:\u0026#39; \u0026amp;\u0026amp; *end != \u0026#39;/\u0026#39;) { end++; } strncpy(host, start, end-start); // port is provided  if (*end == \u0026#39;:\u0026#39;) { // skip \u0026#39;:\u0026#39;  ++end; start = end; // copy port  while (*end != \u0026#39;/\u0026#39;) end++; strncpy(port, start, end-start); } else { // port is not provided, defualt 80  strncpy(port, \u0026#34;80\u0026#34;, 2); } // copy path  strcpy(path, end); } void parse_block_file(char *filename, char list[MAXENTRY][MAXLINE], int limit) { int blockfd; char block_buf[MAXLINE]; rio_t block_rio; ssize_t block_n; blockfd = Open(filename, O_RDONLY, 0); Rio_readinitb(\u0026amp;block_rio, blockfd); memset(block_buf, \u0026#39;\\0\u0026#39;, MAXLINE); int num = 0; while ((block_n = Rio_readlineb(\u0026amp;block_rio, block_buf, MAXLINE)) != 0) { // exceed limit  if (num == limit) break; // right entry  if (strncmp(block_buf, \u0026#34;http://\u0026#34;, 7) == 0) { strcpy(list[num], block_buf); num++; } // comment or not right format entry  // do nothing  } Close(blockfd); } /* * if uri is in list, return true * if not, return false */ int blocked_uri(char *uri, char list[MAXENTRY][MAXLINE]) { int i; for (i = 0; list[i][0] != \u0026#39;\\0\u0026#39;; i++) if (strncmp(uri, list[i], strlen(uri)) == 0) return 1; return 0; }  how to benchmark:\nrun proxy\n(cd ./site/content/chapter12/code/12.39; make \u0026amp;\u0026amp; ./proxy) # or (cd ./site/content/chapter12/code/12.39; make \u0026amp;\u0026amp; ./proxy-thread)  open another terminal, start a local http server\n(python3 -m http.server 8000)  open one another terminal, benchmark\n# -X means proxy, -n means how many requests, -c means concurrent (ab -X localhost:5000 -n 100 -c 10 http://localhost:8000/)  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.55/","title":"2.55","tags":[],"description":"","content":"/* * show-bytes.c */ #include \u0026lt;stdio.h\u0026gt; typedef unsigned char* byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i \u0026lt; len; i++) { printf(\u0026#34; %.2x\u0026#34;, start[i]); } printf(\u0026#34;\\n\u0026#34;); } void show_int(int x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(void*)); } void test_show_bytes(int val) { int ival = val; float fval = (float) ival; int* pval = \u0026amp;ival; show_int(ival); show_float(fval); show_pointer(pval); } int main(int argc, char* argv[]) { int test_num = 328; test_show_bytes(test_num); return 0; }  run\n./show-bytes  output\n 48 01 00 00 00 00 a4 43 a8 1e 71 ee fc 7f 00 00  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.56/","title":"2.56","tags":[],"description":"","content":"change var test_num in show-bytes.c\nint test_num = 1024;  recompile and run\n./show-bytes  output\n00 04 00 00 00 00 80 44 c8 fe 83 2f fc 7f 00 00  You can try more integers :)\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.57/","title":"2.57","tags":[],"description":"","content":"/* * show-bytes.c */ #include \u0026lt;stdio.h\u0026gt; typedef unsigned char* byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i \u0026lt; len; i++) { printf(\u0026#34; %.2x\u0026#34;, start[i]); } printf(\u0026#34;\\n\u0026#34;); } void show_int(int x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(void*)); } //============= // 2.57 changes //============= void show_short(short x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(short)); } void show_long(long x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(long)); } void show_double(double x) { show_bytes((byte_pointer) \u0026amp;x, sizeof(double)); } //================== // 2.57 changes end //==================  void test_show_bytes(int val) { int ival = val; float fval = (float) ival; int* pval = \u0026amp;ival; show_int(ival); show_float(fval); show_pointer(pval); //=============  // 2.57 changes  //=============  short sval = (short) ival; long lval = (long) ival; double dval = (double) ival; show_short(sval); show_long(lval); show_double(dval); //==================  // 2.57 changes end  //================== } int main(int argc, char* argv[]) { int test_num = 328; test_show_bytes(test_num); return 0; }  run\n./show-bytes-more  output\n48 01 00 00 00 00 a4 43 18 b7 2e 20 fd 7f 00 00 48 01 48 01 00 00 00 00 00 00 00 00 00 00 00 80 74 40  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.58/","title":"2.58","tags":[],"description":"","content":"/* * is-little-endian.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; typedef unsigned char* byte_pointer; int is_little_endian() { int test_num = 0xff; byte_pointer byte_start = (byte_pointer) \u0026amp;test_num; if (byte_start[0] == 0xff) { return 1; } return 0; } int main(int argc, char* argv[]) { assert(is_little_endian()); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.59/","title":"2.59","tags":[],"description":"","content":"expression\n(x \u0026amp; 0xFF) | (y \u0026amp; ~0xFF)  try it\n/* * generate-a-word.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; int main(int argc, char* argv[]) { size_t mask = 0xff; size_t x = 0x89ABCDEF; size_t y = 0x76543210; size_t res = (x \u0026amp; mask) | (y \u0026amp; ~mask); assert(res == 0x765432EF); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.60/","title":"2.60","tags":[],"description":"","content":"/* * replace-byte.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; unsigned replace_byte(unsigned x, int i, unsigned char b) { if (i \u0026lt; 0) { printf(\u0026#34;error: i is negetive\\n\u0026#34;); return x; } if (i \u0026gt; sizeof(unsigned)-1) { printf(\u0026#34;error: too big i\u0026#34;); return x; } // 1 byte has 8 bits, \u0026lt;\u0026lt; 3 means * 8  unsigned mask = ((unsigned) 0xFF) \u0026lt;\u0026lt; (i \u0026lt;\u0026lt; 3); unsigned pos_byte = ((unsigned) b) \u0026lt;\u0026lt; (i \u0026lt;\u0026lt; 3); return (x \u0026amp; ~mask) | pos_byte; } int main(int argc, char *argv[]) { unsigned rep_0 = replace_byte(0x12345678, 0, 0xAB); unsigned rep_3 = replace_byte(0x12345678, 3, 0xAB); assert(rep_0 == 0x123456AB); assert(rep_3 == 0xAB345678); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.61/","title":"2.61","tags":[],"description":"","content":"A\n!~x  B\n!x  C\n!~(x | ~0xff)  D\n!((x \u0026gt;\u0026gt; ((sizeof(int)-1) \u0026lt;\u0026lt; 3)) \u0026amp; 0xff)  test it\n/* * 2.61.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; int A(int x) { return !~x; } int B(int x) { return !x; } int C(int x) { return A(x | ~0xff); } int D(int x) { return B((x \u0026gt;\u0026gt; ((sizeof(int)-1) \u0026lt;\u0026lt; 3)) \u0026amp; 0xff); } int main(int argc, char* argv[]) { int all_bit_one = ~0; int all_bit_zero = 0; assert(A(all_bit_one)); assert(!B(all_bit_one)); assert(C(all_bit_one)); assert(!D(all_bit_one)); assert(!A(all_bit_zero)); assert(B(all_bit_zero)); assert(!C(all_bit_zero)); assert(D(all_bit_zero)); // test magic number 0x1234ff  assert(!A(0x1234ff)); assert(!B(0x1234ff)); assert(C(0x1234ff)); assert(D(0x1234ff)); // test magic number 0x1234  assert(!A(0x1234)); assert(!B(0x1234)); assert(!C(0x1234)); assert(D(0x1234)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.62/","title":"2.62","tags":[],"description":"","content":"/* * int-shifts-are-arithemetic.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; int int_shifts_are_arithemetic() { int num = -1; return !(num ^ (num \u0026gt;\u0026gt; 1)); } int main(int argc, char* argv[]) { assert(int_shifts_are_arithemetic()); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.63/","title":"2.63","tags":[],"description":"","content":"/* * srl-sra.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; unsigned srl(unsigned x, int k) { unsigned xsra = (int) x \u0026gt;\u0026gt; k; int w = sizeof(int) \u0026lt;\u0026lt; 3; int mask = (int) -1 \u0026lt;\u0026lt; (w - k); return xsra \u0026amp; ~mask; } int sra(int x, int k) { int xsrl = (unsigned) x \u0026gt;\u0026gt; k; int w = sizeof(int) \u0026lt;\u0026lt; 3; int mask = (int) -1 \u0026lt;\u0026lt; (w - k); //let mask remain unchanged when the first bit of x is 1, otherwise 0.  int m = 1 \u0026lt;\u0026lt; (w - 1); mask \u0026amp;= ! (x \u0026amp; m) - 1; return xsrl | mask; } int main(int argc, char* argv[]) { unsigned test_unsigned = 0x12345678; int test_int = 0x12345678; assert(srl(test_unsigned, 4) == test_unsigned \u0026gt;\u0026gt; 4); assert(sra(test_int, 4) == test_int \u0026gt;\u0026gt; 4); test_unsigned = 0x87654321; test_int = 0x87654321; assert (srl (test_unsigned, 4) == test_unsigned \u0026gt;\u0026gt; 4); assert (sra (test_int, 4) == test_int \u0026gt;\u0026gt; 4); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.64/","title":"2.64","tags":[],"description":"","content":"/* * any-odd-one.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; int any_odd_one(unsigned x) { return !!(0xAAAAAAAA \u0026amp; x); } int main(int argc, char* argv[]) { assert(any_odd_one(0x2)); assert(!any_odd_one(0x4)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.65/","title":"2.65","tags":[],"description":"","content":"Thanks this answer from stackoverflow\n/* * odd-ones.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; int odd_ones(unsigned x) { x ^= x \u0026gt;\u0026gt; 16; x ^= x \u0026gt;\u0026gt; 8; x ^= x \u0026gt;\u0026gt; 4; x ^= x \u0026gt;\u0026gt; 2; x ^= x \u0026gt;\u0026gt; 1; x \u0026amp;= 0x1; return x; } int main(int argc, char* argv[]) { assert(odd_ones(0x10101011)); assert(!odd_ones(0x01010101)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.66/","title":"2.66","tags":[],"description":"","content":"/* * leftmost-one.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* * Generate mask indicating leftmost 1 in x. Assume w=32 * For example, 0xFF00 -\u0026gt; 0x8000, and 0x6000 -\u0026gt; 0x4000. * If x = 0, then return 0 */ int leftmost_one(unsigned x) { /* * first, generate a mask that all bits after leftmost one are one * e.g. 0xFF00 -\u0026gt; 0xFFFF, and 0x6000 -\u0026gt; 0x7FFF * If x = 0, get 0 */ x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; /* * then, do (mask \u0026gt;\u0026gt; 1) + (mask \u0026amp;\u0026amp; 1), in which mask \u0026amp;\u0026amp; 1 deals with case x = 0, reserve leftmost bit one * that\u0026#39;s we want */ return (x \u0026gt;\u0026gt; 1) + (x \u0026amp;\u0026amp; 1); } int main(int argc, char* argv[]) { assert(leftmost_one(0xFF00) == 0x8000); assert(leftmost_one(0x6000) == 0x4000); assert(leftmost_one(0x0) == 0x0); assert(leftmost_one(0x80000000) == 0x80000000); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.67/","title":"2.67","tags":[],"description":"","content":"A.\nIn section 6.5.7 Bitwise shift operators of c11 standard, it said\n If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior it undefined.\n B.\ncheck function int_size_is_32\nC.\ncheck function int_size_is_32_for_16bit\n/* * int-size-is-32.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* The following function does not run properly on some machine */ /* int bad_int_size_is_32() { int set_msb = 1 \u0026lt;\u0026lt; 31; int beyond_msb = 1 \u0026lt;\u0026lt; 32; return set_msb \u0026amp;\u0026amp; !beyond_msb; } */ int int_size_is_32() { int set_msb = 1 \u0026lt;\u0026lt; 31; int beyond_msb = set_msb \u0026lt;\u0026lt; 1; return set_msb \u0026amp;\u0026amp; !beyond_msb; } int int_size_is_32_for_16bit() { int set_msb = 1 \u0026lt;\u0026lt; 15 \u0026lt;\u0026lt; 15 \u0026lt;\u0026lt; 1; int beyond_msb = set_msb \u0026lt;\u0026lt; 1; return set_msb \u0026amp;\u0026amp; !beyond_msb; } int main(int argc, char *argv[]) { assert(int_size_is_32()); assert(int_size_is_32_for_16bit()); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.68/","title":"2.68","tags":[],"description":"","content":"/* * lower-one-mask.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* * Mask with least signficant n bits set to 1 * Example: n = 6 -\u0026gt; 0x3F, n = 17 -\u0026gt; 0x1FFFF * Assume 1 \u0026lt;= n \u0026lt;= w */ int lower_one_mask(int n) { int w = sizeof(int) \u0026lt;\u0026lt; 3; return (unsigned) -1 \u0026gt;\u0026gt; (w - n); } int main(int argc, char* argv[]) { assert(lower_one_mask(6) == 0x3F); assert(lower_one_mask(17) == 0x1FFFF); assert(lower_one_mask(32) == 0xFFFFFFFF); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.69/","title":"2.69","tags":[],"description":"","content":"/* * rotate-left.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* * Do rotate left shift. Assume 0 \u0026lt;= n \u0026lt; w * Example when x = 0x12345678 and w = 32: * n = 4 -\u0026gt; 0x23456781, n = 20 -\u0026gt; 0x67812345 */ unsigned rotate_left(unsigned x, int n) { int w = sizeof(unsigned) \u0026lt;\u0026lt; 3; /* pay attention when n == 0 */ return x \u0026lt;\u0026lt; n | x \u0026gt;\u0026gt; (w - n - 1) \u0026gt;\u0026gt; 1; } int main(int argc, char* argv[]) { assert(rotate_left(0x12345678, 4) == 0x23456781); assert(rotate_left(0x12345678, 20) == 0x67812345); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.70/","title":"2.70","tags":[],"description":"","content":"/* * fits-bits.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; int fits_bits(int x, int n) { /* * 1 \u0026lt;= n \u0026lt;= w * * assume w = 8, n = 3 * if x \u0026gt; 0 * 0b00000010 is ok, 0b00001010 is not, and 0b00000110 is not yet (thanks itardc@163.com) * if x \u0026lt; 0 * 0b11111100 is ok, 0b10111100 is not, and 0b11111000 is not yet * * the point is * x \u0026lt;\u0026lt; (w-n) \u0026gt;\u0026gt; (w-n) must be equal to x itself. * */ int w = sizeof(int) \u0026lt;\u0026lt; 3; int offset = w - n; return (x \u0026lt;\u0026lt; offset \u0026gt;\u0026gt; offset) == x; } int main(int argc, char* argv[]) { assert(!fits_bits(0xFF, 8)); assert(!fits_bits(~0xFF, 8)); assert(fits_bits(0b0010, 3)); assert(!fits_bits(0b1010, 3)); assert(!fits_bits(0b0110, 3)); assert(fits_bits(~0b11, 3)); assert(!fits_bits(~0b01000011, 3)); assert(!fits_bits(~0b111, 3)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.71/","title":"2.71","tags":[],"description":"","content":"A.\nThis function can\u0026rsquo;t extract negetive number from packet_t word.\nB.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; typedef unsigned packet_t; int xbyte(packet_t word, int bytenum) { int max_bytenum = 3; return (int) word \u0026lt;\u0026lt; ((max_bytenum - bytenum) \u0026lt;\u0026lt; 3) \u0026gt;\u0026gt; (max_bytenum \u0026lt;\u0026lt; 3); } int main(int argc, char* argv[]) { assert(xbyte(0x00112233, 0) == 0x33); assert(xbyte(0x00112233, 1) == 0x22); assert(xbyte(0x00112233, 2) == 0x11); assert(xbyte(0x00112233, 3) == 0x00); assert(xbyte(0xAABBCCDD, 0) == 0xFFFFFFDD); assert(xbyte(0xAABBCCDD, 1) == 0xFFFFFFCC); assert(xbyte(0xAABBCCDD, 2) == 0xFFFFFFBB); assert(xbyte(0xAABBCCDD, 3) == 0xFFFFFFAA); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.72/","title":"2.72","tags":[],"description":"","content":"A.\nsizeof(val) returns type size_t, it usually is a kind of unsigned type.\nmaxbytes - sizeof(val) returns value of type size_t, and it\u0026rsquo;s always \u0026gt;= 0\nB.\n/* * copy-int.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void copy_int(int val, void* buf, int maxbytes) { /* compare two signed number, avoid someone set maxbytes a negetive value */ if (maxbytes \u0026gt;= (int) sizeof(val)) { memcpy(buf, (void*)\u0026amp;val, sizeof(val)); } } int main(int argc, char* argv[]) { int maxbytes = sizeof(int) * 10; void* buf = malloc(maxbytes); int val; val = 0x12345678; copy_int(val, buf, maxbytes); assert(*(int*)buf == val); val = 0xAABBCCDD; copy_int(val, buf, 0); assert(*(int*)buf != val); free(buf); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.73/","title":"2.73","tags":[],"description":"","content":"I can\u0026rsquo;t figure out a elegant solution :(\nthanks https://zhangjunphy.github.io/csapp/chap2.html :)\n/* * saturating-add.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt; int saturating_add(int x, int y) { int sum = x + y; int sig_mask = INT_MIN; /* * if x \u0026gt; 0, y \u0026gt; 0 but sum \u0026lt; 0, it\u0026#39;s a positive overflow * if x \u0026lt; 0, y \u0026lt; 0 but sum \u0026gt;= 0, it\u0026#39;s a negetive overflow */ int pos_over = !(x \u0026amp; sig_mask) \u0026amp;\u0026amp; !(y \u0026amp; sig_mask) \u0026amp;\u0026amp; (sum \u0026amp; sig_mask); int neg_over = (x \u0026amp; sig_mask) \u0026amp;\u0026amp; (y \u0026amp; sig_mask) \u0026amp;\u0026amp; !(sum \u0026amp; sig_mask); (pos_over \u0026amp;\u0026amp; (sum = INT_MAX) || neg_over \u0026amp;\u0026amp; (sum = INT_MIN)); return sum; } int main(int argc, char* argv[]) { assert(INT_MAX == saturating_add(INT_MAX, 0x1234)); assert(INT_MIN == saturating_add(INT_MIN, -0x1234)); assert(0x11 + 0x22 == saturating_add(0x11, 0x22)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.74/","title":"2.74","tags":[],"description":"","content":"/* * tsub-ok.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt; /* Determine whether arguments can be substracted without overflow */ int tsub_ok(int x, int y) { int res = 1; (y == INT_MIN) \u0026amp;\u0026amp; (res = 0); // if (y == INT_MIN) res = 0;  int sub = x - y; int pos_over = x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt; 0 \u0026amp;\u0026amp; sub \u0026lt; 0; int neg_over = x \u0026lt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; sub \u0026gt; 0; res = res \u0026amp;\u0026amp; !(pos_over || neg_over); return res; } int main(int argc, char* argv[]) { assert(!tsub_ok(0x00, INT_MIN)); assert(tsub_ok(0x00, 0x00)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.75/","title":"2.75","tags":[],"description":"","content":"/* * unsigned-high-prod.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;inttypes.h\u0026gt; int signed_high_prod(int x, int y) { int64_t mul = (int64_t) x * y; return mul \u0026gt;\u0026gt; 32; } unsigned unsigned_high_prod(unsigned x, unsigned y) { /* TODO calculations */ int sig_x = x \u0026gt;\u0026gt; 31; int sig_y = y \u0026gt;\u0026gt; 31; int signed_prod = signed_high_prod(x, y); return signed_prod + x * sig_y + y * sig_x; } /* a theorically correct version to test unsigned_high_prod func */ unsigned another_unsigned_high_prod(unsigned x, unsigned y) { uint64_t mul = (uint64_t) x * y; return mul \u0026gt;\u0026gt; 32; } int main(int argc, char* argv[]) { unsigned x = 0x12345678; unsigned y = 0xFFFFFFFF; assert(another_unsigned_high_prod(x, y) == unsigned_high_prod(x, y)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.76/","title":"2.76","tags":[],"description":"","content":"/* * calloc.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;string.h\u0026gt; /* rename to avoid conflict */ void* another_calloc(size_t nmemb, size_t size) { if (nmemb == 0 || size == 0) { return NULL; } size_t buf_size = nmemb * size; /* a good way to check overflow or not */ if (nmemb == buf_size / size) { void* ptr = malloc(buf_size); if(ptr != NULL) { memset(ptr, 0, buf_size); } return ptr; } return NULL; } int main(int argc, char* argv[]) { void* p; p = another_calloc(0x1234, 1); assert(p != NULL); free(p); p = another_calloc(SIZE_MAX, 2); assert(p == NULL); free(p); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.77/","title":"2.77","tags":[],"description":"","content":"/* * 2.77.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* K = 17 */ int A(int x) { return (x \u0026lt;\u0026lt; 4) + x; } /* K = -7 */ int B(int x) { return x - (x \u0026lt;\u0026lt; 3); } /* K = 60 */ int C(int x) { return (x \u0026lt;\u0026lt; 6) - (x \u0026lt;\u0026lt; 2); } /* K = -112 */ int D(int x) { return (x \u0026lt;\u0026lt; 4) - (x \u0026lt;\u0026lt; 7); } int main(int argc, char* argv[]) { int x = 0x87654321; assert(A(x) == 17 * x); assert(B(x) == -7 * x); assert(C(x) == 60 * x); assert(D(x) == -112 * x); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.78/","title":"2.78","tags":[],"description":"","content":"/* * divide-power2.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt; /* * Divide by power of 2, -\u0026gt; x/2^k * Assume 0 \u0026lt;= k \u0026lt; w-1 */ int divide_power2(int x, int k) { int is_neg = x \u0026amp; INT_MIN; (is_neg \u0026amp;\u0026amp; (x = x + (1 \u0026lt;\u0026lt; k) - 1)); return x \u0026gt;\u0026gt; k; } int main(int argc, char* argv[]) { int x = 0x80000007; assert(divide_power2(x, 1) == x / 2); assert(divide_power2(x, 2) == x / 4); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.79/","title":"2.79","tags":[],"description":"","content":"/* * mul3div4.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt; /* * code from 2.78 * * Divide by power of 2, -\u0026gt; x/2^k * Assume 0 \u0026lt;= k \u0026lt; w-1 */ int divide_power2(int x, int k) { int is_neg = x \u0026amp; INT_MIN; (is_neg \u0026amp;\u0026amp; (x = x + (1 \u0026lt;\u0026lt; k) - 1)); return x \u0026gt;\u0026gt; k; } int mul3div4(int x) { int mul3 = (x \u0026lt;\u0026lt; 1) + x; return divide_power2(mul3, 2); } int main(int argc, char* argv[]) { int x = 0x87654321; assert(mul3div4(x) == x * 3 / 4); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.80/","title":"2.80","tags":[],"description":"","content":"/* * threeforths.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt; /* * calculate 3/4x, no overflow, round to zero * * no overflow means divide 4 first, then multiple 3, diffrent from 2.79 here * * rounding to zero is a little complicated. * every int x, equals f(first 30 bit number) plus l(last 2 bit number) * * f = x \u0026amp; ~0x3 * l = x \u0026amp; 0x3 * x = f + l * threeforths(x) = f/4*3 + l*3/4 * * f doesn\u0026#39;t care about round at all, we just care about rounding from l*3/4 * * lm3 = (l \u0026lt;\u0026lt; 1) + l * * when x \u0026gt; 0, rounding to zero is easy * * lm3d4 = lm3 \u0026gt;\u0026gt; 2 * * when x \u0026lt; 0, rounding to zero acts like divide_power2 in 2.78 * * bias = 0x3 // (1 \u0026lt;\u0026lt; 2) - 1 * lm3d4 = (lm3 + bias) \u0026gt;\u0026gt; 2 */ int threeforths(int x) { int is_neg = x \u0026amp; INT_MIN; int f = x \u0026amp; ~0x3; int l = x \u0026amp; 0x3; int fd4 = f \u0026gt;\u0026gt; 2; int fd4m3 = (fd4 \u0026lt;\u0026lt; 1) + fd4; int lm3 = (l \u0026lt;\u0026lt; 1) + l; int bias = (1 \u0026lt;\u0026lt; 2) - 1; (is_neg \u0026amp;\u0026amp; (lm3 += bias)); int lm3d4 = lm3 \u0026gt;\u0026gt; 2; return fd4m3 + lm3d4; } int main(int argc, char* argv[]) { assert(threeforths(8) == 6); assert(threeforths(9) == 6); assert(threeforths(10) == 7); assert(threeforths(11) == 8); assert(threeforths(12) == 9); assert(threeforths(-8) == -6); assert(threeforths(-9) == -6); assert(threeforths(-10) == -7); assert(threeforths(-11) == -8); assert(threeforths(-12) == -9); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.81/","title":"2.81","tags":[],"description":"","content":"A.\n-1 \u0026lt;\u0026lt; k  B.\n~(-1 \u0026lt;\u0026lt; k) \u0026lt;\u0026lt; j  /* * 2.81.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* Assume 0 \u0026lt;= k \u0026lt; w */ int A(int k) { return -1 \u0026lt;\u0026lt; k; } /* Assume 0 \u0026lt;= j,k \u0026lt; w */ int B(int k, int j) { return ~A(k) \u0026lt;\u0026lt; j; } int main(int argc, char* argv[]) { assert(A(8) == 0xFFFFFF00); assert(B(16, 8) == 0x00FFFF00); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.82/","title":"2.82","tags":[],"description":"","content":"A.\nwrong, when x == INT_MIN\nB.\nright\nC.\nright\nD.\nright\nE.\nright\n/* * 2.82.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt;#include \u0026#34;lib/random.h\u0026#34; /* broken when x is INT_MIN */ int A(int x, int y) { return (x \u0026lt; y) == (-x \u0026gt; -y); } /* * right * * ((x + y) \u0026lt;\u0026lt; 4) + y - x * =\u0026gt; * x \u0026lt;\u0026lt; 4 - x + y \u0026lt;\u0026lt; 4 + y * =\u0026gt; * x*16 - x + y*16 + y * whether overflow or not, =\u0026gt; * x*15 + y*17 */ int B(int x, int y) { return ((x + y) \u0026lt;\u0026lt; 4) + y - x == 17 * y + 15 * x; } /* * right * * ~x + ~y + 1 * =\u0026gt; * ~x + 1 + ~y + 1 - 1 * =\u0026gt; * -x + -y - 1 * =\u0026gt; * -(x + y) - 1 * =\u0026gt; * ~(x + y) + 1 - 1 * =\u0026gt; * ~(x + y) */ int C(int x, int y) { return ~x + ~y + 1 == ~(x + y); } /* * right * * (ux - uy) == -(unsigned) (y - x) * =\u0026gt; * -(ux - uy) == (unsigned) (y - x) * =\u0026gt; * (ux - uy) == (unsigned) (x - y) */ int D(int x, int y) { unsigned ux = (unsigned) x; unsigned uy = (unsigned) y; return (ux - uy) == -(unsigned) (y - x); } /* * right * * x \u0026gt;\u0026gt; 2 \u0026lt;\u0026lt; 2 * =\u0026gt; * x \u0026amp; ~0x3 * =\u0026gt; * x - num(00/01/10/11) * =\u0026gt; * ((x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 2) \u0026lt;= x */ int E(int x, int y) { return ((x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 2) \u0026lt;= x; } int main(int argc, char* argv[]) { init_seed(); int x = random_int(); int y = random_int(); assert(!A(INT_MIN, 0)); assert(B(x, y)); assert(C(x, y)); assert(D(x, y)); assert(E(x, y)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.83/","title":"2.83","tags":[],"description":"","content":"A.\nn = 0.yyyyy... n \u0026lt;\u0026lt; k = y.yyyyy... = Y + n n \u0026lt;\u0026lt; k - n = Y n = Y/(2^k - 1)  B.\n(a).\ny = 101, Y = 5, k = 3\nn = 5/7\n(b).\ny = 0110, Y = 6, k = 4\nn = 2/5\n(c).\ny = 010011, Y = 19, k = 6\nn = 19/63\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.84/","title":"2.84","tags":[],"description":"","content":"Thanks czy1996\n/* * float-le.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; unsigned f2u(float x) { return *(unsigned*)\u0026amp;x; } int float_le(float x, float y) { unsigned ux = f2u(x); unsigned uy = f2u(y); unsigned sx = ux \u0026gt;\u0026gt; 31; unsigned sy = uy \u0026gt;\u0026gt; 31; // ref: https://github.com/DreamAndDead/CSAPP-3e-Solutions/issues/1  return (ux \u0026lt;\u0026lt; 1 == 0 \u0026amp;\u0026amp; uy \u0026lt;\u0026lt; 1 == 0) || /* both zeros */ (sx \u0026amp;\u0026amp; !sy) || /* x \u0026lt; 0, y \u0026gt;= 0 or x \u0026lt;= 0, y \u0026gt; 0 */ (!sx \u0026amp;\u0026amp; !sy \u0026amp;\u0026amp; ux \u0026lt;= uy) || /* x \u0026gt; 0, y \u0026gt;= 0 or x \u0026gt;= 0, y \u0026gt; 0 */ (sx \u0026amp;\u0026amp; sy \u0026amp;\u0026amp; ux \u0026gt;= uy); /* x \u0026lt; 0, y \u0026lt;= 0 or x \u0026lt;= 0, y \u0026lt; 0 */ } int main(int argc, char* argv[]) { assert(float_le(-0, +0)); assert(float_le(+0, -0)); assert(float_le(0, 3)); assert(float_le(-4, -0)); assert(float_le(-4, 4)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.85/","title":"2.85","tags":[],"description":"","content":"bias = 2^(k-1) - 1\nV = 2^E * M\nA.\n7.0 = 0b111.000\u0026hellip;\nM = 0b1.11, f = 0b0.11, E = 2, e = bias + E, V = 7.0\nbits\n0 10....01 110....  B.\nAssume bias \u0026raquo; n\nbigest odd number, M must be 0b1.111111\u0026hellip;., f = 0b0.11111111\u0026hellip;(n bits 1)\nE = n, V = 0b11111111\u0026hellip;(n+1 bits 1) = 2^(n+1) - 1\nbits\n0 bias+n 11111....  C.\nleast standard number\nM must be 0b1.00\u0026hellip;., f = 0b0.000\u0026hellip;., E = 1 - bias\nV = 2^(1-bias)\nreciprocal\nV = 2^(bias-1)\nM = 0b1.0000\u0026hellip;, f = 0b0.000\u0026hellip;., E = bias-1, e = bias + E\nbits\n0 11...101 00000.....  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.86/","title":"2.86","tags":[],"description":"","content":"bias = 2^(15-1) - 1\n   description binary decimal     least positive unstandard 0 0000\u0026hellip;(15) 0 000\u0026hellip;(62)1 2^(1-bias-63)   least positive standard 0 000\u0026hellip;(14)1 1 000\u0026hellip;.(63) 2^(1-bias)   bigest standard 0 111\u0026hellip;(14)0 1 111\u0026hellip;(63) 2^bias * (2-2^-63)    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.87/","title":"2.87","tags":[],"description":"","content":"   Desc Hex M E V D     -0 0x8000 0 -14 -0 -0.0   \u0026gt;2 least 0x4001 1025/1024 1 1025/512 2.00195312   512 0x6000 1 9 512 512.0   bigest denormalized 0x03FF 1023/1024 -14 1023/(2^24) 6.09755516e-5   -∞ 0xFC00 - - -∞ -∞   ox3BB0 0x3BB0 123/64 -1 123/128 0.9609375    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.88/","title":"2.88","tags":[],"description":"","content":"   A bit A value B bit B value     1 01110 001 -9/16 1 0110 0010 -9/16   0 10110 101 13*2^4 0 1110 1010 13*2^4   1 00111 110 -7/2^10 1 0000 0111 -7/2^10   0 00000 101 5/2^11 0 0000 0001 1/2^10   1 11011 000 -2^12 1 1110 1111 -31*2^3   0 11000 100 3*2^8 0 1111 0000 +oo    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/","title":"2.89","tags":[],"description":"","content":"/* * 2.89.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt;#include \u0026#34;lib/random.h\u0026#34; /* * most important thing is that all double number come from ints */ /* right */ int A(int x, double dx) { return (float)x == (float)dx; } /* wrong when y is INT_MIN */ int B(int x, double dx, int y, double dy) { return dx-dy == (double)(x-y); } /* right */ int C(double dx, double dy, double dz) { return (dx+dy)+dz == dx+(dy+dz); } /* * wrong * * FIXME I don\u0026#39;t know what conditions cause false */ int D(double dx, double dy, double dz) { return (dx*dy)*dz == dx*(dy*dz); } /* wrong when dx != 0 and dz == 0 */ int E(double dx, double dz) { return dx/dx == dz/dz; } int main(int argc, char* argv[]) { init_seed(); int x = random_int(); int y = random_int(); int z = random_int(); double dx = (double)x; double dy = (double)y; double dz = (double)z; printf(\u0026#34;%x %x %x\\n\u0026#34;, x, y, z); assert(A(x, dx)); assert(!B(0, (double)(int)0, INT_MIN, (double)(int)INT_MIN)); assert(C(dx, dy, dz)); /* magic number, brute force attack */ assert(!D((double)(int)0x64e73387, (double)(int)0xd31cb264, (double)(int)0xd22f1fcd)); assert(!E(dx, (double)(int)0)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.90/","title":"2.90","tags":[],"description":"","content":"/* * fpwr2.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;math.h\u0026gt; float u2f(unsigned x) { return *(float*) \u0026amp;x; } /* 2^x */ float fpwr2(int x) { /* Result exponent and fraction */ unsigned exp, frac; unsigned u; if (x \u0026lt; 2-pow(2,7)-23) { /* too small. return 0.0 */ exp = 0; frac = 0; } else if (x \u0026lt; 2-pow(2,7)) { /* Denormalized result */ exp = 0; frac = 1 \u0026lt;\u0026lt; (unsigned)(x - (2-pow(2,7)-23)); } else if (x \u0026lt; pow(2,7)-1+1) { /* Normalized result */ exp = pow(2,7)-1+x; frac = 0; } else { /* Too big, return +oo */ exp = 0xFF; frac = 0; } /* pack exp and frac into 32 bits */ u = exp \u0026lt;\u0026lt; 23 | frac; /* Result as float */ return u2f(u); } int main(int argc, char* argv[]) { assert(fpwr2(0) == powf(2,0)); assert(fpwr2(100) == powf(2,100)); assert(fpwr2(-100) == powf(2,-100)); assert(fpwr2(10000) == powf(2,10000)); assert(fpwr2(-10000) == powf(2,-10000)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.91/","title":"2.91","tags":[],"description":"","content":"A.\n0x40490FDB 0 10000000 10010010000111111011011  float number\n0b11.0010010000111111011011  B.\nref 2.83\n0b11.001001(001)...  C.\n9th\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.92/","title":"2.92","tags":[],"description":"","content":"/* * float-negate.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;float-negate.h\u0026#34; float_bits float_negate(float_bits f) { unsigned sig = f \u0026gt;\u0026gt; 31; unsigned exp = f \u0026gt;\u0026gt; 23 \u0026amp; 0xFF; unsigned frac = f \u0026amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) \u0026amp;\u0026amp; (frac != 0); if (is_NAN) { return f; } return ~sig \u0026lt;\u0026lt; 31 | exp \u0026lt;\u0026lt; 23 | frac; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.93/","title":"2.93","tags":[],"description":"","content":"/* * float-absval.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;float-absval.h\u0026#34; float_bits float_absval(float_bits f) { unsigned sig = f \u0026gt;\u0026gt; 31; unsigned exp = f \u0026gt;\u0026gt; 23 \u0026amp; 0xFF; unsigned frac = f \u0026amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) \u0026amp;\u0026amp; (frac != 0); if (is_NAN) { return f; } return 0 \u0026lt;\u0026lt; 31 | exp \u0026lt;\u0026lt; 23 | frac; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.94/","title":"2.94","tags":[],"description":"","content":"/* * float-twice.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;float-twice.h\u0026#34; float_bits float_twice(float_bits f) { unsigned sig = f \u0026gt;\u0026gt; 31; unsigned exp = f \u0026gt;\u0026gt; 23 \u0026amp; 0xFF; unsigned frac = f \u0026amp; 0x7FFFFF; int is_NAN_or_oo = (exp == 0xFF); if (is_NAN_or_oo) { return f; } if (exp == 0) { /* Denormalized */ frac \u0026lt;\u0026lt;= 1; } else if (exp == 0xFF - 1) { /* twice to oo */ exp = 0xFF; frac = 0; } else { /* Normalized */ exp += 1; } return sig \u0026lt;\u0026lt; 31 | exp \u0026lt;\u0026lt; 23 | frac; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.95/","title":"2.95","tags":[],"description":"","content":"/* * float-half.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;float-half.h\u0026#34; float_bits float_half(float_bits f) { unsigned sig = f \u0026gt;\u0026gt; 31; unsigned rest = f \u0026amp; 0x7FFFFFFF; unsigned exp = f \u0026gt;\u0026gt; 23 \u0026amp; 0xFF; unsigned frac = f \u0026amp; 0x7FFFFF; int is_NAN_or_oo = (exp == 0xFF); if (is_NAN_or_oo) { return f; } /* * round to even, we care about last 2 bits of frac * * 00 =\u0026gt; 0 just \u0026gt;\u0026gt;1 * 01 =\u0026gt; 0 (round to even) just \u0026gt;\u0026gt;1 * 10 =\u0026gt; 1 just \u0026gt;\u0026gt;1 * 11 =\u0026gt; 1 + 1 (round to even) just \u0026gt;\u0026gt;1 and plus 1 */ int addition = (frac \u0026amp; 0x3) == 0x3; if (exp == 0) { /* Denormalized */ frac \u0026gt;\u0026gt;= 1; frac += addition; } else if (exp == 1) { /* Normalized to denormalized */ rest \u0026gt;\u0026gt;= 1; rest += addition; exp = rest \u0026gt;\u0026gt; 23 \u0026amp; 0xFF; frac = rest \u0026amp; 0x7FFFFF; } else { /* Normalized */ exp -= 1; } return sig \u0026lt;\u0026lt; 31 | exp \u0026lt;\u0026lt; 23 | frac; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.96/","title":"2.96","tags":[],"description":"","content":"/* * float-f2i.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;float-f2i.h\u0026#34; /* * Compute (float) f * If conversion cause overflow or f is NaN, return 0x80000000 */ int float_f2i(float_bits f) { unsigned sig = f \u0026gt;\u0026gt; 31; unsigned exp = f \u0026gt;\u0026gt; 23 \u0026amp; 0xFF; unsigned frac = f \u0026amp; 0x7FFFFF; unsigned bias = 0x7F; int num; unsigned E; unsigned M; /* * consider positive numbers * * 0 00000000 00000000000000000000000 * ===\u0026gt; * 0 01111111 00000000000000000000000 * 0 \u0026lt;= f \u0026lt; 1 * get integer 0 * * 0 01111111 00000000000000000000000 * ===\u0026gt; * 0 (01111111+31) 00000000000000000000000 * 1 \u0026lt;= f \u0026lt; 2^31 * integer round to 0 * * 0 (01111111+31) 00000000000000000000000 * ===\u0026gt; * greater * 2^31 \u0026lt;= f \u0026lt; oo * return 0x80000000 */ if (exp \u0026gt;= 0 \u0026amp;\u0026amp; exp \u0026lt; 0 + bias) { /* number less than 1 */ num = 0; } else if (exp \u0026gt;= 31 + bias) { /* number overflow */ /* or f \u0026lt; 0 and (int)f == INT_MIN */ num = 0x80000000; } else { E = exp - bias; M = frac | 0x800000; if (E \u0026gt; 23) { num = M \u0026lt;\u0026lt; (E - 23); } else { /* whether sig is 1 or 0, round to zero */ num = M \u0026gt;\u0026gt; (23 - E); } } return sig ? -num : num; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.97/","title":"2.97","tags":[],"description":"","content":"/* * float-i2f.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;limits.h\u0026gt;#include \u0026#34;float-i2f.h\u0026#34; /* * Assume i \u0026gt; 0 * calculate i\u0026#39;s bit length * * e.g. * 0x3 =\u0026gt; 2 * 0xFF =\u0026gt; 8 * 0x80 =\u0026gt; 8 */ int bits_length(int i) { if ((i \u0026amp; INT_MIN) != 0) { return 32; } unsigned u = (unsigned)i; int length = 0; while (u \u0026gt;= (1\u0026lt;\u0026lt;length)) { length++; } return length; } /* * generate mask * 00000...(32-l) 11111....(l) * * e.g. * 3 =\u0026gt; 0x00000007 * 16 =\u0026gt; 0x0000FFFF */ unsigned bits_mask(int l) { return (unsigned) -1 \u0026gt;\u0026gt; (32-l); } /* * Compute (float) i */ float_bits float_i2f(int i) { unsigned sig, exp, frac, rest, exp_sig /* except sig */, round_part; unsigned bits, fbits; unsigned bias = 0x7F; if (i == 0) { sig = 0; exp = 0; frac = 0; return sig \u0026lt;\u0026lt; 31 | exp \u0026lt;\u0026lt; 23 | frac; } if (i == INT_MIN) { sig = 1; exp = bias + 31; frac = 0; return sig \u0026lt;\u0026lt; 31 | exp \u0026lt;\u0026lt; 23 | frac; } sig = 0; /* 2\u0026#39;s complatation */ if (i \u0026lt; 0) { sig = 1; i = -i; } bits = bits_length(i); fbits = bits - 1; exp = bias + fbits; rest = i \u0026amp; bits_mask(fbits); if (fbits \u0026lt;= 23) { frac = rest \u0026lt;\u0026lt; (23 - fbits); exp_sig = exp \u0026lt;\u0026lt; 23 | frac; } else { int offset = fbits - 23; int round_mid = 1 \u0026lt;\u0026lt; (offset - 1); round_part = rest \u0026amp; bits_mask(offset); frac = rest \u0026gt;\u0026gt; offset; exp_sig = exp \u0026lt;\u0026lt; 23 | frac; /* round to even */ if (round_part \u0026lt; round_mid) { /* nothing */ } else if (round_part \u0026gt; round_mid) { exp_sig += 1; } else { /* round_part == round_mid */ if ((frac \u0026amp; 0x1) == 1) { /* round to even */ exp_sig += 1; } } } return sig \u0026lt;\u0026lt; 31 | exp_sig; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.58/","title":"3.58","tags":[],"description":"","content":"/* * decode.c */ long decode(long x, long y, long z) { long tmp = y - z; return (tmp * x) ^ (tmp \u0026lt;\u0026lt; 63 \u0026gt;\u0026gt; 63); }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.59/","title":"3.59","tags":[],"description":"","content":"assume\nmultiple\n2^128 overflows, so we don\u0026rsquo;t care about it\n# void store_prod(int128_t* dest, int64_t x, int64_t y) # dest in %rdi, x in %rsi, y in %rdx store_prod: movq %rdx, %rax # %rax = y  cqto # (int128_t)y, %rdx = (-1)y_63  movq %rsi, %rcx # %rcx = x  # x \u0026gt;\u0026gt; 63, if x == 1, %rcx = -1; if x_63 == 0, %rcx = 0  # %rcx = (-1)x_63  sarq $63, %rcx # pay attention, imulq behaves differently according to param number(1/2)  imulq %rax, %rcx # %rcx = y * -x_63  imulq %rsi, %rdx # %rdx = x * -y_63  addq %rdx, %rcx # %rcx = x * -y_63 + y * -x_63  mulq %rsi # %rdx:%rax \u0026lt;= ux * uy  # lower 64 bits are same for x * y and ux * uy. ref (2.18) on book  # %rdx = ux * uy(high 64 bits) - (x_{63}y + y_{63}x)2^{64}  addq %rcx, %rdx movq %rax, (%rdi) # set lower 64bits  movq %rdx, 8(%rdi) # set higher 64bits  ret  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.60/","title":"3.60","tags":[],"description":"","content":"A.\n   val reg     x %rdi   n %esi   result %rax   mask %rdx    B.\nresult = 0 mask = 1  C.\nmask != 0  D.\nmask = mask \u0026lt;\u0026lt; n  E.\n/* * loop2.c */ long loop2(long x, int n) { long result = 0; long mask; for (mask = 1; mask != 0; mask \u0026lt;\u0026lt;= n) { result |= (x \u0026amp; mask); } return result; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.61/","title":"3.61","tags":[],"description":"","content":"function cread_alt should be\n/* * cread-alt.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; long cread(long *xp) { return (xp ? *xp : 0); } long cread_alt(long *xp) { return (!xp ? 0 : *xp); } int main(int argc, char* argv[]) { long a = 0; assert(cread(\u0026amp;a) == cread_alt(\u0026amp;a)); assert(cread(NULL) == cread_alt(NULL)); return 0; }  compile function cread in book sample and get\n# long cread(long *xp) # xp in %rdi cread: movq (%rdi), %rax testq %rdi, %rdi movl $0, %edx cmove %rdx, %rax ret  the result of compiling cread_alt may be\n# long cread_alt(long* xp) # xp in %rdi cread_alt: movl $0, %eax testq %rdi, %rdi cmovne (%rdi), %rax  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.62/","title":"3.62","tags":[],"description":"","content":"/* * 3.62.c */ /* Enumerated type creates set of contants numbered 0 and upward */ typedef enum { MODE_A, MODE_B, MODE_C, MODE_D, MODE_E } mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: *p1 = *p1 + *p2; result = *p1; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; result = 27; break; case MODE_E: result = 27; break; default: result = 12; break; } return result; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.63/","title":"3.63","tags":[],"description":"","content":"/* * 3.63.c */ long switch_prob(long x, long n) { long result = x; switch(n) { /* Fill in code here */ case 60: case 62: result = x * 8; break; case 63: result = x \u0026gt;\u0026gt; 3; break; case 64: x = x \u0026lt;\u0026lt; 4 - x; case 65: x = x * x; default: result = x + 0x4B; } return result; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.64/","title":"3.64","tags":[],"description":"","content":"A.\n3.1 in book\nT D[R][C]; \u0026amp;D[i][j] = Xd + L(C*i + j) T means type, D means data, R means row, C means column L means sizeof(T), Xd means address of D  similarly, in 3d array\nTYPE D[R][S][T] \u0026amp;D[i][j][k] = Xd + L(S*T*i + T*j + k)  B.\n.section .data .global A A: .fill 3640/8, 8, 121 # fill data 121  .section .text .global store_ele # long store_ele(long i, long j, long k, long *dest) # i in %rdi, j in %rsi, k in %rdx, dest in %rcx store_ele: leaq (%rsi, %rsi, 2), %rax # t1 = j*3  leaq (%rsi, %rax, 4), %rax # t1 = j*13  movq %rdi, %rsi # t2 = i  salq $6, %rsi # t2 = i*64  addq %rsi, %rdi # t3 = i*65  addq %rax, %rdi # t3 = i*65 + j*13  addq %rdi, %rdx # t4 = i*65 + j*13 + k  movq A(,%rdx,8), %rax # t1 = *(A + 8*t4)  movq %rax, (%rcx) # *dest = t1  movl $3640, %eax # return 3640  ret  base on comments,\nS * T = 65 T = 13 8*R*S*T = 3640  so\nR = 7 S = 5 T = 13  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.65/","title":"3.65","tags":[],"description":"","content":"A.\n\u0026amp;A[i][j] in %rdx  B.\n\u0026amp;A[j][i] in %rax  C.\naddq $8, %rdx # means A[i][j] -\u0026gt; A[i][j+1] addq $120, %rax # means A[j][i] -\u0026gt; A[j+1][i], 120 == 8*M  M = 15\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.66/","title":"3.66","tags":[],"description":"","content":".section .text .global sum_col # long sum_col(long n, long A[NR(n)][NC(n)], long j) # n in %rdi, A in %rsi, j in %rdx sum_col: leaq 1(,%rdi,4), %r8 # t1 = n*4 + 1  leaq (%rdi,%rdi,2), %rax # t2 = n*3  movq %rax, %rdi # t3 = n*3  testq %rax, %rax # test n*3  jle .L4 # n*3 \u0026lt;= 0, jump .L4  salq $3, %r8 # t1 = t1*8 = 8*(n*4 + 1)  leaq (%rsi,%rdx,8), %rcx # t4 = j*8 + A  movl $0, %eax # t2 = 0  movl $0, %edx # t5 = 0 .L3: addq (%rcx), %rax # t2 = *(t4) = *(A + j*8)  addq $1, %rdx # t5 = t5+1  addq %r8, %rcx # t4 = t1+t4 = A + j*8 + 8*(n*4 + 1)  cmpq %rdi, %rdx # cmp t5 \u0026amp; t3  jne .L3 # if t5 != n*3, loop  rep ret .L4: movl $0, %eax # return 0  ret  base on comments in asm code\ncmpq %rdi, %rdx # cmp t5 \u0026amp; t3 jne .L3 # if t5 != n*3, loop  t5 is var i, so NR(n) == n*3\nleaq 1(,%rdi,4), %r8 # t1 = n*4 + 1 ..... salq $3, %r8 # t1 = t1*8 = 8*(n*4 + 1) ..... addq %r8, %rcx # t4 = t1+t4 = A + j*8 + 8*(n*4 + 1)  in every loop, pointer move 8*(n*4 + 1) bytes, so NC(n) == n*4 + 1\nthanks gonglinyuan\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.67/","title":"3.67","tags":[],"description":"","content":"3.67\n/* * 3.67.c */ typedef struct { long a[2]; long *p; } strA; typedef struct { long u[2]; long q; } strB; strB process(strA a) { strB r; r.u[0] = s.a[1]; r.u[1] = s.a[0]; r.q = *s.p; return r; } long eval(long x, long y, long z) { strA s; s.a[0] = x; s.a[1] = y; s.p = \u0026amp;z; strB r = process(s); return r.u[0] + r.u[1] + r.q; }  # strB process(strA s) # s in %rdi process: movq %rdi, %rax movq 24(%rsp), %rdx movq (%rdx), %rdx movq 16(%rsp), %rcx movq %rcx, (%rdi) movq 8(%rsp), %rcx movq %rcx, 8(%rdi) movq %rdx, 16(%rdi) ret # long eval(long x, long y, long z) # x in %rdi, y in %rsi, z in %rdx eval: subq $104, %rsp movq %rdx, 24(%rsp) leaq 24(%rsp), %rax movq %rdi, (%rsp) movq %rsi, 8(%rsp) movq %rax, 16(%rsp) leaq 64(%rsp), %rdi call process movq 72(%rsp), %rax addq 64(%rsp), %rax addq 80(%rsp), %rax addq $104, %rsp ret  A.\n104 +------------------+ | | | | | | | | | | | | | | | | 64 +------------------+ \u0026lt;-- %rdi | | | | | | | | | | | | 32 +------------------+ | z | 24 +------------------+ | \u0026amp;z | 16 +------------------+ | y | 8 +------------------+ | x | 0 +------------------+ \u0026lt;-- %rsp  B.\neval pass a new address %rsp+64 to process\nC.\nprocess access s by %rsp+offset, not by %rdi\nD.\neval pass address %rsp+64 to process, process store data from here as beginning, finially return this address\nE.\n104 +------------------+ | | | | | | | | | | | | 88 +------------------+ | z | 80 +------------------+ | x | 72 +------------------+ | y | 64 +------------------+ \u0026lt;-- %rdi(eval pass in) | | \\ | | -- %rax(process pass out) | | | | | | | | 32 +------------------+ | z | 24 +------------------+ | \u0026amp;z | 16 +------------------+ | y | 8 +------------------+ | x | 0 +------------------+ \u0026lt;-- %rsp in eval | | -8 +------------------+ \u0026lt;-- %rsp in process  F.\ncaller find space and pass space address to callee, callee store data on this space area and return this address\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.68/","title":"3.68","tags":[],"description":"","content":"# void setVal(str1* p, str2* q) # p in %rdi, q in %rsi setVal: # 8(%rsi) fetch q-\u0026gt;t, int t is aligned by 4, so 4 \u0026lt; B \u0026lt;=8  movslq 8(%rsi), %rax # 32(%rsi) fetch q-\u0026gt;u, long u is aligned by 8  # offset q-\u0026gt;s is offset q-\u0026gt;t + 4, so 24 \u0026lt; 12 + A*2 \u0026lt;= 32  addq 32(%rsi), %rax # 184(%rdi) fetch p-\u0026gt;v, long y is aligned by 8, so 176 \u0026lt; A*B*4 \u0026lt;= 184  movq %rax, 184(%rdi) ret  4 \u0026lt; B \u0026lt;= 8 5 \u0026lt; A \u0026lt;= 10 44 \u0026lt; A*B \u0026lt;= 46  only\nA = 9\nB = 5\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.69/","title":"3.69","tags":[],"description":"","content":"/* * 3.69.c */ typedef struct { int first; a_struct a[CNT]; int last; } b_struct; void test(long i, b_struct *bp) { int n = bp-\u0026gt;first + bp-\u0026gt;last; a_struct *ap = \u0026amp;bp-\u0026gt;a[i]; ap-\u0026gt;x[ap-\u0026gt;idx] = n; }  # void test(long i, b_struct *bp) # i in %rdi, bp in %rsi test: mov 0x120(%rsi), %ecx # bp+0x120 fetch bp-\u0026gt;last  add (%rsi), %ecx # bp-\u0026gt;first + bp-\u0026gt;last  lea (%rdi,%rdi,4), %rax # i*5  lea (%rsi,%rax,8), %rax # bp+i*40  # ap = \u0026amp;bp-\u0026gt;a[i] = bp+i*40+8, +8 means skip int first  # so a_struct is aligned by 8, size is 40  # check last instrction, %rdx here saves value ap-\u0026gt;idx!!!  # so in a_struct, idx is first element  mov 0x8(%rax), %rdx movslq %ecx, %rcx # n = bp-\u0026gt;first + bp-\u0026gt;last, convert to long  # save n to address 8*(ap-\u0026gt;idx) + bp+i*40+0x8 + 0x8 (0x10)  # bp+i*40+0x8 means ap  # ap + 0x8 means \u0026amp;(ap-\u0026gt;x)  # ap + 0x8 + 8*(ap-\u0026gt;idx) means \u0026amp;(ap-x[ap-\u0026gt;idx])  # second element of a_struct is x, x is an array of long  # 8*(ap-\u0026gt;idx) means idx is also long type  mov %rcx, 0x10(%rax,%rdx,8) # size of a_struct is 40 and aligned by 8  # so array x has 4 long elements  # finally, a_struct is  # typedef struct {  # long idx,  # long x[4]  # } a_struct  retq  A.\n7*40 + 8 = 288 = 0x120, so\nCNT = 7\nthanks https://github.com/zagortenay333\nB.\ntypedef struct { long idx, long x[4] } a_struct "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.70/","title":"3.70","tags":[],"description":"","content":"A.\n   val offset     e1.p 0   e1.y 8   e2.x 0   e2.next 8    B.\n16\nC.\n# void proc(union ele *up) # up in %rdi proc: # %rax = *(up+8), don\u0026#39;t know it\u0026#39;s next or y  movq 8(%rdi), %rax # %rdx = *( *(up+8) ), %rax stands for a pointer  # so *( *(up+8) ) means *(up-\u0026gt;e2.next)  movq (%rax), %rdx # %rdx = *( *(up-\u0026gt;e2.next) )  # %rdx is treated as a pointer  # so %rdx stores *( *(up-\u0026gt;e2.next).e1.p )  movq (%rdx), %rdx # %rax stores *(up+8)  # %rax is treated as a pointer  # so %rax = *( up-\u0026gt;e2.next ), stands for another union ele\u0026#39;s address  #  # in subq, %rdx is a long number  # *( *(up-\u0026gt;e2.next)+8 ) must be a long number  # so 8(%rax) means *(up-\u0026gt;e2.next).e1.y  subq 8(%rax), %rdx # %rdi never changes in previous instrctions  # instrction below is the final assignment  # so (%rdi) means up-\u0026gt;e2.x  movq %rdx, (%rdi) ret  base on comments\n/* * 3.70.c */ union ele { struct { long *p; long y; } e1; struct { long x; union ele *next; } e2; }; void proc(union ele *up) { /* up-\u0026gt; = *( ) - ; */ up-\u0026gt;e2.x = *( *(up-\u0026gt;e2.next).e1.p ) - *(up-\u0026gt;e2.next).e1.y }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.71/","title":"3.71","tags":[],"description":"","content":"/* * good-echo.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#define BUF_SIZE 12  void good_echo(void) { char buf[BUF_SIZE]; while(1) { /* function fgets is interesting */ char* p = fgets(buf, BUF_SIZE, stdin); if (p == NULL) { break; } printf(\u0026#34;%s\u0026#34;, p); } return; } int main(int argc, char* argv[]) { good_echo(); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.72/","title":"3.72","tags":[],"description":"","content":"/* * 3.72.c */ #include \u0026lt;alloca.h\u0026gt; long aframe(long n, long idx, long *q) { long i; long **p = alloca(n * sizeof(long*)); p[0] = \u0026amp;i; for (i = 1; i \u0026lt; n; i++) { p[i] = q; } return *p[idx]; }  # long aframe(long n, long idx, long *q) # n in %rdi, idx in %rsi, q in %rdx aframe: pushq %rbp movq %rsp, %rbp subq $16, %rsp leaq 30(,%rdi,8), %rax andq $-16, %rax subq %rax, %rsp leaq 15(%rsp), %r8 andq $-16, %r8  A.\nwhen n is odd\nwhen n is even\nB.\nthe least multiple of 16 that greater than s2\nC.\n   which e1 n s1     least 1 even n%16==1   greatest 24 odd n%16==0    least:\ne1 can\u0026rsquo;t be 0, if e1 == 0, p should equal to s2\nwhen n is even, e1 + e2 == 16, if e2 is 15, e1 will be least that can reach, so s1 == n that n%16==1\ngreatest:\nwhen n is odd, e1 + e2 == 24. if p == s2, e2 == 0, so e1 will be the greatest value 24 that can reach. s1 == n that n%16 == 0\nD.\np is aligned by 16\ns2 is the least multiple of 16 that preserve 8*n size space\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.73/","title":"3.73","tags":[],"description":"","content":"/* * 3.73.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x) { __asm__( \u0026#34;vxorps %xmm1, %xmm1, %xmm1\\n\\t\u0026#34; \u0026#34;vucomiss %xmm1, %xmm0\\n\\t\u0026#34; \u0026#34;jp .P\\n\\t\u0026#34; \u0026#34;ja .A\\n\\t\u0026#34; \u0026#34;jb .B\\n\\t\u0026#34; \u0026#34;je .E\\n\\t\u0026#34; \u0026#34;.A:\\n\\t\u0026#34; \u0026#34;movl $2, %eax\\n\\t\u0026#34; \u0026#34;jmp .Done\\n\\t\u0026#34; \u0026#34;.B:\\n\\t\u0026#34; \u0026#34;movl $0, %eax\\n\\t\u0026#34; \u0026#34;jmp .Done\\n\\t\u0026#34; \u0026#34;.E:\\n\\t\u0026#34; \u0026#34;movl $1, %eax\\n\\t\u0026#34; \u0026#34;jmp .Done\\n\\t\u0026#34; \u0026#34;.P:\\n\\t\u0026#34; \u0026#34;movl $3, %eax\\n\\t\u0026#34; \u0026#34;.Done:\\n\\t\u0026#34; ); } int main(int argc, char* argv[]) { range_t n = NEG, z = ZERO, p = POS, o = OTHER; assert(o == find_range(0.0/0.0)); assert(n == find_range(-2.3)); assert(z == find_range(0.0)); assert(p == find_range(3.33)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.74/","title":"3.74","tags":[],"description":"","content":"/* * 3.74.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x) { __asm__( \u0026#34;vxorps %xmm1, %xmm1, %xmm1\\n\\t\u0026#34; \u0026#34;movq $1, %rax\\n\\t\u0026#34; \u0026#34;movq $2, %r8\\n\\t\u0026#34; \u0026#34;movq $0, %r9\\n\\t\u0026#34; \u0026#34;movq $3, %r10\\n\\t\u0026#34; \u0026#34;vucomiss %xmm1, %xmm0\\n\\t\u0026#34; \u0026#34;cmovaq %r8, %rax\\n\\t\u0026#34; \u0026#34;cmovbq %r9, %rax\\n\\t\u0026#34; \u0026#34;cmovpq %r10, %rax\\n\\t\u0026#34; ); } int main(int argc, char* argv[]) { range_t n = NEG, z = ZERO, p = POS, o = OTHER; assert(o == find_range(0.0/0.0)); assert(n == find_range(-2.3)); assert(z == find_range(0.0)); assert(p == find_range(3.33)); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.75/","title":"3.75","tags":[],"description":"","content":"A.\n   param n real img     1 %xmm0 %xmm1   2 %xmm2 %xmm3   3 %xmm4 %xmm5   n \u0026hellip; \u0026hellip;    B.\nreturn %xmm0 as real part, %xmm1 as img part\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.45/","title":"4.45","tags":[],"description":"","content":"subq $8, %rsp movq REG, (%rsp)  A.\nNo\nif REG is %rsp, we push %rsp-8 instead of %rsp into stack\nB.\nmovq REG, -8(%rsp) subq $8, %rsp  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.46/","title":"4.46","tags":[],"description":"","content":"movq (%rsp), REG addq $8, %rsp  A.\nNo\nif REG is %rsp, movq (%rsp), REG pop the right value into %rsp, but addq $8, %rsp modify it\nB.\naddq $8, %rsp movq 8(%rsp), REG  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.47/","title":"4.47","tags":[],"description":"","content":"A.\nChange into pointer version\n/* * bubble-sort-pointer.c */ void bubble_p(long* data, long count) { long *i, *last; for (last = data+count-1; last \u0026gt; data; last--) { for (i = data; i \u0026lt; last; i++) { if (*(i+1) \u0026lt; *i) { /* swap adjacent elements */ long t = *(i+1); *(i+1) = *i; *i = t; } } } }  B.\nCompile bubble-sort-pointer.c\ngcc -S -Og bubble-sort-pointer.c  get gas file\n.file\t\u0026#34;bubble-sort-pointer.c\u0026#34; .text .globl\tbubble_p .type\tbubble_p, @function bubble_p: .LFB0: .cfi_startproc leaq\t-8(%rdi,%rsi,8), %rsi jmp\t.L2 .L4: movq\t8(%rax), %rdx movq\t(%rax), %rcx cmpq\t%rcx, %rdx jge\t.L3 movq\t%rcx, 8(%rax) movq\t%rdx, (%rax) .L3: addq\t$8, %rax jmp\t.L5 .L6: movq\t%rdi, %rax .L5: cmpq\t%rsi, %rax jb\t.L4 subq\t$8, %rsi .L2: cmpq\t%rdi, %rsi ja\t.L6 rep ret .cfi_endproc .LFE0: .size\tbubble_p, .-bubble_p .ident\t\u0026#34;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609\u0026#34; .section\t.note.GNU-stack,\u0026#34;\u0026#34;,@progbits  Change it into ys version\n/* bubble-sort-pointer.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 data: .quad 0x0000000000000004 .quad 0x0000000000000003 .quad 0x0000000000000002 data_end: .quad 0x0000000000000001 main: irmovq data,%rdi irmovq data_end,%rsi call ysBubbleP ret # long ys_bubble_p(long *data, long *end) # data in %rdi, end in %rsi ysBubbleP: jmp L2 L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 jge L3 rmmovq %r10, 8(%rax) rmmovq %r9, (%rax) L3: irmovq $8, %r8 addq %r8, %rax jmp L5 L6: rrmovq %rdi, %rax L5: rrmovq %rsi, %r8 subq %rax, %r8 jg L4 irmovq $8, %r8 subq %r8, %rsi L2: rrmovq %rsi, %r8 subq %rdi, %r8 jg L6 ret .pos 0x200 stack:  main difference is second param of function is long* end instead of long count for convinient, long* end marks the position of last element.\nusing yas assemble it and yis run it, see output\n../sim/misc/yas bubble-sort-pointer.ys ../sim/misc/yis bubble-sort-pointer.yo Stopped in 117 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax:\t0x0000000000000000\t0x0000000000000020 %rsp:\t0x0000000000000000\t0x0000000000000200 %rsi:\t0x0000000000000000\t0x0000000000000018 %rdi:\t0x0000000000000000\t0x0000000000000018 %r9:\t0x0000000000000000\t0x0000000000000001 %r10:\t0x0000000000000000\t0x0000000000000002 Changes to memory: 0x0018:\t0x0000000000000004\t0x0000000000000001 0x0020:\t0x0000000000000003\t0x0000000000000002 0x0028:\t0x0000000000000002\t0x0000000000000003 0x0030:\t0x0000000000000001\t0x0000000000000004 0x01f0:\t0x0000000000000000\t0x0000000000000055 0x01f8:\t0x0000000000000000\t0x0000000000000013  initial array order is 4,3,2,1, now 1,2,3,4\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.48/","title":"4.48","tags":[],"description":"","content":"a little easy changes.\n/* bubble-sort-pointer.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 data: .quad 0x0000000000000004 .quad 0x0000000000000003 .quad 0x0000000000000002 data_end: .quad 0x0000000000000001 main: irmovq data,%rdi irmovq data_end,%rsi call ysBubbleP ret # long ys_bubble_p(long *data, long *end) # data in %rdi, end in %rsi ysBubbleP: jmp L2 L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 ############################################################## # begin differences ############################################################## cmovl %r9, %r11 cmovl %r10, %r9 cmovl %r11, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax) ############################################################## # end ############################################################## irmovq $8, %r8 addq %r8, %rax jmp L5 L6: rrmovq %rdi, %rax L5: rrmovq %rsi, %r8 subq %rax, %r8 jg L4 irmovq $8, %r8 subq %r8, %rsi L2: rrmovq %rsi, %r8 subq %rdi, %r8 jg L6 ret .pos 0x200 stack:  run test, output\n../sim/misc/yas bubble-sort-pointer-3-cmove.ys ../sim/misc/yis bubble-sort-pointer-3-cmove.yo Stopped in 129 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax:\t0x0000000000000000\t0x0000000000000020 %rsp:\t0x0000000000000000\t0x0000000000000200 %rsi:\t0x0000000000000000\t0x0000000000000018 %rdi:\t0x0000000000000000\t0x0000000000000018 %r9:\t0x0000000000000000\t0x0000000000000002 %r10:\t0x0000000000000000\t0x0000000000000001 %r11:\t0x0000000000000000\t0x0000000000000001 Changes to memory: 0x0018:\t0x0000000000000004\t0x0000000000000001 0x0020:\t0x0000000000000003\t0x0000000000000002 0x0028:\t0x0000000000000002\t0x0000000000000003 0x0030:\t0x0000000000000001\t0x0000000000000004  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.49/","title":"4.49","tags":[],"description":"","content":"it\u0026rsquo;s a brilliant idea, 3 xor is a normal swap\nif x = 9, y = 10\nx = x ^ y x:9^10; y:10 y = x ^ y x:9^10; y:9 x = x ^ y x:10; y:9  if change y after step 1\ntmp = x x:9; y:10; tmp:9 # store x x = x ^ y x:9^10; y:10 y = tmp x:9^10; y:9 # set y to origin x y = x ^ y x:9^10; y:10 x = x ^ y x:9; y:10  no swap happens. that\u0026rsquo;s core in code below\n/* bubble-sort-pointer.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 data: .quad 0x0000000000000004 .quad 0x0000000000000003 .quad 0x0000000000000002 data_end: .quad 0x0000000000000001 main: irmovq data,%rdi irmovq data_end,%rsi call ysBubbleP ret # long ys_bubble_p(long *data, long *end) # data in %rdi, end in %rsi ysBubbleP: jmp L2 L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 ############################################ # begin differences ############################################ rrmovq %r9, %r8 rrmovq %r10, %r11 xorq %r9, %r10 subq %r11, %r8 cmovge %r11, %r9 xorq %r10, %r9 xorq %r9, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax) ############################################ # end ############################################ irmovq $8, %r8 addq %r8, %rax jmp L5 L6: rrmovq %rdi, %rax L5: rrmovq %rsi, %r8 subq %rax, %r8 jg L4 irmovq $8, %r8 subq %r8, %rsi L2: rrmovq %rsi, %r8 subq %rdi, %r8 jg L6 ret .pos 0x200 stack:  test and output, watch memory changes:\n../sim/misc/yas bubble-sort-pointer-1-cmove.ys ../sim/misc/yis bubble-sort-pointer-1-cmove.yo Stopped in 141 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax:\t0x0000000000000000\t0x0000000000000020 %rsp:\t0x0000000000000000\t0x0000000000000200 %rsi:\t0x0000000000000000\t0x0000000000000018 %rdi:\t0x0000000000000000\t0x0000000000000018 %r9:\t0x0000000000000000\t0x0000000000000002 %r10:\t0x0000000000000000\t0x0000000000000001 %r11:\t0x0000000000000000\t0x0000000000000002 Changes to memory: 0x0018:\t0x0000000000000004\t0x0000000000000001 0x0020:\t0x0000000000000003\t0x0000000000000002 0x0028:\t0x0000000000000002\t0x0000000000000003 0x0030:\t0x0000000000000001\t0x0000000000000004  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.50/","title":"4.50","tags":[],"description":"","content":"/* switch.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 array: .quad 0x0000000000000000 .quad 0x0000000000000000 .quad 0x0000000000000000 .quad 0x0000000000000000 main: # test number 1, -1, 3, 5 irmovq array, %r10 irmovq $1,%rdi call switchv rmmovq %rax, (%r10) irmovq $-1,%rdi call switchv rmmovq %rax, 8(%r10) irmovq $3,%rdi call switchv rmmovq %rax, 16(%r10) irmovq $5,%rdi call switchv rmmovq %rax, 24(%r10) ret table: .quad LD # default branch .quad L0 # idx == 0 .quad L1 # idx == 1 .quad L2 # idx == 2 .quad L3 # idx == 3 .quad L4 # idx == 4 .quad L5 # idx == 5 # long switchv(long idx) # idx in %rdi switchv: # contant number irmovq $8, %r8 irmovq $0, %r10 irmovq $1, %r11 irmovq $0, %rax irmovq table, %rcx # table address rrmovq %rdi, %rdx subq %r8, %rdx jg def # idx \u0026gt; 5 subq %r10, %rdi jl def # idx \u0026lt; 0 mul: # calculate 8 * %rdi subq %r10, %rdi je addr addq %r8, %rcx subq %r11, %rdi jmp mul addr: # jump using table address addq %r8, %rcx mrmovq (%rcx), %rdi pushq %rdi ret def: # default branch irmovq table, %rcx mrmovq (%rcx), %rdi pushq %rdi ret L0: irmovq $0xaaa, %rax ret L1: jmp LD L2: jmp L5 L3: irmovq $0xccc, %rax ret L4: jmp LD L5: irmovq $0xbbb, %rax ret LD: irmovq $0xddd, %rax ret .pos 0x200 stack:  test function switchv in main, using idx 1,-1,3,5, store result into array\ntest and output, watch changes to memory:\n../sim/misc/yas switch.ys ../sim/misc/yis switch.yo Stopped in 133 steps at PC = 0x13. Status 'HLT', CC Z=0 S=0 O=0 Changes to registers: %rax:\t0x0000000000000000\t0x0000000000000bbb %rcx:\t0x0000000000000000\t0x00000000000000e7 %rdx:\t0x0000000000000000\t0xfffffffffffffffd %rsp:\t0x0000000000000000\t0x0000000000000200 %rdi:\t0x0000000000000000\t0x00000000000001a8 %r8:\t0x0000000000000000\t0x0000000000000008 %r11:\t0x0000000000000000\t0x0000000000000001 Changes to memory: 0x0000:\t0x000000000200f430\t0x0000000000000ddd 0x0008:\t0x0000000038800000\t0x0000000000000ddd 0x0010:\t0x0000000000000000\t0x0000000000000ccc 0x0018:\t0x0000000000000000\t0x0000000000000bbb  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.51/","title":"4.51","tags":[],"description":"","content":"   phase iaddq V,rB     F icode:ifun = M1[PC]; rA:rB = M1[PC+1]; valC = M8[PC+2]; valP = PC + 10;   D valB = R[rB]   E valE = valB + valC; set CC   M    W R[rB] = valE   PC PC = valP    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.52/","title":"4.52","tags":[],"description":"","content":"easy changes if you make 4.51 right.\ncheck whole file ./chapter4/code/sim/seq/seq-full.hcl with iaddq functionality\nonly watch changes with origin seq-full.hcl file\n(cd ./site/content/chapter4/code/sim/seq; diff -u origin-seq-full.hcl seq-full.hcl)  --- origin-seq-full.hcl\t2021-02-25 07:26:33.312592690 +0000 +++ seq-full.hcl\t2021-02-25 07:26:33.312592690 +0000 @@ -107,16 +107,16 @@  bool instr_valid = icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, -\tIOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; +\tIOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };  # Does fetched instruction require a regid byte? bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, -\tIIRMOVQ, IRMMOVQ, IMRMOVQ }; +\tIIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };  # Does fetched instruction require a constant word? bool need_valC = -\ticode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }; +\ticode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };  ################ Decode Stage ################################### @@ -129,7 +129,7 @@  ## What register should be used as the B source? word srcB = [ -\ticode in { IOPQ, IRMMOVQ, IMRMOVQ } : rB; +\ticode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ } : rB;  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don\u0026#39;t need register ]; @@ -137,7 +137,7 @@  ## What register should be used as the E destination? word dstE = [ icode in { IRRMOVQ } \u0026amp;\u0026amp; Cnd : rB; -\ticode in { IIRMOVQ, IOPQ} : rB; +\ticode in { IIRMOVQ, IOPQ, IIADDQ } : rB;  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don\u0026#39;t write any register ]; @@ -153,7 +153,7 @@  ## Select input A to ALU word aluA = [ icode in { IRRMOVQ, IOPQ } : valA; -\ticode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : valC; +\ticode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;  icode in { ICALL, IPUSHQ } : -8; icode in { IRET, IPOPQ } : 8; # Other instructions don\u0026#39;t need ALU @@ -162,7 +162,7 @@  ## Select input B to ALU word aluB = [ icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, -\tIPUSHQ, IRET, IPOPQ } : valB; +\tIPUSHQ, IRET, IPOPQ, IIADDQ } : valB;  icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don\u0026#39;t need ALU ]; @@ -174,7 +174,7 @@  ]; ## Should the condition codes be updated? -bool set_cc = icode in { IOPQ }; +bool set_cc = icode in { IOPQ, IIADDQ };  ################ Memory Stage ###################################  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.53/","title":"4.53","tags":[],"description":"","content":"1. data hazard something handled by data-forward must be handled by stall if no data-forward anymore. so when\nd_srcA in { e_dstE, M_dstM, M_dstE, W_dstM, W_dstE } || d_srcB in { e_dstE, M_dstM, M_dstE, W_dstM, W_dstE }  data hazard happens, we have to insert bubble in phase E and stall phase F\u0026amp;D\nload/use hazard\nload/use hazard only happens when we use data-forward. no load/use hazard if no data-forward.\npay attention\n previous load/use toggle condition d_srcA == E_dstM || d_srcB == E_dstM now toggles data hazard. in the beginning, d_srcA == RNONE == e_dstE == E_dstM == ...etc, that\u0026rsquo;s not data hazard  so we get:\nsituation: data_hazard bool s_data_hazard = ( ( d_srcA != RNONE \u0026amp;\u0026amp; d_srcA in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } ) || ( d_srcB != RNONE \u0026amp;\u0026amp; d_srcB in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } ) )  2. ret situation keep same\nsituation: ret bool s_ret = IRET in { D_icode, E_icode, M_icode };  3. jxx error keep same\nsituation: jxx error bool s_jxx_error = (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd);  4. hazard composition X means nothing to do; stall means stall; bubble means inserting bubble\n   num data ret jxx F D E M W     1 0 0 0 X X X X X   2 0 0 1 X bubble bubble X X   3 0 1 0 stall bubble X X X   4 1 0 0 stall stall bubble X X    situation 1: nothing happens, every thing is fine\nsituation 2: just jxx error, keep same with book\nsituation 3: just ret, keep same with book\nsituation 4: just data hazard, stall phase F and D, insert bubble in phase E, M and W keep same\nwhat if two/three of them happen same time?\nret:\n +-----------+ +-----------+ +-----------+ M | | M | | M | ret | +-----------+ +-----------+ +-----------+ E | | E | ret | E | nop | +-----------+ +-----------+ +-----------+ D | ret | D | nop | D | nop | +-----------+ +-----------+ +-----------+ 1 2 3  one of them\njxx error:\n +-----------+ M | | +-----------+ E | jxx | +-----------+ D | | +-----------+  when jxx error happens, E_icode must be jxx\ndata hazard:\n \u0026lt;--+ +-----------+ | M | |\u0026lt;--+ +-----------+ | E | |\u0026lt;--+ +-----------+ | D | xxx +---+ +-----------+  when data hazard happens, D_icode is not sure, xxx means any instruction\ncomposition 1: ret and jxx\nkeep same on book\ncomposition 2: ret and data hazard\nthey two happens same time, so xxx must be ret\n \u0026lt;--+ +-----------+ | M | |\u0026lt;--+ +-----------+ | E | |\u0026lt;--+ +-----------+ | D | ret +---+ +-----------+  when they happen same time, data hazard is prior to ret because if ret doesn\u0026rsquo;t stall to avoid data hazard, we get wrong answer with ISA\ncomposition 3: jxx error and data hazard\n \u0026lt;--+ +-----------+ | M | |\u0026lt;--+ +-----------+ | E | jxx |\u0026lt;--+ +-----------+ | D | xxx +---+ +-----------+  when they two happens same time, jxx error is prior to data hazard because next 2 instructions is canceled when jxx error, xxx is canceled anymore.\ncomposition 4: ret \u0026amp; jxx error \u0026amp; data hazard\n \u0026lt;--+ +-----------+ | M | |\u0026lt;--+ +-----------+ | E | jxx |\u0026lt;--+ +-----------+ | D | ret +---+ +-----------+  same like composition 3.\nfinally:\n   num data ret jxx F D E M W     1 0 0 0 X X X X X   2 0 0 1 X bubble bubble X X   3 0 1 0 stall bubble X X X   4 1 0 0 stall stall bubble X X   5 0 1 1 X bubble bubble X X   6 1 0 1 X bubble bubble X X   7 1 1 0 stall stall bubble X X   8 1 1 1 X bubble bubble X X    F:\n stall: (data || ret) \u0026amp;\u0026amp; !jxx bubble: 0  D:\n stall: data \u0026amp;\u0026amp; !jxx bubble: jxx || (!data \u0026amp;\u0026amp; ret)  E:\n stall: 0 bubble: jxx || data  M:\nkeep same\nW:\nkeep same\nfinally:\ncheck file ./site/content/chapter4/code/sim/pipe/pipe-stall.hcl\nwatch changes with origin pipe-stall.hcl file\n(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-stall.hcl pipe-stall.hcl)  --- origin-pipe-stall.hcl\t2021-02-25 07:26:33.309259378 +0000 +++ pipe-stall.hcl\t2021-02-25 07:26:33.309259378 +0000 @@ -303,40 +303,95 @@  ]; ################ Pipeline Register Control ######################### +# situation: ret +# bool s_ret = IRET in { D_icode, E_icode, M_icode }; +# +# situation: jxx error +# bool s_jxx_error = (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd); +# +# situation: data_hazard +# bool s_data_hazard = +# ( +# ( +# d_srcA != RNONE \u0026amp;\u0026amp; +# d_srcA in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } +# ) || +# ( +# d_srcB != RNONE \u0026amp;\u0026amp; +# d_srcB in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } +# ) +# )  # Should I stall or inject a bubble into Pipeline Register F? # At most one of these can be true. -bool F_stall = -\t# Modify the following to stall the update of pipeline register F -\t0 || -\t# Stalling at fetch while ret passes through pipeline -\tIRET in { D_icode, E_icode, M_icode }; +# bool F_stall = (s_ret || s_data_hazard) \u0026amp;\u0026amp; !s_jxx_error; +bool F_stall = ( + (IRET in { D_icode, E_icode, M_icode }) || + ( + ( + d_srcA != RNONE \u0026amp;\u0026amp; + d_srcA in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) || + ( + d_srcB != RNONE \u0026amp;\u0026amp; + d_srcB in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) + ) + ) \u0026amp;\u0026amp; + !(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd);  bool F_bubble = 0; # Should I stall or inject a bubble into Pipeline Register D? # At most one of these can be true. -bool D_stall = -\t# Modify the following to stall the instruction in decode -\t0; +# bool D_stall = s_data_hazard \u0026amp;\u0026amp; !s_jxx_error; +# bool D_bubble = s_jxx_error || (!s_data_hazard \u0026amp;\u0026amp; s_ret) +bool D_stall = ( + ( + d_srcA != RNONE \u0026amp;\u0026amp; + d_srcA in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) || + ( + d_srcB != RNONE \u0026amp;\u0026amp; + d_srcB in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) + ) \u0026amp;\u0026amp; + !(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd);  bool D_bubble = -\t# Mispredicted branch -\t(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || -\t# Stalling at fetch while ret passes through pipeline -\t!(E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }) \u0026amp;\u0026amp; -\t# but not condition for a generate/use hazard -\t!0 \u0026amp;\u0026amp; -\tIRET in { D_icode, E_icode, M_icode }; + (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || + ( + !( + ( + d_srcA != RNONE \u0026amp;\u0026amp; + d_srcA in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) || + ( + d_srcB != RNONE \u0026amp;\u0026amp; + d_srcB in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) + ) \u0026amp;\u0026amp; + (IRET in { D_icode, E_icode, M_icode }) + );  # Should I stall or inject a bubble into Pipeline Register E? # At most one of these can be true. +# bool E_stall = 0; +# bool E_bubble = s_jxx_error || s_data_hazard  bool E_stall = 0; bool E_bubble = -\t# Mispredicted branch -\t(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || -\t# Modify the following to inject bubble into the execute stage -\t0; + (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || + ( + ( + d_srcA != RNONE \u0026amp;\u0026amp; + d_srcA in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) || + ( + d_srcB != RNONE \u0026amp;\u0026amp; + d_srcB in { e_dstE, E_dstM, M_dstM, M_dstE, W_dstM, W_dstE } + ) + ); +  # Should I stall or inject a bubble into Pipeline Register M? # At most one of these can be true.  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.54/","title":"4.54","tags":[],"description":"","content":"almost same like 4.51 seq-full.hcl\ncheck file ./site/content/chapter4/code/sim/pipe/pipe-full.hcl with iaddq functionality\nwatch changes with origin pipe-full.hcl file\n(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-full.hcl pipe-full.hcl)  --- origin-pipe-full.hcl\t2021-02-25 07:26:33.309259378 +0000 +++ pipe-full.hcl\t2021-02-25 07:26:33.309259378 +0000 @@ -158,7 +158,7 @@  # Is instruction valid? bool instr_valid = f_icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, -\tIOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; +\tIOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };  # Determine status code for fetched instruction word f_stat = [ @@ -171,11 +171,11 @@  # Does fetched instruction require a regid byte? bool need_regids = f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, -\tIIRMOVQ, IRMMOVQ, IMRMOVQ }; +\tIIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };  # Does fetched instruction require a constant word? bool need_valC = -\tf_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }; +\tf_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };  # Predict next value of PC word f_predPC = [ @@ -195,14 +195,14 @@  ## What register should be used as the B source? word d_srcB = [ -\tD_icode in { IOPQ, IRMMOVQ, IMRMOVQ } : D_rB; +\tD_icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ } : D_rB;  D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don\u0026#39;t need register ]; ## What register should be used as the E destination? word d_dstE = [ -\tD_icode in { IRRMOVQ, IIRMOVQ, IOPQ} : D_rB; +\tD_icode in { IRRMOVQ, IIRMOVQ, IOPQ, IIADDQ } : D_rB;  D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don\u0026#39;t write any register ]; @@ -239,7 +239,7 @@  ## Select input A to ALU word aluA = [ E_icode in { IRRMOVQ, IOPQ } : E_valA; -\tE_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : E_valC; +\tE_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : E_valC;  E_icode in { ICALL, IPUSHQ } : -8; E_icode in { IRET, IPOPQ } : 8; # Other instructions don\u0026#39;t need ALU @@ -248,7 +248,7 @@  ## Select input B to ALU word aluB = [ E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, -\tIPUSHQ, IRET, IPOPQ } : E_valB; +\tIPUSHQ, IRET, IPOPQ, IIADDQ } : E_valB;  E_icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don\u0026#39;t need ALU ]; @@ -260,7 +260,7 @@  ]; ## Should the condition codes be updated? -bool set_cc = E_icode == IOPQ \u0026amp;\u0026amp; +bool set_cc = (E_icode == IOPQ || E_icode == IIADDQ) \u0026amp;\u0026amp;  # State changes only during normal operation !m_stat in { SADR, SINS, SHLT } \u0026amp;\u0026amp; !W_stat in { SADR, SINS, SHLT };  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.55/","title":"4.55","tags":[],"description":"","content":"Problem mismatch with skeleton code, we follow the code here: change J_YES to UNCOND\none point is\nM_icode == IJXX \u0026amp;\u0026amp; M_ifun != UNCOND  means all jxx except jmp instruction\nanother important point is Mispredicted branch condition\norigin\n(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd)  now\n(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; e_Cnd)  if e_Cnd means misprediction\ncheck file ./site/content/chapter4/code/sim/pipe/pipe-nt.hcl\nwatch changes with origin pipe-nt.hcl\n(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-nt.hcl pipe-nt.hcl)  --- origin-pipe-nt.hcl\t2021-02-25 07:26:33.309259378 +0000 +++ pipe-nt.hcl\t2021-02-25 07:26:33.309259378 +0000 @@ -139,7 +139,7 @@  ## What address should instruction be fetched at word f_pc = [ # Mispredicted branch. Fetch at incremented PC -\tM_icode == IJXX \u0026amp;\u0026amp; !M_Cnd : M_valA; +\tM_icode == IJXX \u0026amp;\u0026amp; M_ifun != UNCOND \u0026amp;\u0026amp; M_Cnd : M_valA;  # Completion of RET instruction W_icode == IRET : W_valM; # Default: Use predicted value of PC @@ -183,6 +183,7 @@  # Predict next value of PC word f_predPC = [ # BNT: This is where you\u0026#39;ll change the branch prediction rule +\tf_icode == IJXX \u0026amp;\u0026amp; f_ifun != UNCOND : f_valP;  f_icode in { IJXX, ICALL } : f_valC; 1 : f_valP; ]; @@ -273,7 +274,11 @@  !m_stat in { SADR, SINS, SHLT } \u0026amp;\u0026amp; !W_stat in { SADR, SINS, SHLT }; ## Generate valA in execute stage -word e_valA = E_valA; # Pass valA through stage +## pass branch address back by M_valA +word e_valA = [ +\tE_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND : E_valC; +\t1 : E_valA; # Pass valA through stage +];  ## Set dstE to RNONE in event of not-taken conditional move word e_dstE = [ @@ -343,7 +348,7 @@  bool D_bubble = # Mispredicted branch -\t(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || +\t(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; e_Cnd) ||  # Stalling at fetch while ret passes through pipeline # but not condition for a load/use hazard !(E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }) \u0026amp;\u0026amp; @@ -354,7 +359,7 @@  bool E_stall = 0; bool E_bubble = # Mispredicted branch -\t(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || +\t(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; e_Cnd) ||  # Conditions for a load/use hazard E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB};  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.56/","title":"4.56","tags":[],"description":"","content":"Problem mismatch with skeleton code, we follow the code here: change J_YES to UNCOND\nalmost same like 4.55. main differences are\n pay attention to whether valC is greater or lower than valP pass both valC and valP back by M registers because if misprediction happens we need judge jumping back to valC or valP  check file ./site/content/chapter4/code/sim/pipe/pipe-btfnt.hcl\nonly watch changes with origin pipe-btfnt.hcl\n(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-btfnt.hcl pipe-btfnt.hcl)  --- origin-pipe-btfnt.hcl\t2021-02-25 07:26:33.309259378 +0000 +++ pipe-btfnt.hcl\t2021-02-25 07:26:33.309259378 +0000 @@ -139,7 +139,10 @@  ## What address should instruction be fetched at word f_pc = [ # Mispredicted branch. Fetch at incremented PC -\tM_icode == IJXX \u0026amp;\u0026amp; !M_Cnd : M_valA; +\t# backward taken error +\tM_icode == IJXX \u0026amp;\u0026amp; M_ifun != UNCOND \u0026amp;\u0026amp; M_valE \u0026lt; M_valA \u0026amp;\u0026amp; !M_Cnd : M_valA; +\t# forward not-taken error +\tM_icode == IJXX \u0026amp;\u0026amp; M_ifun != UNCOND \u0026amp;\u0026amp; M_valE \u0026gt;= M_valA \u0026amp;\u0026amp; M_Cnd : M_valE;  # Completion of RET instruction W_icode == IRET : W_valM; # Default: Use predicted value of PC @@ -183,6 +186,8 @@  # Predict next value of PC word f_predPC = [ # BBTFNT: This is where you\u0026#39;ll change the branch prediction rule +\tf_icode == IJXX \u0026amp;\u0026amp; f_ifun != UNCOND \u0026amp;\u0026amp; f_valC \u0026lt; f_valP : f_valC; +\tf_icode == IJXX \u0026amp;\u0026amp; f_ifun != UNCOND \u0026amp;\u0026amp; f_valC \u0026gt;= f_valP : f_valP;  f_icode in { IJXX, ICALL } : f_valC; 1 : f_valP; ]; @@ -244,12 +249,15 @@  # way to get valC into pipeline register M, so that # you can correct for a mispredicted branch. +## pass valC by M_valE, pass valP by M_valA +  ## Select input A to ALU word aluA = [ E_icode in { IRRMOVQ, IOPQ } : E_valA; E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : E_valC; E_icode in { ICALL, IPUSHQ } : -8; E_icode in { IRET, IPOPQ } : 8; +\tE_icode in { IJXX } : E_valC;  # Other instructions don\u0026#39;t need ALU ]; @@ -258,6 +266,7 @@  E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ } : E_valB; E_icode in { IRRMOVQ, IIRMOVQ } : 0; +\tE_icode in { IJXX } : 0;  # Other instructions don\u0026#39;t need ALU ]; @@ -343,7 +352,11 @@  bool D_bubble = # Mispredicted branch -\t(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || +\t# backward taken error or forward not-taken error +\t( +\t(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; E_valC \u0026lt; E_valA \u0026amp;\u0026amp; !e_Cnd) || +\t(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; E_valC \u0026gt;= E_valA \u0026amp;\u0026amp; e_Cnd) +\t) ||  # BBTFNT: This condition will change # Stalling at fetch while ret passes through pipeline # but not condition for a load/use hazard @@ -355,7 +368,11 @@  bool E_stall = 0; bool E_bubble = # Mispredicted branch -\t(E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || +\t# backward taken error or forward not-taken error +\t( +\t(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; E_valC \u0026lt; E_valA \u0026amp;\u0026amp; !e_Cnd) || +\t(E_icode == IJXX \u0026amp;\u0026amp; E_ifun != UNCOND \u0026amp;\u0026amp; E_valC \u0026gt;= E_valA \u0026amp;\u0026amp; e_Cnd) +\t) ||  # BBTFNT: This condition will change # Conditions for a load/use hazard E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.57/","title":"4.57","tags":[],"description":"","content":"A.\nconsider load/use hazard\nE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB };     situation 1 2 3 4     E_dstM == d_srcA 1 1 0 0   E_dstM == d_srcB 1 0 1 0    situation 4:\nnormal, no hazard happens\nsituation 1,2,3:\nload/use hazard happens\nif E_icode in { IMRMOVQ, IPOPQ }, then E_dstM must not be RNONE\nconsider situation 1 and 3, E_dstM == d_srcB, then d_srcB is not RNONE and must be used in phase E, so load-forward can\u0026rsquo;t work. load-forward only work in situation 2!\nconsider all the instructions that d_srcA is not RNONE\n   instructions d_srcA valA used in phase E? load-forward works?     rrmovq rA Y N   rmmovq rA N Y   opq rA Y N   pushq rA N Y   ret rsp N N   popq rsp N N    ret and popq can\u0026rsquo;t work because d_srcA == d_srcB == %rsp, that\u0026rsquo;s not in situation 2!!\nfinally, load/use only work in condition:\nE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; ( E_dstM == d_srcB || ( E_dstM == d_srcA \u0026amp;\u0026amp; !(D_icode in { IRMMOVQ, IPUSHQ }) ) );  B.\ncheck file ./site/content/chapter4/code/sim/pipe/pipe-lf.hcl\nonly watch changes with origin pipe-lf.hcl\n(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-lf.hcl pipe-lf.hcl)  --- origin-pipe-lf.hcl\t2021-02-25 07:26:33.309259378 +0000 +++ pipe-lf.hcl\t2021-02-25 07:26:33.309259378 +0000 @@ -271,6 +271,7 @@  ## from memory stage when appropriate ## Here it is set to the default used in the normal pipeline word e_valA = [ +\tE_icode in { IRMMOVQ, IPUSHQ } \u0026amp;\u0026amp; E_srcA == M_dstM : m_valM;  1 : E_valA; # Use valA from stage pipe register ]; @@ -329,7 +330,13 @@  bool F_stall = # Conditions for a load/use hazard ## Set this to the new load/use condition -\t0 || +\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; + ( + E_dstM == d_srcB || + ( + E_dstM == d_srcA \u0026amp;\u0026amp; !(D_icode in { IRMMOVQ, IPUSHQ }) + ) + ) ||  # Stalling at fetch while ret passes through pipeline IRET in { D_icode, E_icode, M_icode }; @@ -338,15 +345,29 @@  bool D_stall = # Conditions for a load/use hazard ## Set this to the new load/use condition -\t0; +\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; + ( + E_dstM == d_srcB || + ( + E_dstM == d_srcA \u0026amp;\u0026amp; !(D_icode in { IRMMOVQ, IPUSHQ }) + ) + );  bool D_bubble = # Mispredicted branch (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || # Stalling at fetch while ret passes through pipeline # but not condition for a load/use hazard -\t!(E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }) \u0026amp;\u0026amp; -\tIRET in { D_icode, E_icode, M_icode }; +\t!( +\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; +\t( +\tE_dstM == d_srcB || +\t( +\tE_dstM == d_srcA \u0026amp;\u0026amp; !(D_icode in { IRMMOVQ, IPUSHQ }) +\t) +\t) +\t) \u0026amp;\u0026amp; +\tIRET in { D_icode, E_icode, M_icode };  # Should I stall or inject a bubble into Pipeline Register E? # At most one of these can be true. @@ -356,7 +377,13 @@  (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || # Conditions for a load/use hazard ## Set this to the new load/use condition -\t0; +\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; +\t( +\tE_dstM == d_srcB || +\t( +\tE_dstM == d_srcA \u0026amp;\u0026amp; !(D_icode in { IRMMOVQ, IPUSHQ }) +\t) +\t);  # Should I stall or inject a bubble into Pipeline Register M? # At most one of these can be true.  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.58/","title":"4.58","tags":[],"description":"","content":"it\u0026rsquo;s not a hard problem, focus on key points:\n fetch popq instruction twice. first time fetch popq, works like iaddq; second time fetch popq2, works like mrmovq load/use condition should be popq2 not popq.     phase popq rA popq2 rA     works like iadd $8, %rsp mrmovq -8(%rsp), rA   F valP = PC valP = PC + 2   D valB=R[rsp] valB=R[rsp]   E valE=valB+8 valE=valB-8   M  valM=M8[valE]   W R[rsp]=valE R[rA]=valM    check file ./site/content/chapter4/code/sim/pipe/pipe-1w.hcl\nonly watch changes with origin pipe-1w.hcl\n(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-1w.hcl pipe-1w.hcl)  --- origin-pipe-1w.hcl\t2021-02-25 07:26:33.309259378 +0000 +++ pipe-1w.hcl\t2021-02-25 07:26:33.309259378 +0000 @@ -157,6 +157,7 @@  ## so that it will be IPOP2 when fetched for second time. word f_icode = [ imem_error : INOP; +\tD_icode == IPOPQ : IPOP2;  1: imem_icode; ]; @@ -169,7 +170,7 @@  # Is instruction valid? bool instr_valid = f_icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, -\tIOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; +\tIOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IPOP2 };  # Determine status code for fetched instruction word f_stat = [ @@ -182,7 +183,7 @@  # Does fetched instruction require a regid byte? bool need_regids = f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, -\tIIRMOVQ, IRMMOVQ, IMRMOVQ }; +\tIIRMOVQ, IRMMOVQ, IMRMOVQ, IPOP2 };  # Does fetched instruction require a constant word? bool need_valC = @@ -192,6 +193,7 @@  word f_predPC = [ f_icode in { IJXX, ICALL } : f_valC; ## 1W: Want to refetch popq one time +\tf_icode == IPOPQ : f_pc;  1 : f_valP; ]; @@ -204,14 +206,14 @@  ## What register should be used as the A source? word d_srcA = [ D_icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : D_rA; -\tD_icode in { IPOPQ, IRET } : RRSP; +\tD_icode in { IRET } : RRSP;  1 : RNONE; # Don\u0026#39;t need register ]; ## What register should be used as the B source? word d_srcB = [ D_icode in { IOPQ, IRMMOVQ, IMRMOVQ } : D_rB; -\tD_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; +\tD_icode in { IPUSHQ, IPOPQ, IPOP2, ICALL, IRET } : RRSP;  1 : RNONE; # Don\u0026#39;t need register ]; @@ -224,7 +226,7 @@  ## What register should be used as the M destination? word d_dstM = [ -\tD_icode in { IMRMOVQ, IPOPQ } : D_rA; +\tD_icode in { IMRMOVQ, IPOP2 } : D_rA;  1 : RNONE; # Don\u0026#39;t write any register ]; @@ -255,7 +257,7 @@  word aluA = [ E_icode in { IRRMOVQ, IOPQ } : E_valA; E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : E_valC; -\tE_icode in { ICALL, IPUSHQ } : -8; +\tE_icode in { ICALL, IPUSHQ, IPOP2 } : -8;  E_icode in { IRET, IPOPQ } : 8; # Other instructions don\u0026#39;t need ALU ]; @@ -263,7 +265,7 @@  ## Select input B to ALU word aluB = [ E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, -\tIPUSHQ, IRET, IPOPQ } : E_valB; +\tIPUSHQ, IRET, IPOPQ, IPOP2 } : E_valB;  E_icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don\u0026#39;t need ALU ]; @@ -292,13 +294,13 @@  ## Select memory address word mem_addr = [ -\tM_icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : M_valE; -\tM_icode in { IPOPQ, IRET } : M_valA; +\tM_icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ, IPOP2 } : M_valE; +\tM_icode in { IRET } : M_valA;  # Other instructions don\u0026#39;t need address ]; ## Set read control signal -bool mem_read = M_icode in { IMRMOVQ, IPOPQ, IRET }; +bool mem_read = M_icode in { IMRMOVQ, IRET, IPOP2 };  ## Set write control signal bool mem_write = M_icode in { IRMMOVQ, IPUSHQ, ICALL }; @@ -350,7 +352,7 @@  bool F_bubble = 0; bool F_stall = # Conditions for a load/use hazard -\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; +\tE_icode in { IMRMOVQ, IPOP2 } \u0026amp;\u0026amp;  E_dstM in { d_srcA, d_srcB } || # Stalling at fetch while ret passes through pipeline IRET in { D_icode, E_icode, M_icode }; @@ -359,7 +361,7 @@  # At most one of these can be true. bool D_stall = # Conditions for a load/use hazard -\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; +\tE_icode in { IMRMOVQ, IPOP2 } \u0026amp;\u0026amp;  E_dstM in { d_srcA, d_srcB }; bool D_bubble = @@ -367,7 +369,7 @@  (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || # Stalling at fetch while ret passes through pipeline # but not condition for a load/use hazard -\t!(E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }) \u0026amp;\u0026amp; +\t!(E_icode in { IMRMOVQ, IPOP2 } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }) \u0026amp;\u0026amp;  # 1W: This condition will change IRET in { D_icode, E_icode, M_icode }; @@ -378,7 +380,7 @@  # Mispredicted branch (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || # Conditions for a load/use hazard -\tE_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; +\tE_icode in { IMRMOVQ, IPOP2 } \u0026amp;\u0026amp;  E_dstM in { d_srcA, d_srcB}; # Should I stall or inject a bubble into Pipeline Register M?  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.59/","title":"4.59","tags":[],"description":"","content":"4.47 is the better one\nloop part in 4.47\nL4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 jge L3 rmmovq %r10, 8(%rax) rmmovq %r9, (%rax)  50% jge is right, run 5 instructions; 50% jge is wrong, run 7 instructions and 2 nop bubble. so Cycles Per Loop is 50% * 5 + (7 + 2) * 50% = 7\nloop part in 4.48\nL4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 cmovl %r9, %r11 cmovl %r10, %r9 cmovl %r11, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax)  Cycles Per Loop is 9\nloop part in 4.49\nL4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 rrmovq %r10, %r11 xorq %r9, %r10 subq %r11, %r8 cmovge %r11, %r9 xorq %r10, %r9 xorq %r9, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax)  Cycles Per Loop is 11\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.13/","title":"5.13","tags":[],"description":"","content":"A.\n +----+----+----+----+-----+-----+ |%rbp|%rcx|%rax|%rbx|%xmm1|%xmm0| +----+----+----+----+-----+-----++----+ +----|----|----|----------|---\u0026gt;| | | +----|----|----------|---\u0026gt;|load| vmovad 0(%rbp,%rcx,8),%xmm1 | | | | +-----|----| | | | | | | | +----+ | +----|----|----------|---\u0026gt;| | | | | | | | |load|---+ | | +----|----------|---\u0026gt;| | | | | | | | | +----+ | vmulsd (%rax,%rcx,8),%xmm1,%xmm0 | | | | | | | |\u0026lt;--+ | | | | +-----|---\u0026gt;|mul | | | | | +-----|----| | | | | | | | +----+ | | | | +-----|---\u0026gt;| | | | | | | +---\u0026gt;|add | vaddsd %xmm1,%xmm0,%xmm0 | | | | | +----| | | | | | | | +----+ | +----|----|----------|---\u0026gt;| | | | | | | |add | addq $1, %rcx | +----|----|----------|----| | | | | | | | +----+ | +----|----|----------|---\u0026gt;| | | | | | | | |cmp |---+ cmpq %rbx, %rcx | | | +----|-----|---\u0026gt;| | | | | | | | | +----+ | | | | | | | | | | | | | | | | |jne |\u0026lt;--+ jne .L15 | | | | | | | | | | | | | | +----+ v v v v v v +----+----+----+----+-----+-----+ |%rbp|%rcx|%rax|%rbx|%xmm1|%xmm0| +----+----+----+----+-----+-----+ +----+ +-----+ |%rcx| |%xmm0| +----+ +-----+ | | | +----+ | \u0026lt;--------- key path +----\u0026gt;|load|------+ | | +----+ | | | v v | +----+ +-+--+ +-+--+ +----\u0026gt;|load|---\u0026gt;|mul |---\u0026gt;|add | | +----+ +----+ +----+ | | | | v | +----+ | |add | | +----+ | | | v v +-+--+ +-----+ |%rcx| |%xmm0| +----+ +-----+  B.\n5-12\nfloat add cell, CPE is 3.0\nC.\n5-12\nlong add cell, 1.0\nD.\nonly float add on key path\n/* * 5.13.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;./lib/vec.h\u0026#34; /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; for (i = 0; i \u0026lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(4); vec_ptr v = new_vec(4); data_t *arr = (data_t*) malloc(sizeof(data_t) * 4); arr[0] = 0; arr[1] = 1; arr[2] = 2; arr[3] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, \u0026amp;res); assert(res == 1+4+9); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.14/","title":"5.14","tags":[],"description":"","content":" +----+ +----+ |sum | | i | +----+ +----+ | | v | +----+ +----+ +----+ | |add |\u0026lt;------|mul |\u0026lt;-|load|\u0026lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |\u0026lt;------|mul |\u0026lt;-|load|\u0026lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |\u0026lt;------|mul |\u0026lt;-|load|\u0026lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |\u0026lt;------|mul |\u0026lt;-|load|\u0026lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |\u0026lt;------|mul |\u0026lt;-|load|\u0026lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |\u0026lt;------|mul |\u0026lt;-|load|\u0026lt;------+ +----+ +----+ +----+ | | | | v | +----+ | |add | | \u0026lt;------- key path +----+ | | | | v v +----+ +-+--+ |sum | | i | +----+ +----+  A.\nevery element has 6 long/float add\nelement count is n/6\nso n/6 * 6 = n\nCPE bound == 1.0\nB.\nsame like A\n/* * 5.14.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;./lib/vec.h\u0026#34; #define LEN 24  /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; for (i = 0; i \u0026lt; length-6; i+=6) { sum = sum + udata[i] * vdata[i] + udata[i+1] * vdata[i+1] + udata[i+2] * vdata[i+2] + udata[i+3] * vdata[i+3] + udata[i+4] * vdata[i+4] + udata[i+5] * vdata[i+5]; } for(; i \u0026lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[1] = 1; arr[2] = 2; arr[3] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, \u0026amp;res); assert(res == 1+4+9); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.15/","title":"5.15","tags":[],"description":"","content":"maybe\n float mul capatity limit(less than 6) register renaming limit  /* * 5.15.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;./lib/vec.h\u0026#34; #define LEN 24  /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; data_t sum1 = (data_t) 0; data_t sum2 = (data_t) 0; data_t sum3 = (data_t) 0; data_t sum4 = (data_t) 0; data_t sum5 = (data_t) 0; for (i = 0; i \u0026lt; length-6; i+=6) { sum = sum + udata[i] * vdata[i]; sum1 = sum1 + udata[i+1] * vdata[i+1]; sum2 = sum2 + udata[i+2] * vdata[i+2]; sum3 = sum3 + udata[i+3] * vdata[i+3]; sum4 = sum4 + udata[i+4] * vdata[i+4]; sum5 = sum5 + udata[i+5] * vdata[i+5]; } for(; i \u0026lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum + sum1 + sum2 + sum3 + sum4 + sum5; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[11] = 1; arr[2] = 2; arr[23] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, \u0026amp;res); assert(res == 1+4+9); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.16/","title":"5.16","tags":[],"description":"","content":"/* * 5.16.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;./lib/vec.h\u0026#34; #define LEN 24  /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; for (i = 0; i \u0026lt; length-6; i+=6) { sum = sum + ( udata[i] * vdata[i] + udata[i+1] * vdata[i+1] + udata[i+2] * vdata[i+2] + udata[i+3] * vdata[i+3] + udata[i+4] * vdata[i+4] + udata[i+5] * vdata[i+5] ); } for(; i \u0026lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[11] = 1; arr[2] = 2; arr[23] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, \u0026amp;res); assert(res == 1+4+9); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.17/","title":"5.17","tags":[],"description":"","content":"/* * 5.17.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;assert.h\u0026gt; void* basic_memset(void *s, int c, size_t n) { size_t cnt = 0; unsigned char *schar = s; while (cnt \u0026lt; n) { *schar++ = (unsigned char) c; cnt++; } return s; } /* * K = sizeof(unsigned long) * cs store K chars for memset */ void* effective_memset(void *s, unsigned long cs, size_t n) { /* align to K */ size_t K = sizeof(unsigned long); size_t cnt = 0; unsigned char *schar = s; while (cnt \u0026lt; n) { if ((size_t)schar % K == 0) { break; } *schar++ = (unsigned char)cs; cnt++; } /* set K chars one time */ unsigned long *slong = (unsigned long *)schar; size_t rest = n - cnt; size_t loop = rest / K; size_t tail = rest % K; for (size_t i = 0; i \u0026lt; loop; i++) { *slong++ = cs; } /* pad the tail part */ schar = (unsigned char *)slong; for (size_t i = 0; i \u0026lt; tail; i++) { *schar++ = (unsigned char)cs; } return s; } int main(int argc, char* argv[]) { size_t space = sizeof(char) * 65537; // careful! malloc SIZE_MAX size memory will make sys slow  // or crash down  // size_t space = SIZE_MAX;  void* basic_space = malloc(space); void* effective_space = malloc(space); int basic_fill = 0xFF; unsigned long effective_fill = ~0; basic_memset(basic_space, basic_fill, space); effective_memset(effective_space, effective_fill, space); assert(memcmp(basic_space, effective_space, space) == 0); free(basic_space); free(effective_space); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.18/","title":"5.18","tags":[],"description":"","content":"try to write 6*3a version for function holy.\nthis solution is not fully tested on my machine, sorry for that :(\nuname -p   Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz\n if your machine core is Intel Core i7 Haswell like book, you can try install google gperftools for profile\n(cd ./site/content/chapter5/code; make 5.18.prof)  loop more times is a good idea :)\n/* * 5.18.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; /* calculate a0 + a1*x + a2*x^2 + ... + an*x^n */ double poly(double a[], double x, long degree) { long i; double result = a[0]; double xpwr = x; for (i = 1; i \u0026lt;= degree; i++) { result += a[i] * xpwr; xpwr = x * xpwr; } return result; } /* version 6*3a */ double poly_6_3a(double a[], double x, long degree) { long i = 1; double result = a[0]; double result1 = 0; double result2 = 0; double xpwr = x; double xpwr1 = x * x * x; double xpwr2 = x * x * x * x * x; double xpwr_step = x * x * x * x * x * x; for (; i \u0026lt;= degree - 6; i+=6) { result = result + (a[i]*xpwr + a[i+1]*xpwr*x); result1 = result1 + (a[i+2]*xpwr1 + a[i+3]*xpwr1*x); result2 = result2 + (a[i+4]*xpwr2 + a[i+5]*xpwr2*x); xpwr *= xpwr_step; xpwr1 *= xpwr_step; xpwr2 *= xpwr_step; } for (; i \u0026lt;= degree; i++) { result = result + a[i]*xpwr; xpwr *= x; } return result + result1 + result2; } /* apply horner\u0026#39;s method */ double polyh(double a[], double x, long degree) { long i; double result = a[degree]; for (i = degree-1; i \u0026gt;= 0; i--) { result = a[i] + x*result; } return result; } #define LOOP 1000 #define LEN 1000  int main(int argc, char* argv[]) { double a[10 + 1] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}; double x = 2; long degree = 10; assert(poly(a, x, degree) == 2+4+8+16+32+(2+4+8+16+32)*32); assert(poly_6_3a(a, x, degree) == 2+4+8+16+32+(2+4+8+16+32)*32); assert(poly(a, x, degree) == polyh(a, x, degree)); x = 1; degree = LEN; double b[LEN + 1]; for (int c = 0; c \u0026lt; LOOP; c++) { poly(b, x, degree); } for (int c = 0; c \u0026lt; LOOP; c++) { poly_6_3a(b, x, degree); } for (int c = 0; c \u0026lt; LOOP; c++) { polyh(b, x, degree); } return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.19/","title":"5.19","tags":[],"description":"","content":"this solution\u0026rsquo;s performance is not fully meassured.\nif you\u0026rsquo;re interested, you can try install google\u0026rsquo;s gperftools for profile\n(cd ./site/content/chapter5/code; make 5.19.prof)  loop more times is a good idea :)\n/* * 5.19.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; void psum1a(float a[], float p[], long n) { long i; float last_val, val; last_val = p[0] = a[0]; for (i = 1; i \u0026lt; n; i++) { val = last_val + a[i]; p[i] = val; last_val = val; } } /* version 4*1a */ void psum_4_1a(float a[], float p[], long n) { long i; float val, last_val; float tmp, tmp1, tmp2, tmp3; last_val = p[0] = a[0]; for (i = 1; i \u0026lt; n - 4; i++) { tmp = last_val + a[i]; tmp1 = tmp + a[i+1]; tmp2 = tmp1 + a[i+2]; tmp3 = tmp2 + a[i+3]; p[i] = tmp; p[i+1] = tmp1; p[i+2] = tmp2; p[i+3] = tmp3; /* key point */ last_val = last_val + (a[i] + a[i+1] + a[i+2] + a[i+3]); } for (; i \u0026lt; n; i++) { last_val += a[i]; p[i] = last_val; } } #define LOOP 1000 #define LEN 1000  int main(int argc, char* argv[]) { float a[5] = { 1, 2, 3, 4, 5 }; float p[5]; psum1a(a, p, 5); assert(p[4] == 15); float q[5]; psum_4_1a(a, q, 5); assert(q[4] == 15); /* for prof */ for (int i = 0; i \u0026lt; LOOP; i++) { float s[LEN]; float d[LEN]; psum1a(s, d, LEN); psum_4_1a(s, d, LEN); } return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.22/","title":"6.22","tags":[],"description":"","content":"assume\nBits Per Track\nbpt = x * r * K  Track Count\ntc = (1-x) * r * M  M, K are constant\nso\nBit Count\nbc = K * M * r^2 * (1-x) * x  when x == 1/2, bc is maximum\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.23/","title":"6.23","tags":[],"description":"","content":"T_avg_seek = 4ms\nT_avg_rotation = 1/2 * 1/15000 * 60s/min * 1000ms/s = 2ms\nT_avg_transfer = 1/15000 * 1/800 * 60s/min * 1000ms/s = 0.005ms\nso\nT_access = 6.005ms\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.24/","title":"6.24","tags":[],"description":"","content":"almost same like problem 6.4 on book\nA.\nbest case: blocks are mapped sequential and on same cylinder. just seek data once.\nT_avg_seek = 4ms T_avg_rotation = 2ms  file size 2MB, block size 512B, block count 2MB/512B = 4000\nBlock Per Track = 1000, so we need rotate 4 loop to read all data\nT_transfer = T_rotation = T_max_rotation * 4 = 16ms  so\nT_access = 22ms  B.\nworse case: blocks are random.\nT_access = 4000 * (T_avg_seek + T_avg_rotation) = 24s  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.25/","title":"6.25","tags":[],"description":"","content":"   m c B E S t s b     32 1024 4 4 64 24 6 2   32 1024 4 256 1 30 0 2   32 1024 8 1 128 22 7 3   32 1024 8 128 1 29 0 3   32 1024 32 1 32 22 5 5   32 1024 32 4 8 24 3 5    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.26/","title":"6.26","tags":[],"description":"","content":"   m c B E S t s b     32 2048 8 1 256 21 8 3   32 2048 4 4 128 23 7 2   32 1024 2 8 64 25 6 1   32 1024 32 2 16 23 4 5    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.27/","title":"6.27","tags":[],"description":"","content":"A.\nt = 0x45 = 0b01000101, s = 0b001, b = xx(xx is 00/01/10/11)\naddress may be\n01000101 001 xx format 0 1000 1010 01xx  address range: 0x08A4 - 0x08A7\nt = 0x38\naddress range: 0x0704 - 0x0707\nB.\n0x1238 - 0x123B\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.28/","title":"6.28","tags":[],"description":"","content":"same like 6.27\nA.\nNone\nB.\n0x18F0 - 0x18F3\n0x00B0 - 0x00B3\nC.\n0x0E34 - 0x0E37\nD.\n0x1BDC - 0x1BDF\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.29/","title":"6.29","tags":[],"description":"","content":"A.\n 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+ | CT | CT | CT | CT | CT | CT | CT | CT | CI | CI | CO | CO | +----+----+----+----+----+----+----+----+----+----+----+----+  B.\n   read/write addr hit? value(or unknown)     read 0x834 No -   write 0x836 Yes unknown   read 0xFFD Yes 0xC0    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.30/","title":"6.30","tags":[],"description":"","content":"A.\nC = E * B * S = 128B\nB.\n 12 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+----+ | CT | CT | CT | CT | CT | CT | CT | CT | CI | CI | CI | CO | CO | +----+----+----+----+----+----+----+----+----+----+----+----+----+  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.31/","title":"6.31","tags":[],"description":"","content":"A.\n 12 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+----+ | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 0 | +----+----+----+----+----+----+----+----+----+----+----+----+----+  B.\n   param value     CO 0x02   CI 0x06   CT 0x38   hit? Yes   return 0xEB    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.32/","title":"6.32","tags":[],"description":"","content":"A.\n 12 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+----+ | 1 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | +----+----+----+----+----+----+----+----+----+----+----+----+----+  B.\n   param value     CO 0x00   CI 0x02   CT 0xB7   hit? No   return \u0026ndash;    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.33/","title":"6.33","tags":[],"description":"","content":"same like 6.27\n0x1788 - 0x178B\n0x16C8 - 0x16CB\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.34/","title":"6.34","tags":[],"description":"","content":"src:\n    c0 c1 c2 c3     r0 m m h m   r1 m h m h   r2 m m h m   r3 m h m h    dst:\n    c0 c1 c2 c3     r0 m m m m   r1 m m m m   r2 m m m m   r3 m m m m    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.35/","title":"6.35","tags":[],"description":"","content":"src:\n    c0 c1 c2 c3     r0 m h h h   r1 m h h h   r2 m h h h   r3 m h h h    dst:\n    c0 c1 c2 c3     r0 m h h h   r1 m h h h   r2 m h h h   r3 m h h h    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.36/","title":"6.36","tags":[],"description":"","content":"int x[2][128]; int i; int sum = 0; for (i = 0; i \u0026lt; 128; i++) { sum += x[0][i] * x[1][i]; } A.\nC = 512, E = 1, B = 16, S = 32\ntotal read count: 2 * 128\nx[0][i] address: i*4\nx[1][i] address: (128+i)4 = 512 + i4\nso x[0][i] and x[1][i] are cached into same block.\nmiss rate 100%\nB.\nC = 1024, E = 1, B = 16, S = 64\nsizeof(x) == 2 * 128 * 4 == C\nwhole array can be cached.\nmiss rate is depended on block size B.\nB = 16, sizeof(int) = 4, so\nmiss rate is 25%\nC.\nC = 512, E = 2, B = 16, S = 16\ntotal read count: 2 * 128\nx[0][i] address: i*4\nx[1][i] address: (128+i)4 = 512 + i4\nso x[0][i] and x[1][i] are cached into different block in same set.\nin first half, all elements can be cached. miss rate is 25%.\nfor (i = 0; i \u0026lt; 64; i++) sum += x[0][i] * x[1][i]; in second half\nfor (i = 64; i \u0026lt; 128; i++) sum += x[0][i] * x[1][i]; x[0][i] is not in cache. according to LRU strategy, cache x[0][i] into the same block with x[0][i-64], cache x[1][i] into the same block with x[1][i-64]. miss rate is 25%.\nfinally, miss rate is still 25%.\nD.\nNo\nif B is still 16, sizeof(int) = 4, block can only cache 4 int one time.\nread int first time toggle memory cache, miss; next 3 time read hit.\n25% miss rate is lowest.\nE.\nYes\nassume B = 32, block cache 8 int at one time.\nonly 1 miss in 8 time int read.\nmiss rate can be 12.5%.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.37/","title":"6.37","tags":[],"description":"","content":"/* * 6.37.c */ typedef int array_t[N][N]; int sumA(array_t a) { int i, j; int sum = 0; for (i = 0; i \u0026lt; N; i++) for (j = 0; j \u0026lt; N; j++) sum += a[i][j]; return sum; } int sumB(array_t a) { int i, j; int sum = 0; for (i = 0; i \u0026lt; N; i++) for (j = 0; j \u0026lt; N; j++) sum += a[j][i]; return sum; } int sumC(array_t a) { int i, j; int sum = 0; for (i = 0; i \u0026lt; N; i+=2) for (j = 0; j \u0026lt; N; j+=2) sum += (a[j][i] + a[j][i+1] + a[j+1][i] + a[j+1][i+1]) }  C = 4096, B = 16, E = 1, S = 256\nN = 64 sizeof(array_t) == 64 * 64 == 4096 == 4*C\nmemory-cache graph memory address start from 0 and end to 4096*4. cell size is 16B. number(0-255) in cell means cache block number that the cell will be cached. 0 +---------+ | 0 | 16 +---------+ | 1 | 32 +---------+ | 2 | 48 +---------+ | . | | . | | . | | . | | . | 4096-16 +---------+ | 255 | 4096 +---------+ | 0 | 4096+16 +---------+ | 1 | 4096+32 +---------+ | . | | . | | . | | . | | . | | . | 4096*4-16+---------+ | 255 | 4096*4 +---------+  A. sumA\nsum += a[i][j];  read memory address order:\n0, 4, 8, 12, \u0026hellip;.., 4096*4-4\nread cache order:\n0, 0, 0, 0, 1, 1, 1, 1,\u0026hellip;..255, 255, 255, 255, 0, 0, 0, 0,\u0026hellip;..255, 255, 255, 255\nfirst cache read miss, next 3 time read hit.\nmiss rate: 25%\nB. sumB\nsum += a[j][i];  read memory address order:\n0, 644, 6442, \u0026hellip;. 64463, 4, 644+4, 6442+4, \u0026hellip;. 4096*4-4\nread cache order:\n0, 16, 32, 48, \u0026hellip; 240,(4 times) 1, 17, 33, \u0026hellip; 241,(4 times) 15, 31, 47, \u0026hellip; 255(4 times)\nlet\u0026rsquo;s see first read loop:\nread cache order loop 4 times\n0, 16, 32, 48, \u0026hellip; 240,(4 times)\nfirst loop all miss, next 3 loop all hit\nso miss rate is 25%.\nC. sumC\nfor (i = 0; i \u0026lt; N; i+=2) for (j = 0; j \u0026lt; N; j+=2) sum += (a[j][i] + a[j][i+1] + a[j+1][i] + a[j+1][i+1]);  easy to see that read a[j][i+1] and a[j+1][i+1] always hit\nsame like\nfor (i = 0; i \u0026lt; N; i+=2) for (j = 0; j \u0026lt; N; j+=2) sum += (a[j][i] + a[j+1][i]);  same like\nfor (i = 0; i \u0026lt; N; i+=2) for (j = 0; j \u0026lt; N; j++) sum += a[j][i];  total read count = 64*64\nbecause of i+=2,\nread cache order only loop 2 times\n0, 16, 32, 48, \u0026hellip; 240,(2 times)\nso miss rate is 50%\ntotol read miss count = 64/2 * 64 * 50% = 64*64/4\nso miss rate is still 25%.\nN = 60 A. sumA\nsum += a[i][j];  read memory by step 1\nmiss rate 25%\nB. sumB\nfor (i = 0; i \u0026lt; N; i++) for (j = 0; j \u0026lt; N; j++) sum += a[j][i];  it\u0026rsquo;s interesting.\nlet\u0026rsquo;s see first inner loop a[0][0] -\u0026gt; a[59][0]\nread memory address order:\n0, 604, 6042, \u0026hellip;. 604*59\nread cache order:\n0, 15, 30, \u0026hellip;., 225, (17 numbers) 255, 14, 29, \u0026hellip;.., 224, (17 numbers) 254, 13, 28, \u0026hellip;.., 223, (17 numbers) 253, 12, 27, 42, 57, 72, 87, 102, 117 (9 numbers)\nall read miss and store into different blocks\nnext 3 loops: a[0][1] -\u0026gt; a[59][1], a[0][2] -\u0026gt; a[59][2], a[0][3] -\u0026gt; a[59][3]\nall hit\nalthrough N is smaller and not power of 2, miss rate is still 25%\nC. sumC\nsame as miss rate when N = 64\n25%\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.38/","title":"6.38","tags":[],"description":"","content":"A.\n4 * 16 * 16\nB.\nsizeof(point_color) == 16, B = 32\nsquare[i][j].c = 0  miss, cache 2 point_color, then\nsquare[i][j].m = 0 square[i][j].y = 0 square[i][j].k = 0 square[i][j+1].c = 0 square[i][j+1].m = 0 square[i][j+1].y = 0 square[i][j+1].k = 0  all hit\nso miss count is 4 * 16 * 16 * 1/8\nC.\n1/8\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.39/","title":"6.39","tags":[],"description":"","content":"A.\n4 * 16 * 16\nB.\nsizeof(point_color) == 16, B = 32\nsquare[j][i].c = 0  miss, cache 2 point_color, then\nsquare[j][i].m = 0 square[j][i].y = 0 square[j][i].k = 0  all hit.\nnext loop\nsquare[j+1][i] - square[j][i] == 16*16 == 256  square[j+1][i] miss, cache block not conflict with square[j][i]\nsquare[j+8][i] - square[j][i] == 16*16*8 == 2048  square[j+8][i] miss, cache block overwrite square[j][i] block. so when we reach square[j][i+1], still miss.\nso miss count is 4 * 16 * 16 * 1/4\nC.\n1/4\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.40/","title":"6.40","tags":[],"description":"","content":"A.\n4 * 16 * 16\nB.\nfirst loop, same like 6.38, but\nwrite count is 16*16, miss rate is 1/2.\nsecond loop, same like 6.39, but\nwrite count is 16163, miss rate is 1/6.\nmiss count is\n16161/2 + 16163*1/6\nC.\n1/4\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.41/","title":"6.41","tags":[],"description":"","content":"every loop\nbuffer[i][j].r = 0;  always miss, then cache one piexl, so\nbuffer[i][j].g = 0; buffer[i][j].b = 0; buffer[i][j].a = 0;  all hit\nmiss rate is 1/4\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.42/","title":"6.42","tags":[],"description":"","content":"same like\nfor (i = 0; i \u0026lt; 640; i++) for (j = 0; j \u0026lt; 480; j++) buffer[i][j].r = 0; buffer[i][j].g = 0; buffer[i][j].b = 0; buffer[i][j].a = 0; C = 64KB, B = 4B, sizeof(piexl) = 4\nbuffer[i][j].r = 0;  miss, cache one piexl, so\nbuffer[i][j].g = 0; buffer[i][j].b = 0; buffer[i][j].a = 0;  all hit\nmiss rate is 1/4\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.43/","title":"6.43","tags":[],"description":"","content":"same like\nfor (i = 0; i \u0026lt; 640; i++) for (j = 0; j \u0026lt; 480; j++) (int*)\u0026amp;buffer[i][j] = 0; every loop,\n(int*)\u0026amp;buffer[i][j] = 0;  always miss\nmiss rate 100%\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.44/","title":"6.44","tags":[],"description":"","content":"download mountain program from here\nI\u0026rsquo;ve download it into chapter6/code dir\nrun\n(cd ./site/content/chapter6/code/mountain; ./mountain)  see result\nClock frequency is approx. 2500.0 MHz Memory mountain (MB/sec) s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 128m 12824 7552 5119 3776 2981 2452 2080 1799 1663 1563 1483 1410 1372 1334 1304 64m 12880 7575 5121 3790 2976 2456 2079 1797 1663 1563 1489 1415 1366 1333 1302 32m 12849 7635 5137 3785 2996 2456 2075 1795 1671 1570 1486 1419 1372 1321 1299 16m 12906 7656 5174 3826 3000 2504 2090 1808 1700 1579 1506 1442 1397 1373 1357 8m 13045 7832 5321 4072 3121 2577 2194 1885 1787 1706 1663 1633 1622 1621 1703 4m 13303 8352 5602 4210 3326 2765 2352 2033 1931 1859 1824 1812 1817 1906 2076 2m 16265 11003 9150 7368 6024 5014 4310 3816 3795 3761 3848 3877 3909 3946 4044 1024k 16708 11597 10180 8150 6605 5544 4772 4169 4109 4150 4136 4127 4113 4127 4119 512k 16674 11613 10179 8160 6595 5543 4787 4182 4245 4242 4300 4360 4416 4508 4668 256k 16929 12872 11826 10661 8538 7360 6383 5724 6516 6951 7181 7297 7041 7634 7768 128k 16992 15381 14141 13145 12497 11444 10028 9734 9642 9638 9671 9696 9606 9438 9117 64k 17109 15238 14163 13563 12263 11302 9736 9412 9175 9162 9239 9200 9267 9229 12245 32k 18060 17655 17503 16954 16785 16489 16718 14382 16135 16512 16471 15799 14318 16250 15337 16k 17809 17534 17326 16516 16783 16406 16250 13333 14043 15280 13890 12546 13347 12394 17062  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.45/","title":"6.45","tags":[],"description":"","content":"assume matrix size N = 4, cache block size B = 8Byte, sizeof(int) = 4\nmatrix size 4*4 +--+--+--+--+ |0 |1 |2 |3 | +--+--+--+--+ |4 |5 |6 |7 | +--+--+--+--+ |8 |9 |10|11| +--+--+--+--+ |12|13|14|15| +--+--+--+--+  function transponse\nvoid transpose(int* dst, int* src, int N) { int i, j; for (i = 0; i \u0026lt;= N-1; i++) for (j = 0; j \u0026lt;= N-1; j++) dst[j*N+i] = src[i*N+j]; } every cache block can store 2 int numbers\ntraverse src by step 1, order:\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\norder 0: cache miss, load src[0],src[1] order 1: cache hit because of order 0 order 2: cache miss, load src[2],src[3] \u0026hellip;. order 15: cache hit\nif B is greater, hit rate will be greater too.\ntraverse dst by step 4, order:\n0 4 8 12 1 5 9 13 2 6 10 14 3 7 11 15\nelement 0: miss, load dst[0],dst[1] element 4: miss, load dst[4],dst[5] element 8: miss, load dst[8],dst[9] element 12: miss, load dst[12],dst[13] element 1: interesting, order 0 has loaded dst[1] into cache, hit. but in many cases, element 4/8/12 may use the same cache block with element 0. so miss is also possible. \u0026hellip;. element 15: hit / miss\nlet\u0026rsquo;s assume worest case: all element miss cache\nif we split matrix by 2*2\nsplit matrix by size 2*2 block +--+--+--+--+ | | | + 0 + 1 + | | | +--+--+--+--+ | | | + 2 + 3 + | | | +--+--+--+--+  transpose block 0 itself\ntranspose block 1 with 2\ntranspose block 3 itself\ncode\nfor (i = 0; i \u0026lt;= N-2; i+=2) for (j = 0; j \u0026lt;= N-2; j+=2) { dst[j*N+i] = src[i*N+j]; dst[j*N+i+1] = src[(i+1)*N+j]; dst[(j+1)*N+i] = src[i*N+j+1]; dst[(j+1)*N+i+1] = src[(i+1)*N+j+1]; } when i = 0, j = 0, transpose block 0 itself\n+--+--+ +--+--+ |0 |1 | |0 |4 | +--+--+ =\u0026gt; +--+--+ |4 |5 | |1 |5 | +--+--+ +--+--+ dst[0] = src[0]; dst[1] = src[4]; dst[4] = src[1]; dst[5] = src[5];  if element 0 is miss, element 1 must hit; if element 4 is miss, element 5 must hit;\n50% is the highest hit rate in such low cache block size.\nif B is greater and cache size C is larger, we can split matrix into 44, 88 or more larger. theoretically we will archive the highest hit rate.\nfinally code:\n/* * transpose.c */ #include \u0026lt;assert.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; // a large prime number #define MATRIX_N 9973 #define MEM_SIZE (sizeof(int) * MATRIX_N * MATRIX_N) #define LOOP 1000 #define BLOCK 16  void randomize(void *mem, size_t size) { int rnd = open(\u0026#34;/dev/urandom\u0026#34;, O_RDONLY); read(rnd, mem, size); close(rnd); } void transpose(int *dst, int *src, int N) { int i, j; for (i = 0; i \u0026lt;= N - 1; i++) for (j = 0; j \u0026lt;= N - 1; j++) dst[j * N + i] = src[i * N + j]; } void effective_transpose(int *dst, int *src, int N) { int i, j, a, b; for (i = 0; i \u0026lt;= N - BLOCK; i += BLOCK) for (j = 0; j \u0026lt;= N - BLOCK; j += BLOCK) for (a = i; a \u0026lt; i + BLOCK; a++) for (b = j; b \u0026lt; j + BLOCK; b++) dst[b * N + a] = src[a * N + b]; int offset = i; for (i = offset; i \u0026lt;= N - 1; i++) for (j = 0; j \u0026lt; offset; j += BLOCK) for (b = j; b \u0026lt; j + BLOCK; b++) dst[b * N + i] = src[i * N + b]; for (i = 0; i \u0026lt;= N - 1; i++) for (j = offset; j \u0026lt;= N - 1; j++) dst[j * N + i] = src[i * N + j]; } void test(void) { int *d = (int *)malloc(MEM_SIZE); int *s = (int *)malloc(MEM_SIZE); randomize((void *)s, MEM_SIZE); transpose(d, s, MATRIX_N); for (int i = 0; i \u0026lt; MATRIX_N; i++) for (int j = 0; j \u0026lt; MATRIX_N; j++) assert(s[i * MATRIX_N + j] == d[j * MATRIX_N + i]); memset(d, 0, MEM_SIZE); effective_transpose(d, s, MATRIX_N); for (int i = 0; i \u0026lt; MATRIX_N; i++) for (int j = 0; j \u0026lt; MATRIX_N; j++) assert(s[i * MATRIX_N + j] == d[j * MATRIX_N + i]); free((void *)d); free((void *)s); } void prof(void) { int *d = (int *)malloc(MEM_SIZE); int *s = (int *)malloc(MEM_SIZE); for (int c = 0; c \u0026lt; LOOP; c++) transpose(d, s, MATRIX_N); free((void *)d); free((void *)s); } void prof_effect(void) { int *d = (int *)malloc(MEM_SIZE); int *s = (int *)malloc(MEM_SIZE); for (int c = 0; c \u0026lt; LOOP; c++) effective_transpose(d, s, MATRIX_N); free((void *)d); free((void *)s); } int main(int argc, char *argv[]) { test(); /* prof(); */ /* prof_effect(); */ return 0; }  in code, matrix size 1024*1024, loop 1000 times to measure program run time.\nchange BLOCK from 2 to 16, record time statistics\norigin function run time: 16.46s\n   BLOCK time(s)     2 9.99   3 7.16   4 5.6   5 5.66   6 5.34   7 5.39   8 5.38   9 5.48   10 6.21   11 7.9   12 10.17   13 11.14   14 11.88   15 12.11   16 11.85    tip: look up cpu cache info\n$ cat /sys/devices/system/cpu/cpu0/cache/* "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.46/","title":"6.46","tags":[],"description":"","content":"same like 6.45, pay attention to brilliant comment :)\n/* * convert.c */ #include \u0026lt;assert.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;time.h\u0026gt; // a large prime number #define MATRIX_N 9973 #define MEM_SIZE (sizeof(int) * MATRIX_N * MATRIX_N) #define LOOP 1000 #define BLOCK 16  void randomize(int *arr, int N) { srand(time(0)); int i, j; for (i = 0; i \u0026lt;= N - 1; i++) for (j = 0; j \u0026lt;= N - 1; j++) arr[i * N + j] = rand() % 2; } void convert(int *src, int N) { int i, j; for (i = 0; i \u0026lt;= N - 1; i++) for (j = 0; j \u0026lt;= N - 1; j++) src[j * N + i] = src[i * N + j] || src[j * N + i]; } void effective_convert(int *src, int N) { int i, j, a, b, tmp; for (i = 0; i \u0026lt;= N - BLOCK; i += BLOCK) /* not j = 0 here */ for (j = i; j \u0026lt;= N - BLOCK; j += BLOCK) for (a = i; a \u0026lt; i + BLOCK; a++) for (b = j; b \u0026lt; j + BLOCK; b++) { /* brilliant! store two value in one loop */ tmp = src[b * N + a] || src[a * N + b]; src[b * N + a] = tmp; src[a * N + b] = tmp; } int offset = i; for (i = offset; i \u0026lt;= N - 1; i++) for (j = 0; j \u0026lt; offset; j += BLOCK) for (b = j; b \u0026lt; j + BLOCK; b++) { tmp = src[b * N + i] || src[i * N + b]; src[b * N + i] = tmp; src[i * N + b] = tmp; } for (i = offset; i \u0026lt;= N - 1; i++) for (j = i; j \u0026lt;= N - 1; j++) { tmp = src[j * N + i] || src[i * N + j]; src[j * N + i] = tmp; src[i * N + j] = tmp; } } void test(void) { int *s = (int *)malloc(MEM_SIZE); int *e = (int *)malloc(MEM_SIZE); randomize(s, MATRIX_N); memcpy(e, s, MEM_SIZE); convert(s, MATRIX_N); effective_convert(e, MATRIX_N); for (int i = 0; i \u0026lt; MATRIX_N; i++) for (int j = 0; j \u0026lt; MATRIX_N; j++) assert(s[i * MATRIX_N + j] == e[i * MATRIX_N + j]); free((void *)s); free((void *)e); } void prof(void) { int *s = (int *)malloc(MEM_SIZE); for (int c = 0; c \u0026lt; LOOP; c++) convert(s, MATRIX_N); free((void *)s); } void prof_effect(void) { int *e = (int *)malloc(MEM_SIZE); for (int c = 0; c \u0026lt; LOOP; c++) effective_convert(e, MATRIX_N); free((void *)e); } int main(int argc, char *argv[]) { test(); /* prof(); */ /* prof_effect(); */ return 0; }  measure time statistics:\norigin function run time: 30.28s\n   BLOCK time(s)     1 14.26   2 12.01   3 7.43   4 6.20   5 6.08   6 5.86   7 5.70   8 5.67   9 6.30   10 6.39   11 6.21   12 6.18   13 5.9   14 6.3   15 5.88   16 5.92    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.10/","title":"8.10","tags":[],"description":"","content":"A. call once, return twice\nfork\nB. call once, never return\nlongjmp, execve\nC. call once, return 1 or more times\nsetjmp\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.11/","title":"8.11","tags":[],"description":"","content":"4 lines\n c +-------+ | \u0026quot;hello\u0026quot; | c | p +-------+-------+ | fork \u0026quot;hello\u0026quot; | | c | +-------+ | | \u0026quot;hello\u0026quot; | | | p | p +------+-------+-------+ main fork fork \u0026quot;hello\u0026quot;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.12/","title":"8.12","tags":[],"description":"","content":"8 lines\n c +-------+---------+ | \u0026quot;hello\u0026quot; \u0026quot;hello\u0026quot; | c | p +-------+-------+---------+ | fork \u0026quot;hello\u0026quot; \u0026quot;hello\u0026quot; | | c | +-------+---------+ | | \u0026quot;hello\u0026quot; \u0026quot;hello\u0026quot; | | | p | p +------+-------+-------+---------+ main fork fork \u0026quot;hello\u0026quot; \u0026quot;hello\u0026quot;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.13/","title":"8.13","tags":[],"description":"","content":"x=4 x=3 x=2  pay attention, parent process and child process don\u0026rsquo;t share global x, they have own private x.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.14/","title":"8.14","tags":[],"description":"","content":"3 lines\n c +-------+ | \u0026quot;hello\u0026quot; | c | p +-------+-------+ | fork \u0026quot;hello\u0026quot; | | p +------+-------+-------+ main fork return \u0026quot;hello\u0026quot;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.15/","title":"8.15","tags":[],"description":"","content":"5 lines\n c +-------+---------+ | \u0026quot;hello\u0026quot; \u0026quot;hello\u0026quot; | c | p +-------+-------+---------+ | fork \u0026quot;hello\u0026quot; \u0026quot;hello\u0026quot; | | | p +------+-------+-------+ main fork return \u0026quot;hello\u0026quot;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.16/","title":"8.16","tags":[],"description":"","content":"counter = 2  child process has its own counter.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.17/","title":"8.17","tags":[],"description":"","content":"hello 0 1 Bye 2 Bye hello 1 0 Bye 2 Bye hello 1 Bye 0 2 Bye  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.18/","title":"8.18","tags":[],"description":"","content":" c +-------+---------+ | \u0026quot;0\u0026quot; exit \u0026quot;2\u0026quot; | c | p +-------+-------+---------+ | fork \u0026quot;1\u0026quot; exit \u0026quot;2\u0026quot; | (atexit) | c | +-------+---------+ | | \u0026quot;0\u0026quot; exit | | | p | p +------+-------+-------+---------+ main fork fork \u0026quot;1\u0026quot; exit  2 must be behind 0/1\nB \u0026amp; D is impossible.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.19/","title":"8.19","tags":[],"description":"","content":"2^n\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.20/","title":"8.20","tags":[],"description":"","content":"/* * 8.20.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; int main(int argc, char* argv[], char* env[]) { if (execve(\u0026#34;/bin/ls\u0026#34;, argv, env) == -1) { fprintf(stderr, \u0026#34;execve error: %s\\n\u0026#34;, strerror(errno)); exit(1); } }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.21/","title":"8.21","tags":[],"description":"","content":"abc  or\nbac  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.22/","title":"8.22","tags":[],"description":"","content":"/* * mysystem.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; int mysystem(char* command) { pid_t pid; int status; if ((pid = Fork()) == 0) { /* child process */ char* argv[4] = { \u0026#34;\u0026#34;, \u0026#34;-c\u0026#34;, command, NULL }; execve(\u0026#34;/bin/sh\u0026#34;, argv, environ); } /* print child pid so we can kill it */ printf(\u0026#34;child pid: %d\\n\u0026#34;, pid); if (Waitpid(pid, \u0026amp;status, 0) \u0026gt; 0) { /* exit normally */ if (WIFEXITED(status)) return WEXITSTATUS(status); /* exit by signal */ if (WIFSIGNALED(status)) return WTERMSIG(status); } } int main(int argc, char* argv[]) { int code; code = mysystem(\u0026#34;./exit-code\u0026#34;); printf(\u0026#34;normally exit, code: %d\\n\u0026#34;, code); fflush(stdout); code = mysystem(\u0026#34;./wait-sig\u0026#34;); printf(\u0026#34;exit caused by signal, code: %d\\n\u0026#34;, code); fflush(stdout); return 0; }  when running ./mysystem, it runs ./exit-code\n/* * exit-code.c */ #include \u0026#34;csapp.h\u0026#34; int main(int argc, char* argv[]) { exit(10); }  should output\nnormally exit, code 10  and runs ./wait-sig, stuck here\n/* * wait-sig.c */ #include \u0026#34;csapp.h\u0026#34; int main(int argc, char* argv[]) { while (1); }  fall into dead loop. open another terminal, type\nkill -\u0026lt;n\u0026gt; \u0026lt;wait-sig's pid\u0026gt;  ./mysystem will return and output\nexit caused by signal, code \u0026lt;n\u0026gt;  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.23/","title":"8.23","tags":[],"description":"","content":" SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR2 | | | | | being handled Pending Canceld Canceld Canceld need 1 sec  there\u0026rsquo;s only one pending signal all the time. other same type signals will be canceled.\nif you modify code\nremove sleep\n/* sleep(1); */  or\nsend more signals\nfor (i = 0; i \u0026lt; 500000; i++)  you will get different counter output.\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.24/","title":"8.24","tags":[],"description":"","content":"/* $begin waitpid1 */ #include \u0026#34;csapp.h\u0026#34;#define N 2 #define LEN 100  int main() { int status, i; pid_t pid; /* Parent creates N children */ for (i = 0; i \u0026lt; N; i++) if ((pid = Fork()) == 0) { /* access address 0, cause fault */ char* cptr = NULL; *cptr = \u0026#39;d\u0026#39;; } /* Parent reaps N children in no particular order */ while ((pid = waitpid(-1, \u0026amp;status, 0)) \u0026gt; 0) { if (WIFEXITED(status)) printf(\u0026#34;child %d terminated normally with exit status=%d\\n\u0026#34;, pid, WEXITSTATUS(status)); else if (WIFSIGNALED(status)) { /* print signal that cause process exit */ char buf[LEN]; sprintf(buf, \u0026#34;child %d terminated by signal %d\u0026#34;, pid, WTERMSIG(status)); psignal(WTERMSIG(status), buf); } else printf(\u0026#34;child %d terminated abnormally\\n\u0026#34;, pid); } /* The only normal termination is if there are no more children */ if (errno != ECHILD) unix_error(\u0026#34;waitpid error\u0026#34;); exit(0); } /* $end waitpid1 */  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.25/","title":"8.25","tags":[],"description":"","content":"/* * 8.25.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; sigjmp_buf buf; void handler(int sig) { /* jump */ siglongjmp(buf, 1); } char* tfgets(char* s, int size, FILE* stream) { char* result; if (!sigsetjmp(buf, 1)) { alarm(5); if (signal(SIGALRM, handler) == SIG_ERR) unix_error(\u0026#34;set alarm handler error\u0026#34;); return fgets(s, size, stream); } else { /* run out of time */ return NULL; } } #define LEN 100  int main(int argc, char* argv[]) { char buf[LEN]; char* input = tfgets(buf, LEN, stdin); if (input == NULL) { printf(\u0026#34;nothing input: NULL\\n\u0026#34;); } else { printf(\u0026#34;%s\u0026#34;, input); } return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.26/","title":"8.26","tags":[],"description":"","content":"learn\n origin shell code in pic 8-23, pic 8-24, pic 8-25 how to use waitpid in pic 8-18 how to wait child process in pic 8-42  and write a job management module\ncompose them and the little shell is born.\nadd bg fg jobs command to origin shell program\n#include \u0026lt;assert.h\u0026gt;#include \u0026#34;../csapp.h\u0026#34;#include \u0026#34;shell.h\u0026#34;#include \u0026#34;job.h\u0026#34; void eval(char *cmdline) { char *argv[MAXARGS]; /* Argument list execve() */ char buf[MAXLINE]; /* Holds modified command line */ int bg; /* Should the job run in bg or fg? */ pid_t pid; /* Process id */ strcpy(buf, cmdline); bg = parse_line(buf, argv); if (argv[0] == NULL) return; /* Ignore empty lines */ if (!builtin_command(argv)) { sigset_t mask_one, prev_one; Sigemptyset(\u0026amp;mask_one); Sigaddset(\u0026amp;mask_one, SIGCHLD); /* block signal child */ Sigprocmask(SIG_BLOCK, \u0026amp;mask_one, \u0026amp;prev_one); if ((pid = Fork()) == 0) { /* unblock in child process */ Sigprocmask(SIG_SETMASK, \u0026amp;prev_one, NULL); /* set gid same like pid */ Setpgid(0, 0); if (execve(argv[0], argv, environ) \u0026lt; 0) { printf(\u0026#34;%s: Command not found.\\n\u0026#34;, argv[0]); exit(0); } } sigset_t mask_all, prev_all; Sigfillset(\u0026amp;mask_all); // save job info  Sigprocmask(SIG_BLOCK, \u0026amp;mask_all, \u0026amp;prev_all); Jid new_jid = new_job(pid, cmdline, !bg); Sigprocmask(SIG_SETMASK, \u0026amp;prev_all, NULL); if (!bg) { set_fg_pid(pid); while(get_fg_pid()) sigsuspend(\u0026amp;prev_one); } else printf(\u0026#34;[%d] %d %s \\t%s\\n\u0026#34;, new_jid, pid, \u0026#34;Running\u0026#34;, cmdline); /* unblock child signal */ Sigprocmask(SIG_SETMASK, \u0026amp;prev_one, NULL); } return; } /* * If first arg is a builtin command, run it and return true; * else return false. */ int builtin_command(char **argv) { if (!strcmp(argv[0], \u0026#34;quit\u0026#34;)) /* quit command */ exit(0); if (!strcmp(argv[0], \u0026#34;\u0026amp;\u0026#34;)) /* Ignore singleton \u0026amp; */ return 1; if (!strcmp(argv[0], \u0026#34;jobs\u0026#34;)) { print_jobs(); return 1; } // \u0026gt; fg  if (!strcmp(argv[0], \u0026#34;fg\u0026#34;)) { int id; // right format: fg %ddd or fg ddd  if ((id = parse_id(argv[1])) != -1 \u0026amp;\u0026amp; argv[2] == NULL) { sigset_t mask_one, prev_one; Sigemptyset(\u0026amp;mask_one); Sigaddset(\u0026amp;mask_one, SIGCHLD); Sigprocmask(SIG_BLOCK, \u0026amp;mask_one, \u0026amp;prev_one); pid_t pid = id; // if param is jid  if (argv[1][0] == \u0026#39;%\u0026#39;) { JobPtr jp = find_job_by_jid(id); pid = jp-\u0026gt;pid; } Kill(pid, SIGCONT); set_fg_pid(pid); while(get_fg_pid()) sigsuspend(\u0026amp;prev_one); Sigprocmask(SIG_SETMASK, \u0026amp;prev_one, NULL); } else { printf(\u0026#34;format error, e.g. fg %%12 || fg 1498\\n\u0026#34;); } return 1; } // \u0026gt; bg  if (!strcmp(argv[0], \u0026#34;bg\u0026#34;)) { int id; // right format: bg %ddd or bg ddd  if ((id = parse_id(argv[1])) != -1 \u0026amp;\u0026amp; argv[2] == NULL) { pid_t pid = id; // jid param  if (argv[1][0] == \u0026#39;%\u0026#39;) { JobPtr jp = find_job_by_jid(id); pid = jp-\u0026gt;pid; } Kill(pid, SIGCONT); } else { printf(\u0026#34;format error, e.g. bg %%12 or bg 1498\\n\u0026#34;); } return 1; } return 0; /* Not a builtin command */ } /* parse_line - Parse the command line and build the argv array */ int parse_line(char *buf, char **argv) { char *delim; /* Points to first space delimiter */ int argc; /* Number of args */ int bg; /* Background job? */ buf[strlen(buf)-1] = \u0026#39; \u0026#39;; /* Replace trailing \u0026#39;\\n\u0026#39; with space */ while (*buf \u0026amp;\u0026amp; (*buf == \u0026#39; \u0026#39;)) /* Ignore leading spaces */ buf++; /* Build the argv list */ argc = 0; while ((delim = strchr(buf, \u0026#39; \u0026#39;))) { argv[argc++] = buf; *delim = \u0026#39;\\0\u0026#39;; buf = delim + 1; while (*buf \u0026amp;\u0026amp; (*buf == \u0026#39; \u0026#39;)) /* Ignore spaces */ buf++; } argv[argc] = NULL; if (argc == 0) /* Ignore blank line */ return 1; /* Should the job run in the background? */ if ((bg = (*argv[argc-1] == \u0026#39;\u0026amp;\u0026#39;)) != 0) argv[--argc] = NULL; return bg; } static int is_number_str(char* s) { int len = strlen(s); for (int i = 0; i \u0026lt; len; i++) if (!isdigit(s[i])) return 0; return 1; } int parse_id(char* s) { int error = -1; if (s == NULL) return error; /* format: %ddddd */ if (s[0] == \u0026#39;%\u0026#39;) { if (!is_number_str(s+1)) return error; return atoi(s+1); } /* format: dddddd */ if (is_number_str(s)) return atoi(s); /* not right */ return error; } void test_shell() { // parse id  assert(-1 == parse_id(\u0026#34;ns\u0026#34;)); assert(-1 == parse_id(\u0026#34;%%\u0026#34;)); assert(0 == parse_id(\u0026#34;%0\u0026#34;)); assert(0 == parse_id(\u0026#34;0\u0026#34;)); assert(98 == parse_id(\u0026#34;%98\u0026#34;)); assert(98 == parse_id(\u0026#34;98\u0026#34;)); }  job management module. signal handlers are the key part\n/* * job.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;job.h\u0026#34;#include \u0026#34;../csapp.h\u0026#34; static volatile sig_atomic_t fg_pid; static Job jobs[MAXJOBS]; int is_fg_pid(pid_t pid) { return fg_pid == pid; } pid_t get_fg_pid() { return fg_pid; } void set_fg_pid(pid_t pid) { fg_pid = pid; } /* SIGCONT signal */ void sigchild_handler(int sig) { int old_errno = errno; int status; pid_t pid; sigset_t mask_all, prev_all; Sigfillset(\u0026amp;mask_all); /* exit or be stopped or continue */ while ((pid = waitpid(-1, \u0026amp;status, WNOHANG|WUNTRACED|WCONTINUED)) \u0026gt; 0) { /* exit normally */ if (WIFEXITED(status) || WIFSIGNALED(status)) { if (is_fg_pid(pid)) { set_fg_pid(0); } else { Sio_puts(\u0026#34;pid \u0026#34;); Sio_putl(pid); Sio_puts(\u0026#34; terminates\\n\u0026#34;); } Sigprocmask(SIG_BLOCK, \u0026amp;mask_all, \u0026amp;prev_all); del_job_by_pid(pid); Sigprocmask(SIG_SETMASK, \u0026amp;prev_all, NULL); } /* be stopped */ if (WIFSTOPPED(status)) { if (is_fg_pid(pid)) { set_fg_pid(0); } // set pid status stopped  Sigprocmask(SIG_BLOCK, \u0026amp;mask_all, \u0026amp;prev_all); JobPtr jp = find_job_by_pid(pid); set_job_status(jp, Stopped); Sigprocmask(SIG_SETMASK, \u0026amp;prev_all, NULL); Sio_puts(\u0026#34;pid \u0026#34;); Sio_putl(pid); Sio_puts(\u0026#34; be stopped\\n\u0026#34;); } /* continue */ if(WIFCONTINUED(status)) { set_fg_pid(pid); // set pid status running  Sigprocmask(SIG_BLOCK, \u0026amp;mask_all, \u0026amp;prev_all); JobPtr jp = find_job_by_pid(pid); set_job_status(jp, Running); Sigprocmask(SIG_SETMASK, \u0026amp;prev_all, NULL); Sio_puts(\u0026#34;pid \u0026#34;); Sio_putl(pid); Sio_puts(\u0026#34; continue\\n\u0026#34;); } } errno = old_errno; } void sigint_handler(int sig) { /* when fg_pid == 0, stop shell itself, it\u0026#39;ll be a dead loop */ if (is_fg_pid(0)) { Signal(SIGINT, SIG_DFL); Kill(getpid(), SIGINT); } else { Kill(get_fg_pid(), SIGINT); } } void sigstop_handler(int sig) { /* same like int handler */ if (is_fg_pid(0)) { Signal(SIGTSTP, SIG_DFL); Kill(getpid(), SIGTSTP); } else { Kill(get_fg_pid(), SIGTSTP); } } JobPtr find_job_by_jid(Jid jid) { return \u0026amp;(jobs[jid]); } JobPtr find_job_by_pid(pid_t pid) { for (int i = 0; i \u0026lt; MAXJOBS; i++) { Job j = jobs[i]; if (j.using \u0026amp;\u0026amp; j.pid == pid) { return \u0026amp;(jobs[i]); } } /* no such job */ return NULL; } void set_job_status(JobPtr jp, enum JobStatus status) { if (jp) jp-\u0026gt;status = status; } // seek a spare place for new job static int find_spare_jid() { Jid jid = -1; for (int i = 0; i \u0026lt; MAXJOBS; i++) { if (jobs[i].using == 0) { jid = i; break; } } return jid; } int new_job(pid_t pid, char* cmdline, int fg) { // find a jid  Jid jid = find_spare_jid(); if (jid == -1) unix_error(\u0026#34;no more jid to use\u0026#34;); // save process info  jobs[jid].jid = jid; jobs[jid].pid = pid; jobs[jid].status = Running; strcpy(jobs[jid].cmdline, cmdline); jobs[jid].using = 1; return jid; } void del_job_by_pid(pid_t pid) { // search job whose pid is pid  for (int i = 0; i \u0026lt; MAXJOBS; i++) { if (jobs[i].using \u0026amp;\u0026amp; jobs[i].pid == pid) { // delete job  jobs[i].using = 0; } } } void print_jobs() { for (int i = 0; i \u0026lt; MAXJOBS; i++) { Job j = jobs[i]; if (j.using) { printf(\u0026#34;[%d] %d %s \\t%s\\n\u0026#34;, j.jid, j.pid, j.status == Running ? \u0026#34;Running\u0026#34; : \u0026#34;Stopped\u0026#34;, j.cmdline); } } } void init_jobs() { memset(jobs, 0, sizeof(jobs)); } void test_job() { }  test it\n(cd chapter8/code/shell; make \u0026amp;\u0026amp; ./shell)  ps: ./loop is a dead loop program, ./sleep sleeps 5 secs and exit.\n  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.11/","title":"9.11","tags":[],"description":"","content":"VA: 0x027c\nA.\n 13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 0| 0| 0| 1| 0| 0| 1| 1| 1| 1| 1| 0| 0| +--|--|--|--|--|--|--|--|--|--|--|--|--|--+  B.\n   param value     VPN 0x09   TLBI 0x01   TLBT 0x02   hit? No   page falut? No   PPN 0x17    C.\n 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 1| 0| 1| 1| 1| 1| 1| 1| 1| 0| 0| +--|--|--|--|--|--|--|--|--|--|--|--+  D.\n   param value     CO 0x00   CI 0x0F   CT 0x17   hit? No   value \u0026mdash;\u0026ndash;    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.12/","title":"9.12","tags":[],"description":"","content":"VA: 0x03a9\nA.\n 13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 0| 0| 0| 1| 1| 1| 0| 1| 0| 1| 0| 0| 1| +--|--|--|--|--|--|--|--|--|--|--|--|--|--+  B.\n   param value     VPN 0x0E   TLBI 0x02   TLBT 0x03   hit? No   page falut? No   PPN 0x11    C.\n 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0| 1| +--|--|--|--|--|--|--|--|--|--|--|--+  D.\n   param value     CO 0x01   CI 0x0A   CT 0x11   hit? No   value \u0026mdash;\u0026ndash;    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.13/","title":"9.13","tags":[],"description":"","content":"VA: 0x0040\nA.\n 13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 0| 0| 0| 0| 0| 0| 1| 0| 0| 0| 0| 0| 0| +--|--|--|--|--|--|--|--|--|--|--|--|--|--+  B.\n   param value     VPN 0x01   TLBI 0x01   TLBT 0x00   hit? No   page falut? Yes    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.14/","title":"9.14","tags":[],"description":"","content":"/* * 9.14.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026#34;vm/csapp.h\u0026#34; void test(char* filename, char* content) { int fd; char buf[20]; fd = Open(filename, O_RDONLY, 0); Read(fd, buf, strlen(content)); assert( !strncmp(buf, content, strlen(content)) ); } int touch(char* filename, char* content) { int fd; umask(DEF_UMASK); fd = Open(filename, O_WRONLY|O_CREAT|O_TRUNC, DEF_MODE); Write(fd, content, strlen(content)); Close(fd); } int main(int argc, char* argv[]) { touch(\u0026#34;hello.txt\u0026#34;, \u0026#34;Hello, world!\u0026#34;); test(\u0026#34;hello.txt\u0026#34;, \u0026#34;Hello, world!\u0026#34;); struct stat stat; int fd; char* bufp; size_t size; fd = Open(\u0026#34;hello.txt\u0026#34;, O_RDWR, 0); fstat(fd, \u0026amp;stat); size = stat.st_size; bufp = Mmap(NULL, size, PROT_WRITE, MAP_SHARED, fd, 0); *bufp = \u0026#39;J\u0026#39;; Munmap(bufp, size); test(\u0026#34;hello.txt\u0026#34;, \u0026#34;Jello, world!\u0026#34;); return 0; }  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.15/","title":"9.15","tags":[],"description":"","content":"   malloc size header     malloc(3) 8 0x9   malloc(11) 16 0x11   malloc(20) 24 0x19   malloc(21) 24 0x19    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.16/","title":"9.16","tags":[],"description":"","content":"   alignment allocated block spare block min block size     word Header \u0026amp; Footer Header \u0026amp; Footer 16   word Header Header \u0026amp; Footer 16   double word Header \u0026amp; Footer Header \u0026amp; Footer 16   double word Header Header \u0026amp; Footer 16    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.17/","title":"9.17","tags":[],"description":"","content":"complete code in ./site/content/chapter9/code/vm/mm.9.17.c\n--- mm.c\t2021-02-25 07:26:33.315926002 +0000 +++ mm.9.17.c\t2021-02-25 07:26:33.315926002 +0000 @@ -41,6 +41,7 @@  /* Global variables */ static char *heap_listp = 0; /* Pointer to first block */ +static char *rover; /* Next fit rover */  /* Function prototypes for internal helper routines */ static void *extend_heap(size_t words); @@ -69,6 +70,7 @@  heap_listp += (2*WSIZE); //line:vm:mm:endinit /* $end mminit */ + rover = heap_listp;  /* $begin mminit */ /* Extend the empty heap with a free block of CHUNKSIZE bytes */ @@ -177,6 +179,10 @@  bp = PREV_BLKP(bp); } /* $end mmfree */ + /* Make sure the rover isn\u0026#39;t pointing into the free block */ + /* that we just coalesced */ + if ((rover \u0026gt; (char *)bp) \u0026amp;\u0026amp; (rover \u0026lt; NEXT_BLKP(bp))) + rover = bp;  /* $begin mmfree */ return bp; } @@ -290,16 +296,20 @@  { /* $end mmfirstfit */ - /* $begin mmfirstfit */ - /* First-fit search */ - void *bp; - - for (bp = heap_listp; GET_SIZE(HDRP(bp)) \u0026gt; 0; bp = NEXT_BLKP(bp)) { - if (!GET_ALLOC(HDRP(bp)) \u0026amp;\u0026amp; (asize \u0026lt;= GET_SIZE(HDRP(bp)))) { - return bp; - } - } - return NULL; /* No fit */ + /* Next fit search */ + char *oldrover = rover; + + /* Search from the rover to the end of list */ + for ( ; GET_SIZE(HDRP(rover)) \u0026gt; 0; rover = NEXT_BLKP(rover)) + if (!GET_ALLOC(HDRP(rover)) \u0026amp;\u0026amp; (asize \u0026lt;= GET_SIZE(HDRP(rover)))) + return rover; + + /* search from start of list to old rover */ + for (rover = heap_listp; rover \u0026lt; oldrover; rover = NEXT_BLKP(rover)) + if (!GET_ALLOC(HDRP(rover)) \u0026amp;\u0026amp; (asize \u0026lt;= GET_SIZE(HDRP(rover)))) + return rover; + + return NULL; /* no fit found */  } /* $end mmfirstfit */  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.18/","title":"9.18","tags":[],"description":"","content":"complete code in ./site/content/chapter9/code/vm/mm.9.18.c\n--- mm.c\t2021-02-25 07:26:33.315926002 +0000 +++ mm.9.18.c\t2021-02-25 07:26:33.315926002 +0000 @@ -20,7 +20,7 @@  #define MAX(x, y) ((x) \u0026gt; (y)? (x) : (y)) /* Pack a size and allocated bit into a word */ -#define PACK(size, alloc) ((size) | (alloc)) //line:vm:mm:pack +#define PACK(size, alloc, prev_alloc) ((size) | (alloc) | (prev_alloc \u0026lt;\u0026lt; 1)) //line:vm:mm:pack  /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) //line:vm:mm:get @@ -29,6 +29,7 @@  /* Read the size and allocated fields from address p */ #define GET_SIZE(p) (GET(p) \u0026amp; ~0x7) //line:vm:mm:getsize #define GET_ALLOC(p) (GET(p) \u0026amp; 0x1) //line:vm:mm:getalloc +#define GET_PREV_ALLOC(p) ((GET(p) \u0026gt;\u0026gt; 1) \u0026amp; 0x1)  /* Given block ptr bp, compute address of its header and footer */ #define HDRP(bp) ((char *)(bp) - WSIZE) //line:vm:mm:hdrp @@ -63,9 +64,9 @@  if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1) //line:vm:mm:begininit return -1; PUT(heap_listp, 0); /* Alignment padding */ - PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); /* Prologue header */ - PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ - PUT(heap_listp + (3*WSIZE), PACK(0, 1)); /* Epilogue header */ + PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1, 1)); /* Prologue header */ + PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1, 1)); /* Prologue footer */ + PUT(heap_listp + (3*WSIZE), PACK(0, 1, 1)); /* Epilogue header */  heap_listp += (2*WSIZE); //line:vm:mm:endinit /* $end mminit */ @@ -98,10 +99,10 @@  return NULL; /* Adjust block size to include overhead and alignment reqs. */ - if (size \u0026lt;= DSIZE) //line:vm:mm:sizeadjust1 - asize = 2*DSIZE; //line:vm:mm:sizeadjust2 + if (size \u0026lt;= WSIZE) + asize = DSIZE;  else - asize = DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE); //line:vm:mm:sizeadjust3 + asize = DSIZE * ((size + (WSIZE) + (DSIZE-1)) / DSIZE); //line:vm:mm:sizeadjust3  /* Search the free list for a fit */ if ((bp = find_fit(asize)) != NULL) { //line:vm:mm:findfitcall @@ -136,8 +137,16 @@  } /* $begin mmfree */ - PUT(HDRP(bp), PACK(size, 0)); - PUT(FTRP(bp), PACK(size, 0)); + PUT(HDRP(bp), PACK(size, 0, GET_PREV_ALLOC(HDRP(bp)))); + PUT(FTRP(bp), PACK(size, 0, GET_PREV_ALLOC(HDRP(bp)))); + + if (GET_ALLOC(HDRP(NEXT_BLKP(bp)))) + PUT(HDRP(NEXT_BLKP(bp)), PACK(GET_SIZE(HDRP(NEXT_BLKP(bp))), 1, 0)); + else { + PUT(HDRP(NEXT_BLKP(bp)), PACK(GET_SIZE(HDRP(NEXT_BLKP(bp))), 0, 0)); + PUT(FTRP(NEXT_BLKP(bp)), PACK(GET_SIZE(HDRP(NEXT_BLKP(bp))), 0, 0)); + } +  coalesce(bp); } @@ -148,7 +157,7 @@  /* $begin mmfree */ static void *coalesce(void *bp) { - size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); + size_t prev_alloc = GET_PREV_ALLOC(HDRP(bp));  size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); @@ -158,22 +167,22 @@  else if (prev_alloc \u0026amp;\u0026amp; !next_alloc) { /* Case 2 */ size += GET_SIZE(HDRP(NEXT_BLKP(bp))); - PUT(HDRP(bp), PACK(size, 0)); - PUT(FTRP(bp), PACK(size,0)); + PUT(HDRP(bp), PACK(size, 0, 1)); + PUT(FTRP(bp), PACK(size, 0, 1));  } else if (!prev_alloc \u0026amp;\u0026amp; next_alloc) { /* Case 3 */ size += GET_SIZE(HDRP(PREV_BLKP(bp))); - PUT(FTRP(bp), PACK(size, 0)); - PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); + PUT(FTRP(bp), PACK(size, 0, 1)); + PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0, 1));  bp = PREV_BLKP(bp); } else { /* Case 4 */ size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp))); - PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); - PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0)); + PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0, 1)); + PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0, 1));  bp = PREV_BLKP(bp); } /* $end mmfree */ @@ -246,9 +255,9 @@  return NULL; //line:vm:mm:endextend /* Initialize free block header/footer and the epilogue header */ - PUT(HDRP(bp), PACK(size, 0)); /* Free block header */ //line:vm:mm:freeblockhdr - PUT(FTRP(bp), PACK(size, 0)); /* Free block footer */ //line:vm:mm:freeblockftr - PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); /* New epilogue header */ //line:vm:mm:newepihdr + PUT(HDRP(bp), PACK(size, 0, GET_PREV_ALLOC(HDRP(bp)))); /* Free block header */ //line:vm:mm:freeblockhdr + PUT(FTRP(bp), PACK(size, 0, GET_PREV_ALLOC(HDRP(bp)))); /* Free block footer */ //line:vm:mm:freeblockftr + PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1, 0)); /* New epilogue header */ //line:vm:mm:newepihdr  /* Coalesce if the previous block was free */ return coalesce(bp); //line:vm:mm:returnblock @@ -267,15 +276,14 @@  size_t csize = GET_SIZE(HDRP(bp)); if ((csize - asize) \u0026gt;= (2*DSIZE)) { - PUT(HDRP(bp), PACK(asize, 1)); - PUT(FTRP(bp), PACK(asize, 1)); + PUT(HDRP(bp), PACK(asize, 1, 1));  bp = NEXT_BLKP(bp); - PUT(HDRP(bp), PACK(csize-asize, 0)); - PUT(FTRP(bp), PACK(csize-asize, 0)); + PUT(HDRP(bp), PACK(csize-asize, 0, 1)); + PUT(FTRP(bp), PACK(csize-asize, 0, 1));  } else { - PUT(HDRP(bp), PACK(csize, 1)); - PUT(FTRP(bp), PACK(csize, 1)); + PUT(HDRP(bp), PACK(csize, 1, 1)); + PUT(HDRP(NEXT_BLKP(bp)), PACK(csize, 1, 1));  } } /* $end mmplace */  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.19/","title":"9.19","tags":[],"description":"","content":"   a: Right. 2^(k+1) block size for (2^k)+1 allocation request\nb: wrong.\nc: wrong. LIFO is also fast.\nd: wrong. almost every strategy has external fragmentation problem.\n  a: wrong. first fit should be fast in this condition\nb: wrong. should be order by block size\nc: wrong. min spare size not max\nd: Right.\n  b\nref 9.10.3\n"},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.20/","title":"9.20","tags":[],"description":"","content":"using malloc lib code from csapp site\n implicit idle list allocated block with header \u0026amp; footer idle block with header \u0026amp; footer no GC first fit strategy  another modification to malloc lib file\nmm.h\n--- ../vm/mm.h\t2021-02-25 07:26:33.315926002 +0000 +++ mm.h\t2021-02-25 07:26:33.315926002 +0000 @@ -5,6 +5,9 @@  extern void mm_free (void *ptr); /* $end mallocinterface */ +#define malloc(size) mm_malloc(size) +#define free(ptr) mm_free(ptr) +  extern void *mm_realloc(void *ptr, size_t size); extern void *mm_calloc (size_t nmemb, size_t size); extern void mm_checkheap(int verbose);  memlib.c\n--- ../vm/memlib.c\t2021-02-25 07:26:33.315926002 +0000 +++ memlib.c\t2021-02-25 07:26:33.315926002 +0000 @@ -15,23 +15,18 @@  #include \u0026#34;csapp.h\u0026#34; #include \u0026#34;memlib.h\u0026#34; -#define MAX_HEAP (20*(1\u0026lt;\u0026lt;20)) /* 20 MB */ - -  /* $begin memlib */ /* Private global variables */ static char *mem_heap; /* Points to first byte of heap */ static char *mem_brk; /* Points to last byte of heap plus 1 */ -static char *mem_max_addr; /* Max legal heap addr plus 1*/  /* * mem_init - Initialize the memory system model */ void mem_init(void) { - mem_heap = (char *)Malloc(MAX_HEAP); + mem_heap = (char *)sbrk(0);  mem_brk = (char *)mem_heap; - mem_max_addr = (char *)(mem_heap + MAX_HEAP);  } /* @@ -43,7 +38,7 @@  { char *old_brk = mem_brk; - if ( (incr \u0026lt; 0) || ((mem_brk + incr) \u0026gt; mem_max_addr)) { + if ( (incr \u0026lt; 0) || ((mem_brk = sbrk(incr)) == (void *)-1)) {  errno = ENOMEM; fprintf(stderr, \u0026#34;ERROR: mem_sbrk failed. Ran out of memory...\\n\u0026#34;); return (void *)-1;  main.c file measure malloc performance\n/* * main.c */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;csapp.h\u0026#34; #ifdef CUS_MALLOC #include \u0026#34;mm.h\u0026#34;#include \u0026#34;memlib.h\u0026#34;#else #include \u0026lt;stdlib.h\u0026gt;#endif  #define LOOP 10000  int main(int argc, char* argv[]) { void* m_start = sbrk(0); size_t malloc_size = 0; int i; for (i = 0; i \u0026lt; LOOP; i+=2) { void* ptr_f = malloc(i); void* ptr = malloc(i+1); free(ptr_f); malloc_size += i+1; } void* m_end = sbrk(0); size_t heap_size = (size_t)(m_end - m_start); printf(\u0026#34;malloc size: %ld, heap_size: %ld\\n\u0026#34;, malloc_size, heap_size); return 0; }  run make to generate both origin main executable file and custom version(using -DCUS_MALLOC)\nCC = gcc CFLAGS = -m64 -pthread -DCUS_MALLOC SRCS = mm.c memlib.c csapp.c all: origin custom diff measure: time ./origin.main time ./custom.main origin: $(CC) -m64 main.c -o origin.main custom: $(CC) $(CFLAGS) $(SRCS) main.c -o custom.main diff: (diff -u ../vm/mm.h mm.h \u0026gt; mm.h.diff; cd .) (diff -u ../vm/memlib.c memlib.c \u0026gt; memlib.c.diff; cd .) test: .PHONY: clean clean: find . -type f -executable -print0 | xargs -0 rm -f --  measurement\n(cd ./site/content/chapter9/code/malloc; make measure) time ./origin.main malloc size: 25000000, heap_size: 28311552 0.00user 0.01system 0:00.01elapsed 100%CPU (0avgtext+0avgdata 19256maxresident)k 0inputs+0outputs (0major+4547minor)pagefaults 0swaps time ./custom.main malloc size: 25000000, heap_size: 31327104 0.58user 0.00system 0:00.58elapsed 99%CPU (0avgtext+0avgdata 30592maxresident)k 0inputs+0outputs (0major+7339minor)pagefaults 0swaps  "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/","title":"CSAPP-3e-Solutions","tags":[],"description":"","content":"CSAPP-3e-Solutions Computer Systems: A Programmer\u0026rsquo;s Perspective Third Edition Solutions Code Test Convention    test way description     assert use assert function from \u0026lt;assert.h\u0026gt;   output watch code output to judge if it works right   yas use simulator test script to test simulator itself   browser start server and use browser visit server and watch result   benchmark use wrk/ab to make lots of connections at same time to test server    "},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://dreamanddead.github.io/CSAPP-3e-Solutions/tags/","title":"Tags","tags":[],"description":"","content":""}]