<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSAPP-3e-Solutions on CASPP 3e Solutions</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/</link><description>Recent content in CSAPP-3e-Solutions on CASPP 3e Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Feb 2021 09:15:46 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/CSAPP-3e-Solutions/index.xml" rel="self" type="application/rss+xml"/><item><title>10.6</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.6/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.6/</guid><description>fd = 4</description></item><item><title>11.6</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.6/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.6/</guid><description>A.
--- tiny.origin.c 2021-02-25 07:26:33.302592754 +0000 +++ tiny.6.c 2021-02-25 07:26:33.302592754 +0000 @@ -13,6 +13,8 @@ void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void echo(int connfd); + int main(int argc, char **argv) { int listenfd, connfd; @@ -33,11 +35,24 @@ Getnameinfo((SA *) &amp;amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(&amp;#34;Accepted connection from (%s, %s)\n&amp;#34;, hostname, port); - doit(connfd); //line:netp:tiny:doit + echo(connfd); Close(connfd); //line:netp:tiny:close } } +void echo(int connfd) { + size_t n; + char buf[MAXLINE]; + rio_t rio; + + Rio_readinitb(&amp;amp;rio, connfd); + while ((n = Rio_readlineb(&amp;amp;rio, buf, MAXLINE)) !</description></item><item><title>7.6</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.6/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.6/</guid><description>/* * swap.c */ extern int buf[]; int* bufp0 = &amp;amp;buf[0]; static int* bufp1; static void incr() { static int count=0; count++; } void swap() { int temp; incr(); bufp1 = &amp;amp;buf[1]; temp = *bufp0; *bufp0 = *bufp1; *bufp1 = temp; } in .symtab? type module section buf Yes external m .data bufp0 Yes global swap .data bufp1 Yes local swap .</description></item><item><title>10.7</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.7/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.7/</guid><description>/* * 10.7.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; int main(int argc, char* argv[]) { int n; char buf[MAXBUF]; while ((n = Rio_readn(STDIN_FILENO, buf, MAXBUF)) != 0) Rio_writen(STDOUT_FILENO, buf, n); return 0; }</description></item><item><title>11.7</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.7/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.7/</guid><description>visit mdn to check all mime type
--- tiny.origin.c 2021-02-25 07:26:33.302592754 +0000 +++ tiny.7.c 2021-02-25 07:26:33.302592754 +0000 @@ -173,6 +173,8 @@ strcpy(filetype, &amp;#34;image/png&amp;#34;); else if (strstr(filename, &amp;#34;.jpg&amp;#34;)) strcpy(filetype, &amp;#34;image/jpeg&amp;#34;); + else if (strstr(filename, &amp;#34;.mpeg&amp;#34;)) + strcpy(filetype, &amp;#34;video/mpeg&amp;#34;); else strcpy(filetype, &amp;#34;text/plain&amp;#34;); } run server
(cd ./site/content/chapter11/code; make &amp;amp;&amp;amp; ./tiny.7 5000) browser visit
http://localhost:5000/ghost-in-shell.mpeg</description></item><item><title>7.7</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.7/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.7/</guid><description>/* * bar5.c */ double x; void f() { /*x = -0.0;*/ } delete line
x = -0.0;</description></item><item><title>10.8</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.8/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.8/</guid><description>/* * 10.8.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; int main(int argc, char* argv[]) { struct stat stat; char *type, *readok; int fd; if (argc &amp;lt;= 1) fd = 0; // stdin else fd = atoi(argv[1]); Fstat(fd, &amp;amp;stat); if (S_ISREG(stat.st_mode)) type = &amp;#34;regular&amp;#34;; else if (S_ISDIR(stat.st_mode)) type = &amp;#34;dir&amp;#34;; else type = &amp;#34;other&amp;#34;; if ((stat.st_mode &amp;amp; S_IRUSR)) readok = &amp;#34;yes&amp;#34;; else readok = &amp;#34;no&amp;#34;; printf(&amp;#34;type: %s, read: %s\n&amp;#34;, type, readok); return 0; }</description></item><item><title>11.8</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.8/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.8/</guid><description>--- tiny.origin.c 2021-02-25 07:26:33.302592754 +0000 +++ tiny.8.c 2021-02-25 07:26:33.302592754 +0000 @@ -12,6 +12,7 @@ void serve_dynamic(int fd, char *filename, char *cgiargs); void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void sigchild_handler(int sig); int main(int argc, char **argv) { @@ -26,6 +27,9 @@ exit(1); } + if (Signal(SIGCHLD, sigchild_handler) == SIG_ERR) + unix_error(&amp;#34;signal child handler error&amp;#34;); + listenfd = Open_listenfd(argv[1]); while (1) { clientlen = sizeof(clientaddr); @@ -38,6 +42,15 @@ } } +void sigchild_handler(int sig) { + int old_errno = errno; + int status; + pid_t pid; + while ((pid = waitpid(-1, &amp;amp;status, WNOHANG)) &amp;gt; 0) { + } + errno = old_errno; +} + /* * doit - handle one HTTP request/response transaction */ @@ -196,7 +209,6 @@ Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */ //line:netp:servedynamic:dup2 Execve(filename, emptylist, environ); /* Run CGI program */ //line:netp:servedynamic:execve } - Wait(NULL); /* Parent waits for and reaps child */ //line:netp:servedynamic:wait } /*</description></item><item><title>7.8</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.8/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.8/</guid><description>A.
main.1
main.2
B.
unknown
unknown
C.
error
error</description></item><item><title>10.9</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.9/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.9/</guid><description>if (Fork() == 0) { Dup2(0, 3); Execve(&amp;#34;fstatcheck&amp;#34;, argv, envp); }</description></item><item><title>11.9</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.9/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.9/</guid><description>--- tiny.origin.c 2021-02-25 07:26:33.302592754 +0000 +++ tiny.9.c 2021-02-25 07:26:33.302592754 +0000 @@ -152,12 +152,12 @@ printf(&amp;#34;Response headers:\n&amp;#34;); printf(&amp;#34;%s&amp;#34;, buf); - /* Send response body to client */ srcfd = Open(filename, O_RDONLY, 0); //line:netp:servestatic:open - srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);//line:netp:servestatic:mmap + srcp = (char*)Malloc(filesize); + Rio_readn(srcfd, srcp, filesize); Close(srcfd); //line:netp:servestatic:close Rio_writen(fd, srcp, filesize); //line:netp:servestatic:write - Munmap(srcp, filesize); //line:netp:servestatic:munmap + free(srcp); } /*</description></item><item><title>7.9</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.9/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.9/</guid><description>function main print 0x55 on my machine.
modify char main to unsigned int main here
/* * bar6.c */ #include &amp;lt;stdio.h&amp;gt; unsigned int main; void p2() { printf(&amp;#34;0x%x\n&amp;#34;, main); } /* * foo6.c */ void p2(void); void offset(void) { return; } int main(int argc, char* argv[]) { p2(); return 0; }
(cd ./site/content/chapter7/code/7.9; make &amp;amp;&amp;amp; ./main) output:
gcc foo6.c bar6.c -o main /usr/lib/gcc/x86_64-pc-linux-gnu/4.9.4/../../../../x86_64-pc-linux-gnu/bin/ld: Warning: alignment 1 of symbol `main' in /tmp/ccTBhRjm.</description></item><item><title>8.9</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.9/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.9/</guid><description> process pair cocurrent? AB No AC Yes AD Yes BC Yes BD Yes CD Yes</description></item><item><title>10.10</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.10/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter10/10.10/</guid><description>/* * 10.10.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; int main(int argc, char* argv[]) { int n; rio_t rio; char buf[MAXLINE]; if (argc == 2) { int fd = Open(argv[1], O_RDONLY, 0); while ((n = Rio_readn(fd, buf, MAXBUF)) != 0) Rio_writen(STDOUT_FILENO, buf, n); exit(0); } Rio_readinitb(&amp;amp;rio, STDIN_FILENO); while ((n = Rio_readlineb(&amp;amp;rio, buf, MAXLINE)) != 0) Rio_writen(STDOUT_FILENO, buf, n); return 0; }</description></item><item><title>7.10</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.10/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.10/</guid><description>A.
gcc p.o libx.a B.
gcc p.o libx.a liby.a libx.a C.
gcc p.o libx.a liby.a libx.a libz.a</description></item><item><title>7.11</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.11/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.11/</guid><description>space for section .bss</description></item><item><title>7.12</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.12/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.12/</guid><description>A.
ADDR(s) = ADDR(.text) = 0x4004e0
ADDR(r.symbol) = ADDR(swap) = 0x4004f8
refaddr = ADDR(s) + r.offset = 0x4004ea
*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr) = 0xa
B.
ADDR(s) = ADDR(.text) = 0x4004d0
ADDR(r.symbol) = ADDR(swap) = 0x400500
refaddr = ADDR(s) + r.offset = 0x4004da
*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr) = 0x22</description></item><item><title>7.13</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.13/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter7/7.13/</guid><description>A.
libm.a path
whereis libm.a output:
libm: /usr/lib64/libm.a /usr/lib64/libm.so libm.a files
ar t /usr/lib64/libm.a output:
s_lib_version.o s_matherr.o s_signgam.o fclrexcpt.o fgetexcptflg.o fraiseexcpt.o fsetexcptflg.o ftestexcept.o fegetround.o fesetround.o fegetenv.o feholdexcpt.o fesetenv.o feupdateenv.o t_exp.o fedisblxcpt.o feenablxcpt.o fegetexcept.o powl_helper.o e_acos.o e_acosh.o e_asin.o e_atan2.o e_atanh.o .... similar way for libc.a
B.
compile code with -Og and -Og -g
/* * little.c */ int main(int argc, char* argv[]) { return 0; } (cd chapter7/code/7.</description></item><item><title>11.10</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.10/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.10/</guid><description>A.
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Tiny Server&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;#34;/cgi-bin/form-adder&amp;#34; method=&amp;#34;GET&amp;#34;&amp;gt; &amp;lt;p&amp;gt;first number: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;first&amp;#34;/&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;second number: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;second&amp;#34;/&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;Submit&amp;#34;/&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; browser should visit localhost:5000/cgi-bin/form-adder?first=222&amp;amp;second=333
B.
form-adder handle query string like first=ddd&amp;amp;second=dddd
/* * form-adder.c - a minimal CGI program that adds two numbers together */ #include &amp;#34;../csapp.h&amp;#34; int main(void) { char *buf, *p; char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE]; int n1=0, n2=0; /* Extract the two arguments */ if ((buf = getenv(&amp;#34;QUERY_STRING&amp;#34;)) !</description></item><item><title>11.11</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.11/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.11/</guid><description>from rfc2626 section 9.4 HEAD
The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
tiny.c changes
--- tiny.origin.c 2021-02-25 07:26:33.302592754 +0000 +++ tiny.11.c 2021-02-25 07:26:33.302592754 +0000 @@ -7,9 +7,9 @@ void doit(int fd); void read_requesthdrs(rio_t *rp); int parse_uri(char *uri, char *filename, char *cgiargs); -void serve_static(int fd, char *filename, int filesize); +void serve_static(int fd, char *filename, int filesize, char *method); void get_filetype(char *filename, char *filetype); -void serve_dynamic(int fd, char *filename, char *cgiargs); +void serve_dynamic(int fd, char *filename, char *cgiargs, char *method); void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); @@ -55,7 +55,7 @@ return; printf(&amp;#34;%s&amp;#34;, buf); sscanf(buf, &amp;#34;%s %s %s&amp;#34;, method, uri, version); //line:netp:doit:parserequest - if (strcasecmp(method, &amp;#34;GET&amp;#34;)) { //line:netp:doit:beginrequesterr + if (!</description></item><item><title>11.12</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.12/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.12/</guid><description>run server
(cd ./site/content/chapter11/code; make &amp;amp;&amp;amp; ./tiny.12 5000) visit http://localhost:5000/post-home.html and submit
POST method pass param by message-body behind Headers part. When we input 9 and 10 and submit, socket pass content
POST /cgi-bin/post-adder HTTP/1.1 Host: localhost:5000 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 16 Referer: http://localhost:5000/post-home.html Cookie: _ga=GA1.1.1286836072.1494744693 Connection: keep-alive Upgrade-Insecure-Requests: 1 (CRLF here, message-body below) first=9&amp;amp;second=10 Content-Length marks the length of message-body.</description></item><item><title>11.13</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.13/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter11/11.13/</guid><description>--- tiny.origin.c 2021-02-25 07:26:33.302592754 +0000 +++ tiny.13.c 2021-02-25 07:26:33.302592754 +0000 @@ -13,6 +13,17 @@ void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +// improved rio written +void Im_rio_writen(int fd, void *usrbuf, size_t n) { + if (rio_writen(fd, usrbuf, n) != n) { + if (errno == EPIPE) + fprintf(stderr, &amp;#34;EPIPE error&amp;#34;); + + fprintf(stderr, &amp;#34;%s &amp;#34;, strerror(errno)); + unix_error(&amp;#34;client side has ended connection&amp;#34;); + } +} + int main(int argc, char **argv) { int listenfd, connfd; @@ -26,6 +37,9 @@ exit(1); } + if (Signal(SIGPIPE, SIG_IGN) == SIG_ERR) + unix_error(&amp;#34;mask signal pipe error&amp;#34;); + listenfd = Open_listenfd(argv[1]); while (1) { clientlen = sizeof(clientaddr); @@ -148,7 +162,7 @@ sprintf(buf, &amp;#34;%sConnection: close\r\n&amp;#34;, buf); sprintf(buf, &amp;#34;%sContent-length: %d\r\n&amp;#34;, buf, filesize); sprintf(buf, &amp;#34;%sContent-type: %s\r\n\r\n&amp;#34;, buf, filetype); - Rio_writen(fd, buf, strlen(buf)); //line:netp:servestatic:endserve + Im_rio_writen(fd, buf, strlen(buf)); //line:netp:servestatic:endserve printf(&amp;#34;Response headers:\n&amp;#34;); printf(&amp;#34;%s&amp;#34;, buf); @@ -156,7 +170,7 @@ srcfd = Open(filename, O_RDONLY, 0); //line:netp:servestatic:open srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);//line:netp:servestatic:mmap Close(srcfd); //line:netp:servestatic:close - Rio_writen(fd, srcp, filesize); //line:netp:servestatic:write + Im_rio_writen(fd, srcp, filesize); //line:netp:servestatic:write Munmap(srcp, filesize); //line:netp:servestatic:munmap } @@ -186,11 +200,13 @@ /* Return first part of HTTP response */ sprintf(buf, &amp;#34;HTTP/1.</description></item><item><title>12.16</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.16/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.16/</guid><description>/* * 12.16.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; void *thread(void *vargp); #define DEFAULT 4 int main(int argc, char* argv[]) { int N; if (argc &amp;gt; 2) unix_error(&amp;#34;too many param&amp;#34;); else if (argc == 2) N = atoi(argv[1]); else N = DEFAULT; int i; pthread_t tid; for (i = 0; i &amp;lt; N; i++) { Pthread_create(&amp;amp;tid, NULL, thread, NULL); } Pthread_exit(NULL); } void *thread(void *vargp) { printf(&amp;#34;Hello, world\n&amp;#34;); return NULL; }</description></item><item><title>12.17</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.17/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.17/</guid><description>A.
main thread didn&amp;rsquo;t wait other thread.
B.
pthread_exit
/* * 12.17.c */ #include &amp;#34;csapp.h&amp;#34;void *thread(void *vargp); int main() { pthread_t tid; Pthread_create(&amp;amp;tid, NULL, thread, NULL); // exit(0); Pthread_exit(NULL); } /* Thread routine */ void *thread(void *vargp) { Sleep(1); printf(&amp;#34;Hello, world!\n&amp;#34;); return NULL; }</description></item><item><title>12.18</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.18/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.18/</guid><description>A unsafe
B safe
C unsafe</description></item><item><title>12.19</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.19/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.19/</guid><description>pay attention to static int reader_first
/* * 12.19.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; #define WRITE_LIMIT 100000 #define PEOPLE 4 static int readtimes; static int writetimes; static int readcnt; // if a reader is waiting when writing, reader first next round static int reader_first; sem_t mutex, w; void *reader(void *vargp) { while (1) { P(&amp;amp;mutex); readcnt++; if (readcnt == 1) P(&amp;amp;w); V(&amp;amp;mutex); /* Critical section */ readtimes++; reader_first = 0; /* Critical section */ P(&amp;amp;mutex); readcnt--; if (readcnt == 0) V(&amp;amp;w); V(&amp;amp;mutex); } } void *writer(void *vargp) { while (1) { if (reader_first == 1) continue; P(&amp;amp;w); /* Critical section */ writetimes++; if (writetimes == WRITE_LIMIT) { printf(&amp;#34;read/write: %d/%d\n&amp;#34;, readtimes, writetimes); exit(0); } /* Critical section */ // if a reader is waiting, reader first next round if (readcnt == 1) reader_first = 1; V(&amp;amp;w); } } void init(void) { readcnt = 0; readtimes = 0; writetimes = 0; reader_first = 0; Sem_init(&amp;amp;w, 0, 1); Sem_init(&amp;amp;mutex, 0, 1); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i &amp;lt; PEOPLE; i++) if (i%2 == 0) Pthread_create(&amp;amp;tid, NULL, reader, NULL); else Pthread_create(&amp;amp;tid, NULL, writer, NULL); Pthread_exit(NULL); exit(0); }</description></item><item><title>12.20</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.20/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.20/</guid><description>readercnt limits the readers number at the same time.
/* * 12.20.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; #define WRITE_LIMIT 100000 #define PEOPLE 20 // 10 reader and 10 writer #define N 5 static int readtimes; static int writetimes; sem_t mutex; sem_t readercnt; void *reader(void *vargp) { while (1) { P(&amp;amp;readercnt); P(&amp;amp;mutex); readtimes++; V(&amp;amp;mutex); V(&amp;amp;readercnt); } } void *writer(void *vargp) { while (1) { P(&amp;amp;mutex); writetimes++; if (writetimes == WRITE_LIMIT) { printf(&amp;#34;read/write: %d/%d\n&amp;#34;, readtimes, writetimes); exit(0); } V(&amp;amp;mutex); } } void init(void) { readtimes = 0; writetimes = 0; Sem_init(&amp;amp;mutex, 0, 1); Sem_init(&amp;amp;readercnt, 0, N); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i &amp;lt; PEOPLE; i++) { if (i%2 == 0) Pthread_create(&amp;amp;tid, NULL, reader, NULL); else Pthread_create(&amp;amp;tid, NULL, writer, NULL); } Pthread_exit(NULL); exit(0); }</description></item><item><title>12.21</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.21/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.21/</guid><description>writecnt record how many writers are waiting.
/* * 12.21.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; #define WRITE_LIMIT 100000 #define PEOPLE 4 static int readtimes; static int writetimes; static int writecnt; sem_t mutex, w; static int number; void *reader(void *vargp) { while (1) { // writer first if (writecnt &amp;gt; 0) continue; P(&amp;amp;w); /* Critical section */ readtimes++; /* Critical section */ V(&amp;amp;w); } } void *writer(void *vargp) { while (1) { P(&amp;amp;mutex); // one more writer wait to write writecnt++; V(&amp;amp;mutex); P(&amp;amp;w); /* Critical section */ writetimes++; if (writetimes == WRITE_LIMIT) { printf(&amp;#34;read/write: %d/%d\n&amp;#34;, readtimes, writetimes); exit(0); } /* Critical section */ V(&amp;amp;w); P(&amp;amp;mutex); // writer has written writecnt--; V(&amp;amp;mutex); } } void init(void) { writecnt = 0; readtimes = 0; writetimes = 0; Sem_init(&amp;amp;w, 0, 1); Sem_init(&amp;amp;mutex, 0, 1); } int main(int argc, char* argv[]) { int i; pthread_t tid; init(); for (i = 0; i &amp;lt; PEOPLE; i++) { if (i%2 == 0) Pthread_create(&amp;amp;tid, NULL, reader, NULL); else Pthread_create(&amp;amp;tid, NULL, writer, NULL); } Pthread_exit(NULL); exit(0); }</description></item><item><title>12.22</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.22/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.22/</guid><description>#include &amp;#34;csapp.h&amp;#34; /* read line from connfd and echo line to connfd */ int echo_line(int connfd); void command(void); int main(int argc, char **argv) { int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; fd_set read_set, ready_set; if (argc != 2) { fprintf(stderr, &amp;#34;usage: %s &amp;lt;port&amp;gt;\nuse port 5000 here\n&amp;#34;, argv[0]); // default port 5000 listenfd = Open_listenfd(&amp;#34;5000&amp;#34;); } else { listenfd = Open_listenfd(argv[1]); //line:conc:select:openlistenfd } FD_ZERO(&amp;amp;read_set); /* Clear read set */ //line:conc:select:clearreadset FD_SET(STDIN_FILENO, &amp;amp;read_set); /* Add stdin to read set */ //line:conc:select:addstdin FD_SET(listenfd, &amp;amp;read_set); /* Add listenfd to read set */ //line:conc:select:addlistenfd // max n for select int n = listenfd+1; while (1) { ready_set = read_set; Select(n, &amp;amp;ready_set, NULL, NULL, NULL); //line:conc:select:select if (FD_ISSET(STDIN_FILENO, &amp;amp;ready_set)) //line:conc:select:stdinready command(); /* Read command line from stdin */ if (FD_ISSET(listenfd, &amp;amp;ready_set)) { //line:conc:select:listenfdready clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA *)&amp;amp;clientaddr, &amp;amp;clientlen); // listen to accepted io ports if (connfd+1 &amp;gt; FD_SETSIZE) { fprintf(stderr, &amp;#34;too many clients\n&amp;#34;); Close(connfd); } n = n &amp;gt; connfd+1 ?</description></item><item><title>12.23</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.23/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.23/</guid><description>code in pic 12-8 save as file 12.23.bug.c
run server
(cd ./site/content/chapter12/code; make &amp;amp;&amp;amp; ./12.23.bug) let&amp;rsquo;s figure out when server will fail, see code 12.23.client.c
/* * 12.23.client.c - An echo client */ #include &amp;#34;csapp.h&amp;#34; int main(int argc, char **argv) { int clientfd; char *host, *port; char *buf = &amp;#34;something to send\n&amp;#34;; rio_t rio; host = &amp;#34;127.0.0.1&amp;#34;; port = &amp;#34;5000&amp;#34;; clientfd = Open_clientfd(host, port); Rio_readinitb(&amp;amp;rio, clientfd); Rio_writen(clientfd, buf, strlen(buf)); /*Close(clientfd);*/ exit(0); } line 20 Close(clientfd) are commented.</description></item><item><title>12.24</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.24/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.24/</guid><description>if don&amp;rsquo;t pass pointer param which points to same data block, functions
rio_readn rio_writen rio_readinitb rio_readlineb rio_readnb are all implicitly reentrant functions</description></item><item><title>12.25</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.25/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.25/</guid><description>/* * A thread-safe version of echo that counts the total number * of bytes received from clients. */ /* $begin echo_cnt */ #include &amp;#34;csapp.h&amp;#34; static int byte_cnt; /* Byte counter */ static sem_t mutex; /* and the mutex that protects it */ static void init_echo_cnt(void) { Sem_init(&amp;amp;mutex, 0, 1); byte_cnt = 0; } void echo_cnt(int connfd) { int n; char buf[MAXLINE]; rio_t rio; static pthread_once_t once = PTHREAD_ONCE_INIT; Pthread_once(&amp;amp;once, init_echo_cnt); //line:conc:pre:pthreadonce Rio_readinitb(&amp;amp;rio, connfd); //line:conc:pre:rioinitb while((n = Rio_readlineb(&amp;amp;rio, buf, MAXLINE)) !</description></item><item><title>12.26</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.26/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.26/</guid><description>struct hostent *gethostbyname(const char *name) struct hostent { char *h_name; char **h_aliases; int h_addrtype; int h_length; char **h_addr_list; } copy int, copy char*, copy char** in struct hostent are 3 different ways.
/* * 12.26.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; /* * struct hostent *gethostbyname(const char *name) * * struct hostent { * char *h_name; * char **h_aliases; * int h_addrtype; * int h_length; * char **h_addr_list; * } */ static sem_t mutex; static void init_mutex(void) { Sem_init(&amp;amp;mutex, 0, 1); } struct hostent *gethostbyname_ts(const char *name, struct hostent *host) { struct hostent *sharehost; P(&amp;amp;mutex); sharehost = gethostbyname(name); // copy int host-&amp;gt;h_addrtype = sharehost-&amp;gt;h_addrtype; host-&amp;gt;h_length = sharehost-&amp;gt;h_length; // copy char * host-&amp;gt;h_name = (char*)Malloc(strlen(sharehost-&amp;gt;h_name)); strcpy(host-&amp;gt;h_name, sharehost-&amp;gt;h_name); // copy char ** int i; for (i = 0; sharehost-&amp;gt;h_aliases[i] !</description></item><item><title>12.27</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.27/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.27/</guid><description>FILE *fpin, *fpout; fpin = fdopen(sockfd, &amp;#34;r&amp;#34;); fpout = fdopen(sockfd, &amp;#34;w&amp;#34;); // read and write fclose(fpin); fclose(fpout); ref: 10.11
fdopen open 2 stream on same sockfd, fdclose will close sockfd under stream. if you call fclose 2 stream on the same sockfd, the second fclose will fail.
image one thread execute code and open 2 stream on fd N. after execution of line fclose(fpin);, program create another thread and execute the same code.</description></item><item><title>12.28</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.28/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.28/</guid><description>No effect on deadlock
1
thread 1 thread 2 P(s) P(s) P(t) P(t) V(s) V(s) V(t) V(t) + | | + +--------------------+ V(t)| | | | | | + | unsafe region t | | | | | | | + +---------+---------+ | V(s)| | | | | | | | | | + | | | | | | | | | | | | | | + | +---------+----------+ P(t)| | | | | unsafe region s | + | | | | | | | | + +-------------------+ P(s)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(s) P(t) V(s) V(t) 2</description></item><item><title>12.29</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.29/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.29/</guid><description>no deadlock
initial: a = 1, b = 1, c = 1
thread 1 thread 2 P(a) P(c) P(b) P(b) V(b) V(b) P(c) V(c) V(c) &amp;mdash;- V(a) &amp;mdash;- thread 2 doesn&amp;rsquo;t manipulate mutex a and initial a is 1, so P(a), V(a) don&amp;rsquo;t affect deadlock status.
thread 1 thread 2 P(b) P(c) V(b) P(b) P(c) V(b) V(c) V(c) + | | + +----------+ V(c)| | | | | | + | | | | | | | | + +----------+ | | V(b)| | | | | | | | | | + | | | | | | | | | | | | | | + +----------+ | | P(b)| | | | | | + | | | | | | | | + +----------+ P(c)| | + | | +----+----+----+----+----+----+----+----+----+ thread 1 P(b) V(b) P(c) V(c)</description></item><item><title>12.30</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.30/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.30/</guid><description>initial: a = 1, b = 1, c = 1
thread 1 thread 2 thread 3 P(a) P(c) P(c) P(b) P(b) V(c) V(b) V(b) P(b) P(c) V(c) P(a) V(c) P(a) V(a) V(a) V(a) V(b) A.
thread 1: a&amp;amp;b, a&amp;amp;c
thread 2: b&amp;amp;c
thread 3: a&amp;amp;b
B.
thread 2 and thread 3</description></item><item><title>12.31</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.31/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.31/</guid><description>/* * 12.31.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; sigjmp_buf buf; void sigchild_handler(int sig) { siglongjmp(buf, 1); } char *tfgets(char *s, int size, FILE *stream) { if (Fork() == 0) { Sleep(5); exit(0); } switch (sigsetjmp(buf, 1)) { case 0: Signal(SIGCHLD, sigchild_handler); return fgets(s, size, stream); case 1: return NULL; } } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(&amp;#34;BOOM!\n&amp;#34;); else printf(&amp;#34;%s&amp;#34;, buf); return 0; }</description></item><item><title>12.32</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.32/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.32/</guid><description>key is last param of select
/* * 12.32.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; char *tfgets(char *s, int size, FILE *stream) { fd_set read_set; FD_ZERO(&amp;amp;read_set); FD_SET(STDIN_FILENO, &amp;amp;read_set); struct timeval timeout; timeout.tv_sec = 5; timeout.tv_usec = 0; Select(1, &amp;amp;read_set, NULL, NULL, &amp;amp;timeout); if (FD_ISSET(STDIN_FILENO, &amp;amp;read_set)) return fgets(s, size, stream); else return NULL; } int main(int argc, char* argv[]) { char buf[MAXLINE]; if (tfgets(buf, MAXLINE, stdin) == NULL) printf(&amp;#34;BOOM!\n&amp;#34;); else printf(&amp;#34;%s&amp;#34;, buf); return 0; }</description></item><item><title>12.33</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.33/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.33/</guid><description>/* * 12.33.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; struct pack { char *s; int size; FILE *stream; }; char *ptr = NULL; int timeout = -1; void *thread_read(void *vargp) { struct pack p = *(struct pack *)vargp; ptr = fgets(p.s, p.size, p.stream); timeout = 0; } void *thread_sleep(void *vargp) { Sleep(5); timeout = 1; } char *tfgets(char *s, int size, FILE *stream) { pthread_t tid_read; pthread_t tid_sleep; struct pack p; p.s = s; p.</description></item><item><title>12.34</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.34/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.34/</guid><description>matrix size and thread number
/* * 12.34.h */ #define N 640 #define M 640 #define THREAD (1&amp;lt;&amp;lt;4) #define ROWS_PER_THREAD (N / THREAD) non concurrent version
/* * 12.34.non.concurrent.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34;#include &amp;#34;12.34.h&amp;#34; int M1[N][M]; int M2[N][M]; int MUL12[N][M]; void non_concurrent_mul(void) { int i, j, k; for (i = 0; i &amp;lt; N; i++) for (j = 0; j &amp;lt; N; j++) { int sum = 0; for (k = 0; k &amp;lt; M; k++) { sum += M1[i][k] * M2[k][j]; } MUL12[i][j] = sum; } } int main(int argc, char* argv[]) { non_concurrent_mul(); return 0; } concurrent version</description></item><item><title>12.35</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.35/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.35/</guid><description>see origin tiny server in section 11.6 on book
the key is close(connfd) in both parent and child process to ensure close fd and reuse it or it&amp;rsquo;ll failed: Accept error: too many open files
--- 12.tiny.c 2021-02-25 07:26:33.305926066 +0000 +++ 12.35.c 2021-02-25 07:26:33.302592754 +0000 @@ -1,6 +1,8 @@ /* - * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the + * 12.35.c - A simple, iterative HTTP/1.</description></item><item><title>12.36</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.36/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.36/</guid><description>check section 11.6 and 12.2.1, combine code pieces together
code directory: chapter12/code/12.36
origin tiny server: tiny.h tiny.c
select echoserver: echoserver.h echoserver.c
key points:
move main loop to main.c file check_clients in echoserver call doit(from tiny server) and close fd benchmark it
Running 4s test @ http://localhost:5000 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 62.72ms 91.68ms 368.55ms 82.94% Req/Sec 615.27 398.96 1.46k 65.91% 3649 requests in 4.</description></item><item><title>12.37</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.37/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.37/</guid><description>see origin tiny server in section 11.6 on book
the key is how to pass connfd into thread
--- 12.tiny.c 2021-02-25 07:26:33.305926066 +0000 +++ 12.37.c 2021-02-25 07:26:33.302592754 +0000 @@ -13,9 +13,13 @@ void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg); +void *thread(void *vargp); + int main(int argc, char **argv) { int listenfd, connfd; + int *connfdp; + pthread_t tid; char hostname[MAXLINE], port[MAXLINE]; socklen_t clientlen; struct sockaddr_storage clientaddr; @@ -35,11 +39,23 @@ Getnameinfo((SA *) &amp;amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(&amp;#34;Accepted connection from (%s, %s)\n&amp;#34;, hostname, port); - doit(connfd); //line:netp:tiny:doit - Close(connfd); //line:netp:tiny:close + + connfdp = (int*)Malloc(sizeof(int)); + *connfdp = connfd; + Pthread_create(&amp;amp;tid, NULL, thread, connfdp); } } +void *thread(void *vargp) { + int connfd = *(int*)vargp; + Pthread_detach(Pthread_self()); + Free(vargp); + + doit(connfd); + Close(connfd); + return NULL; +} + /* * doit - handle one HTTP request/response transaction */ run server</description></item><item><title>12.38</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.38/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.38/</guid><description>code in directory chapter12/code/12.38
files:
sbuf.h, sbuf.c: prethreading package from section 12.5.4 in book. differences are that add new functions sbuf_full, sbuf_empty. tiny.h, tiny.c: origin tiny server from section 11.6 in book. differences are we seperate function declarations into a .h file main.c: listen new connections, create threads and adjust threads number dynamicly see new functions in sbuf, sbuf_full and sbuf_empty
/* Empty buf? */ int sbuf_empty(sbuf_t *sp) { int e; P(&amp;amp;sp-&amp;gt;mutex); /* Lock the buffer */ e = sp-&amp;gt;front == sp-&amp;gt;rear; V(&amp;amp;sp-&amp;gt;mutex); /* Lock the buffer */ return e; } /* Full buf?</description></item><item><title>12.39</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.39/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter12/12.39/</guid><description>+------+ +------+ +------+ | |-----&amp;gt;| |------&amp;gt;| | |client| |proxy | |server| | |&amp;lt;-----| |&amp;lt;------| | +------+ +------+ +------+ as server as client proxy play with client as a server, with server as a client, interesting.
the key point is when normal situation
+------+ +------+ | |-----&amp;gt;| | |client| |server| | |&amp;lt;-----| | +------+ +------+ HTTP request from client is something like
GET / HTTP/1.1 Host: address:port but with proxy, it&amp;rsquo;ll be</description></item><item><title>2.55</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.55/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.55/</guid><description>/* * show-bytes.c */ #include &amp;lt;stdio.h&amp;gt; typedef unsigned char* byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i &amp;lt; len; i++) { printf(&amp;#34; %.2x&amp;#34;, start[i]); } printf(&amp;#34;\n&amp;#34;); } void show_int(int x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(void*)); } void test_show_bytes(int val) { int ival = val; float fval = (float) ival; int* pval = &amp;amp;ival; show_int(ival); show_float(fval); show_pointer(pval); } int main(int argc, char* argv[]) { int test_num = 328; test_show_bytes(test_num); return 0; } run</description></item><item><title>2.56</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.56/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.56/</guid><description>change var test_num in show-bytes.c
int test_num = 1024; recompile and run
./show-bytes output
00 04 00 00 00 00 80 44 c8 fe 83 2f fc 7f 00 00 You can try more integers :)</description></item><item><title>2.57</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.57/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.57/</guid><description>/* * show-bytes.c */ #include &amp;lt;stdio.h&amp;gt; typedef unsigned char* byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i &amp;lt; len; i++) { printf(&amp;#34; %.2x&amp;#34;, start[i]); } printf(&amp;#34;\n&amp;#34;); } void show_int(int x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(int)); } void show_float(float x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(void*)); } //============= // 2.57 changes //============= void show_short(short x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(short)); } void show_long(long x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(long)); } void show_double(double x) { show_bytes((byte_pointer) &amp;amp;x, sizeof(double)); } //================== // 2.</description></item><item><title>2.58</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.58/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.58/</guid><description>/* * is-little-endian.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef unsigned char* byte_pointer; int is_little_endian() { int test_num = 0xff; byte_pointer byte_start = (byte_pointer) &amp;amp;test_num; if (byte_start[0] == 0xff) { return 1; } return 0; } int main(int argc, char* argv[]) { assert(is_little_endian()); return 0; }</description></item><item><title>2.59</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.59/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.59/</guid><description>expression
(x &amp;amp; 0xFF) | (y &amp;amp; ~0xFF) try it
/* * generate-a-word.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int main(int argc, char* argv[]) { size_t mask = 0xff; size_t x = 0x89ABCDEF; size_t y = 0x76543210; size_t res = (x &amp;amp; mask) | (y &amp;amp; ~mask); assert(res == 0x765432EF); return 0; }</description></item><item><title>2.60</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.60/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.60/</guid><description>/* * replace-byte.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; unsigned replace_byte(unsigned x, int i, unsigned char b) { if (i &amp;lt; 0) { printf(&amp;#34;error: i is negetive\n&amp;#34;); return x; } if (i &amp;gt; sizeof(unsigned)-1) { printf(&amp;#34;error: too big i&amp;#34;); return x; } // 1 byte has 8 bits, &amp;lt;&amp;lt; 3 means * 8 unsigned mask = ((unsigned) 0xFF) &amp;lt;&amp;lt; (i &amp;lt;&amp;lt; 3); unsigned pos_byte = ((unsigned) b) &amp;lt;&amp;lt; (i &amp;lt;&amp;lt; 3); return (x &amp;amp; ~mask) | pos_byte; } int main(int argc, char *argv[]) { unsigned rep_0 = replace_byte(0x12345678, 0, 0xAB); unsigned rep_3 = replace_byte(0x12345678, 3, 0xAB); assert(rep_0 == 0x123456AB); assert(rep_3 == 0xAB345678); return 0; }</description></item><item><title>2.61</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.61/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.61/</guid><description>A
!~x B
!x C
!~(x | ~0xff) D
!((x &amp;gt;&amp;gt; ((sizeof(int)-1) &amp;lt;&amp;lt; 3)) &amp;amp; 0xff) test it
/* * 2.61.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int A(int x) { return !~x; } int B(int x) { return !x; } int C(int x) { return A(x | ~0xff); } int D(int x) { return B((x &amp;gt;&amp;gt; ((sizeof(int)-1) &amp;lt;&amp;lt; 3)) &amp;amp; 0xff); } int main(int argc, char* argv[]) { int all_bit_one = ~0; int all_bit_zero = 0; assert(A(all_bit_one)); assert(!</description></item><item><title>2.62</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.62/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.62/</guid><description>/* * int-shifts-are-arithemetic.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int int_shifts_are_arithemetic() { int num = -1; return !(num ^ (num &amp;gt;&amp;gt; 1)); } int main(int argc, char* argv[]) { assert(int_shifts_are_arithemetic()); return 0; }</description></item><item><title>2.63</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.63/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.63/</guid><description>/* * srl-sra.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; unsigned srl(unsigned x, int k) { unsigned xsra = (int) x &amp;gt;&amp;gt; k; int w = sizeof(int) &amp;lt;&amp;lt; 3; int mask = (int) -1 &amp;lt;&amp;lt; (w - k); return xsra &amp;amp; ~mask; } int sra(int x, int k) { int xsrl = (unsigned) x &amp;gt;&amp;gt; k; int w = sizeof(int) &amp;lt;&amp;lt; 3; int mask = (int) -1 &amp;lt;&amp;lt; (w - k); //let mask remain unchanged when the first bit of x is 1, otherwise 0.</description></item><item><title>2.64</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.64/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.64/</guid><description>/* * any-odd-one.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int any_odd_one(unsigned x) { return !!(0xAAAAAAAA &amp;amp; x); } int main(int argc, char* argv[]) { assert(any_odd_one(0x2)); assert(!any_odd_one(0x4)); return 0; }</description></item><item><title>2.65</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.65/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.65/</guid><description>Thanks this answer from stackoverflow
/* * odd-ones.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int odd_ones(unsigned x) { x ^= x &amp;gt;&amp;gt; 16; x ^= x &amp;gt;&amp;gt; 8; x ^= x &amp;gt;&amp;gt; 4; x ^= x &amp;gt;&amp;gt; 2; x ^= x &amp;gt;&amp;gt; 1; x &amp;amp;= 0x1; return x; } int main(int argc, char* argv[]) { assert(odd_ones(0x10101011)); assert(!odd_ones(0x01010101)); return 0; }</description></item><item><title>2.66</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.66/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.66/</guid><description>/* * leftmost-one.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* * Generate mask indicating leftmost 1 in x. Assume w=32 * For example, 0xFF00 -&amp;gt; 0x8000, and 0x6000 -&amp;gt; 0x4000. * If x = 0, then return 0 */ int leftmost_one(unsigned x) { /* * first, generate a mask that all bits after leftmost one are one * e.g. 0xFF00 -&amp;gt; 0xFFFF, and 0x6000 -&amp;gt; 0x7FFF * If x = 0, get 0 */ x |= x &amp;gt;&amp;gt; 1; x |= x &amp;gt;&amp;gt; 2; x |= x &amp;gt;&amp;gt; 4; x |= x &amp;gt;&amp;gt; 8; x |= x &amp;gt;&amp;gt; 16; /* * then, do (mask &amp;gt;&amp;gt; 1) + (mask &amp;amp;&amp;amp; 1), in which mask &amp;amp;&amp;amp; 1 deals with case x = 0, reserve leftmost bit one * that&amp;#39;s we want */ return (x &amp;gt;&amp;gt; 1) + (x &amp;amp;&amp;amp; 1); } int main(int argc, char* argv[]) { assert(leftmost_one(0xFF00) == 0x8000); assert(leftmost_one(0x6000) == 0x4000); assert(leftmost_one(0x0) == 0x0); assert(leftmost_one(0x80000000) == 0x80000000); return 0; }</description></item><item><title>2.67</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.67/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.67/</guid><description>A.
In section 6.5.7 Bitwise shift operators of c11 standard, it said
If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior it undefined.
B.
check function int_size_is_32
C.
check function int_size_is_32_for_16bit
/* * int-size-is-32.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* The following function does not run properly on some machine */ /* int bad_int_size_is_32() { int set_msb = 1 &amp;lt;&amp;lt; 31; int beyond_msb = 1 &amp;lt;&amp;lt; 32; return set_msb &amp;amp;&amp;amp; !</description></item><item><title>2.68</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.68/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.68/</guid><description>/* * lower-one-mask.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* * Mask with least signficant n bits set to 1 * Example: n = 6 -&amp;gt; 0x3F, n = 17 -&amp;gt; 0x1FFFF * Assume 1 &amp;lt;= n &amp;lt;= w */ int lower_one_mask(int n) { int w = sizeof(int) &amp;lt;&amp;lt; 3; return (unsigned) -1 &amp;gt;&amp;gt; (w - n); } int main(int argc, char* argv[]) { assert(lower_one_mask(6) == 0x3F); assert(lower_one_mask(17) == 0x1FFFF); assert(lower_one_mask(32) == 0xFFFFFFFF); return 0; }</description></item><item><title>2.69</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.69/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.69/</guid><description>/* * rotate-left.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* * Do rotate left shift. Assume 0 &amp;lt;= n &amp;lt; w * Example when x = 0x12345678 and w = 32: * n = 4 -&amp;gt; 0x23456781, n = 20 -&amp;gt; 0x67812345 */ unsigned rotate_left(unsigned x, int n) { int w = sizeof(unsigned) &amp;lt;&amp;lt; 3; /* pay attention when n == 0 */ return x &amp;lt;&amp;lt; n | x &amp;gt;&amp;gt; (w - n - 1) &amp;gt;&amp;gt; 1; } int main(int argc, char* argv[]) { assert(rotate_left(0x12345678, 4) == 0x23456781); assert(rotate_left(0x12345678, 20) == 0x67812345); return 0; }</description></item><item><title>2.70</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.70/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.70/</guid><description>/* * fits-bits.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; int fits_bits(int x, int n) { /* * 1 &amp;lt;= n &amp;lt;= w * * assume w = 8, n = 3 * if x &amp;gt; 0 * 0b00000010 is ok, 0b00001010 is not, and 0b00000110 is not yet (thanks itardc@163.com) * if x &amp;lt; 0 * 0b11111100 is ok, 0b10111100 is not, and 0b11111000 is not yet * * the point is * x &amp;lt;&amp;lt; (w-n) &amp;gt;&amp;gt; (w-n) must be equal to x itself.</description></item><item><title>2.71</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.71/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.71/</guid><description>A.
This function can&amp;rsquo;t extract a negetive byte number from word
B.
/* * xbyte.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef unsigned packet_t; int xbyte(packet_t word, int bytenum) { /* * pay attention when byte we want is negetive * * Assume sizeof(unsigned) is 4 * first shift left 8 * (4 - 1 - bytenum) * then arthemetic shift right 8 * (4 - 1) reserve signficant bit */ int size = sizeof(unsigned); int shift_left_val = (size - 1 - bytenum) &amp;lt;&amp;lt; 3; int shift_right_val = (size - 1) &amp;lt;&amp;lt; 3; return (int) word &amp;lt;&amp;lt; shift_left_val &amp;gt;&amp;gt; shift_right_val; } int main(int argc, char* argv[]) { assert(xbyte(0xAABBCCDD, 1) == 0xFFFFFFCC); assert(xbyte(0x00112233, 2) == 0x11); return 0; }</description></item><item><title>2.72</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.72/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.72/</guid><description>A.
sizeof(val) returns type size_t, it usually is a kind of unsigned type.
maxbytes - sizeof(val) returns value of type size_t, and it&amp;rsquo;s always &amp;gt;= 0
B.
/* * copy-int.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; void copy_int(int val, void* buf, int maxbytes) { /* compare two signed number, avoid someone set maxbytes a negetive value */ if (maxbytes &amp;gt;= (int) sizeof(val)) { memcpy(buf, (void*)&amp;amp;val, sizeof(val)); } } int main(int argc, char* argv[]) { int maxbytes = sizeof(int) * 10; void* buf = malloc(maxbytes); int val; val = 0x12345678; copy_int(val, buf, maxbytes); assert(*(int*)buf == val); val = 0xAABBCCDD; copy_int(val, buf, 0); assert(*(int*)buf !</description></item><item><title>2.73</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.73/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.73/</guid><description>I can&amp;rsquo;t figure out a elegant solution :(
thanks https://zhangjunphy.github.io/csapp/chap2.html :)
/* * saturating-add.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; int saturating_add(int x, int y) { int sum = x + y; int sig_mask = INT_MIN; /* * if x &amp;gt; 0, y &amp;gt; 0 but sum &amp;lt; 0, it&amp;#39;s a positive overflow * if x &amp;lt; 0, y &amp;lt; 0 but sum &amp;gt;= 0, it&amp;#39;s a negetive overflow */ int pos_over = !</description></item><item><title>2.74</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.74/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.74/</guid><description>/* * tsub-ok.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* Determine whether arguments can be substracted without overflow */ int tsub_ok(int x, int y) { int res = 1; (y == INT_MIN) &amp;amp;&amp;amp; (res = 0); // if (y == INT_MIN) res = 0; int sub = x - y; int pos_over = x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; 0 &amp;amp;&amp;amp; sub &amp;lt; 0; int neg_over = x &amp;lt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; sub &amp;gt; 0; res = res &amp;amp;&amp;amp; !</description></item><item><title>2.75</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.75/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.75/</guid><description>/* * unsigned-high-prod.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;inttypes.h&amp;gt; int signed_high_prod(int x, int y) { int64_t mul = (int64_t) x * y; return mul &amp;gt;&amp;gt; 32; } unsigned unsigned_high_prod(unsigned x, unsigned y) { /* TODO calculations */ int sig_x = x &amp;gt;&amp;gt; 31; int sig_y = y &amp;gt;&amp;gt; 31; int signed_prod = signed_high_prod(x, y); return signed_prod + x * sig_y + y * sig_x; } /* a theorically correct version to test unsigned_high_prod func */ unsigned another_unsigned_high_prod(unsigned x, unsigned y) { uint64_t mul = (uint64_t) x * y; return mul &amp;gt;&amp;gt; 32; } int main(int argc, char* argv[]) { unsigned x = 0x12345678; unsigned y = 0xFFFFFFFF; assert(another_unsigned_high_prod(x, y) == unsigned_high_prod(x, y)); return 0; }</description></item><item><title>2.76</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.76/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.76/</guid><description>/* * calloc.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;string.h&amp;gt; /* rename to avoid conflict */ void* another_calloc(size_t nmemb, size_t size) { if (nmemb == 0 || size == 0) { return NULL; } size_t buf_size = nmemb * size; /* a good way to check overflow or not */ if (nmemb == buf_size / size) { void* ptr = malloc(buf_size); if(ptr != NULL) { memset(ptr, 0, buf_size); } return ptr; } return NULL; } int main(int argc, char* argv[]) { void* p; p = another_calloc(0x1234, 1); assert(p !</description></item><item><title>2.77</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.77/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.77/</guid><description>/* * 2.77.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* K = 17 */ int A(int x) { return (x &amp;lt;&amp;lt; 4) + x; } /* K = -7 */ int B(int x) { return x - (x &amp;lt;&amp;lt; 3); } /* K = 60 */ int C(int x) { return (x &amp;lt;&amp;lt; 6) - (x &amp;lt;&amp;lt; 2); } /* K = -112 */ int D(int x) { return (x &amp;lt;&amp;lt; 4) - (x &amp;lt;&amp;lt; 7); } int main(int argc, char* argv[]) { int x = 0x87654321; assert(A(x) == 17 * x); assert(B(x) == -7 * x); assert(C(x) == 60 * x); assert(D(x) == -112 * x); return 0; }</description></item><item><title>2.78</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.78/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.78/</guid><description>/* * divide-power2.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* * Divide by power of 2, -&amp;gt; x/2^k * Assume 0 &amp;lt;= k &amp;lt; w-1 */ int divide_power2(int x, int k) { int is_neg = x &amp;amp; INT_MIN; (is_neg &amp;amp;&amp;amp; (x = x + (1 &amp;lt;&amp;lt; k) - 1)); return x &amp;gt;&amp;gt; k; } int main(int argc, char* argv[]) { int x = 0x80000007; assert(divide_power2(x, 1) == x / 2); assert(divide_power2(x, 2) == x / 4); return 0; }</description></item><item><title>2.79</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.79/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.79/</guid><description>/* * mul3div4.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* * code from 2.78 * * Divide by power of 2, -&amp;gt; x/2^k * Assume 0 &amp;lt;= k &amp;lt; w-1 */ int divide_power2(int x, int k) { int is_neg = x &amp;amp; INT_MIN; (is_neg &amp;amp;&amp;amp; (x = x + (1 &amp;lt;&amp;lt; k) - 1)); return x &amp;gt;&amp;gt; k; } int mul3div4(int x) { int mul3 = (x &amp;lt;&amp;lt; 1) + x; return divide_power2(mul3, 2); } int main(int argc, char* argv[]) { int x = 0x87654321; assert(mul3div4(x) == x * 3 / 4); return 0; }</description></item><item><title>2.80</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.80/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.80/</guid><description>/* * threeforths.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt; /* * calculate 3/4x, no overflow, round to zero * * no overflow means divide 4 first, then multiple 3, diffrent from 2.79 here * * rounding to zero is a little complicated. * every int x, equals f(first 30 bit number) plus l(last 2 bit number) * * f = x &amp;amp; ~0x3 * l = x &amp;amp; 0x3 * x = f + l * threeforths(x) = f/4*3 + l*3/4 * * f doesn&amp;#39;t care about round at all, we just care about rounding from l*3/4 * * lm3 = (l &amp;lt;&amp;lt; 1) + l * * when x &amp;gt; 0, rounding to zero is easy * * lm3d4 = lm3 &amp;gt;&amp;gt; 2 * * when x &amp;lt; 0, rounding to zero acts like divide_power2 in 2.</description></item><item><title>2.81</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.81/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.81/</guid><description>A.
-1 &amp;lt;&amp;lt; k B.
~(-1 &amp;lt;&amp;lt; k) &amp;lt;&amp;lt; j /* * 2.81.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; /* Assume 0 &amp;lt;= k &amp;lt; w */ int A(int k) { return -1 &amp;lt;&amp;lt; k; } /* Assume 0 &amp;lt;= j,k &amp;lt; w */ int B(int k, int j) { return ~A(k) &amp;lt;&amp;lt; j; } int main(int argc, char* argv[]) { assert(A(8) == 0xFFFFFF00); assert(B(16, 8) == 0x00FFFF00); return 0; }</description></item><item><title>2.82</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.82/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.82/</guid><description>A.
wrong, when x == INT_MIN
B.
right
C.
right
D.
right
E.
right
/* * 2.82.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;lib/random.h&amp;#34; /* broken when x is INT_MIN */ int A(int x, int y) { return (x &amp;lt; y) == (-x &amp;gt; -y); } /* * right * * ((x + y) &amp;lt;&amp;lt; 4) + y - x * =&amp;gt; * x &amp;lt;&amp;lt; 4 - x + y &amp;lt;&amp;lt; 4 + y * =&amp;gt; * x*16 - x + y*16 + y * whether overflow or not, =&amp;gt; * x*15 + y*17 */ int B(int x, int y) { return ((x + y) &amp;lt;&amp;lt; 4) + y - x == 17 * y + 15 * x; } /* * right * * ~x + ~y + 1 * =&amp;gt; * ~x + 1 + ~y + 1 - 1 * =&amp;gt; * -x + -y - 1 * =&amp;gt; * -(x + y) - 1 * =&amp;gt; * ~(x + y) + 1 - 1 * =&amp;gt; * ~(x + y) */ int C(int x, int y) { return ~x + ~y + 1 == ~(x + y); } /* * right * * (ux - uy) == -(unsigned) (y - x) * =&amp;gt; * -(ux - uy) == (unsigned) (y - x) * =&amp;gt; * (ux - uy) == (unsigned) (x - y) */ int D(int x, int y) { unsigned ux = (unsigned) x; unsigned uy = (unsigned) y; return (ux - uy) == -(unsigned) (y - x); } /* * right * * x &amp;gt;&amp;gt; 2 &amp;lt;&amp;lt; 2 * =&amp;gt; * x &amp;amp; ~0x3 * =&amp;gt; * x - num(00/01/10/11) * =&amp;gt; * ((x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 2) &amp;lt;= x */ int E(int x, int y) { return ((x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 2) &amp;lt;= x; } int main(int argc, char* argv[]) { init_seed(); int x = random_int(); int y = random_int(); assert(!</description></item><item><title>2.83</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.83/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.83/</guid><description>A.
n = 0.yyyyy... n &amp;lt;&amp;lt; k = y.yyyyy... = Y + n n &amp;lt;&amp;lt; k - n = Y n = Y/(2^k - 1) B.
(a).
y = 101, Y = 5, k = 3
n = 5/7
(b).
y = 0110, Y = 6, k = 4
n = 2/5
(c).
y = 010011, Y = 19, k = 6
n = 19/63</description></item><item><title>2.84</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.84/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.84/</guid><description>Thanks czy1996
/* * float-le.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; unsigned f2u(float x) { return *(unsigned*)&amp;amp;x; } int float_le(float x, float y) { unsigned ux = f2u(x); unsigned uy = f2u(y); unsigned sx = ux &amp;gt;&amp;gt; 31; unsigned sy = uy &amp;gt;&amp;gt; 31; // ref: https://github.com/DreamAndDead/CSAPP-3e-Solutions/issues/1 return (ux &amp;lt;&amp;lt; 1 == 0 &amp;amp;&amp;amp; uy &amp;lt;&amp;lt; 1 == 0) || /* both zeros */ (sx &amp;amp;&amp;amp; !sy) || /* x &amp;lt; 0, y &amp;gt;= 0 or x &amp;lt;= 0, y &amp;gt; 0 */ (!</description></item><item><title>2.85</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.85/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.85/</guid><description>bias = 2^(k-1) - 1
V = 2^E * M
A.
7.0 = 0b111.000&amp;hellip;
M = 0b1.11, f = 0b0.11, E = 2, e = bias + E, V = 7.0
bits
0 10....01 110.... B.
Assume bias &amp;raquo; n
bigest odd number, M must be 0b1.111111&amp;hellip;., f = 0b0.11111111&amp;hellip;(n bits 1)
E = n, V = 0b11111111&amp;hellip;(n+1 bits 1) = 2^(n+1) - 1
bits
0 bias+n 11111.... C.</description></item><item><title>2.86</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.86/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.86/</guid><description>bias = 2^(15-1) - 1
description binary decimal least positive unstandard 0 0000&amp;hellip;(15) 0 000&amp;hellip;(62)1 2^(1-bias-63) least positive standard 0 000&amp;hellip;(14)1 1 000&amp;hellip;.(63) 2^(1-bias) bigest standard 0 111&amp;hellip;(14)0 1 111&amp;hellip;(63) 2^bias * (2-2^-63)</description></item><item><title>2.87</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.87/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.87/</guid><description> Desc Hex M E V D -0 0x8000 0 -14 -0 -0.0 &amp;gt;2 least 0x4001 1025/1024 1 1025/512 2.00195312 512 0x6000 1 9 512 512.0 bigest denormalized 0x03FF 1023/1024 -14 1023/(2^24) 6.09755516e-5 - 0xFC00 - - - - ox3BB0 0x3BB0 123/64 -1 123/128 0.9609375</description></item><item><title>2.88</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.88/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.88/</guid><description> A bit A value B bit B value 1 01110 001 -9/16 1 0110 0010 -9/16 0 10110 101 13*2^4 0 1110 1010 13*2^4 1 00111 110 -7/2^10 1 0000 0111 -7/2^10 0 00000 101 5/2^11 0 0000 0001 1/2^10 1 11011 000 -2^12 1 1110 1111 -31*2^3 0 11000 100 3*2^8 0 1111 0000 +oo</description></item><item><title>2.89</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/</guid><description>/* * 2.89.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;lib/random.h&amp;#34; /* * most important thing is that all double number come from ints */ /* right */ int A(int x, double dx) { return (float)x == (float)dx; } /* wrong when y is INT_MIN */ int B(int x, double dx, int y, double dy) { return dx-dy == (double)(x-y); } /* right */ int C(double dx, double dy, double dz) { return (dx+dy)+dz == dx+(dy+dz); } /* * wrong * * FIXME I don&amp;#39;t know what conditions cause false */ int D(double dx, double dy, double dz) { return (dx*dy)*dz == dx*(dy*dz); } /* wrong when dx !</description></item><item><title>2.90</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.90/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.90/</guid><description>/* * fpwr2.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;math.h&amp;gt; float u2f(unsigned x) { return *(float*) &amp;amp;x; } /* 2^x */ float fpwr2(int x) { /* Result exponent and fraction */ unsigned exp, frac; unsigned u; if (x &amp;lt; 2-pow(2,7)-23) { /* too small. return 0.0 */ exp = 0; frac = 0; } else if (x &amp;lt; 2-pow(2,7)) { /* Denormalized result */ exp = 0; frac = 1 &amp;lt;&amp;lt; (unsigned)(x - (2-pow(2,7)-23)); } else if (x &amp;lt; pow(2,7)-1+1) { /* Normalized result */ exp = pow(2,7)-1+x; frac = 0; } else { /* Too big, return +oo */ exp = 0xFF; frac = 0; } /* pack exp and frac into 32 bits */ u = exp &amp;lt;&amp;lt; 23 | frac; /* Result as float */ return u2f(u); } int main(int argc, char* argv[]) { assert(fpwr2(0) == powf(2,0)); assert(fpwr2(100) == powf(2,100)); assert(fpwr2(-100) == powf(2,-100)); assert(fpwr2(10000) == powf(2,10000)); assert(fpwr2(-10000) == powf(2,-10000)); return 0; }</description></item><item><title>2.91</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.91/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.91/</guid><description>A.
0x40490FDB 0 10000000 10010010000111111011011 float number
0b11.0010010000111111011011 B.
ref 2.83
0b11.001001(001)... C.
9th</description></item><item><title>2.92</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.92/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.92/</guid><description>/* * float-negate.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-negate.h&amp;#34; float_bits float_negate(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) &amp;amp;&amp;amp; (frac != 0); if (is_NAN) { return f; } return ~sig &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.93</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.93/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.93/</guid><description>/* * float-absval.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-absval.h&amp;#34; float_bits float_absval(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) &amp;amp;&amp;amp; (frac != 0); if (is_NAN) { return f; } return 0 &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.94</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.94/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.94/</guid><description>/* * float-twice.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-twice.h&amp;#34; float_bits float_twice(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN_or_oo = (exp == 0xFF); if (is_NAN_or_oo) { return f; } if (exp == 0) { /* Denormalized */ frac &amp;lt;&amp;lt;= 1; } else if (exp == 0xFF - 1) { /* twice to oo */ exp = 0xFF; frac = 0; } else { /* Normalized */ exp += 1; } return sig &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.95</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.95/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.95/</guid><description>/* * float-half.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-half.h&amp;#34; float_bits float_half(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned rest = f &amp;amp; 0x7FFFFFFF; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; int is_NAN_or_oo = (exp == 0xFF); if (is_NAN_or_oo) { return f; } /* * round to even, we care about last 2 bits of frac * * 00 =&amp;gt; 0 just &amp;gt;&amp;gt;1 * 01 =&amp;gt; 0 (round to even) just &amp;gt;&amp;gt;1 * 10 =&amp;gt; 1 just &amp;gt;&amp;gt;1 * 11 =&amp;gt; 1 + 1 (round to even) just &amp;gt;&amp;gt;1 and plus 1 */ int addition = (frac &amp;amp; 0x3) == 0x3; if (exp == 0) { /* Denormalized */ frac &amp;gt;&amp;gt;= 1; frac += addition; } else if (exp == 1) { /* Normalized to denormalized */ rest &amp;gt;&amp;gt;= 1; rest += addition; exp = rest &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; frac = rest &amp;amp; 0x7FFFFF; } else { /* Normalized */ exp -= 1; } return sig &amp;lt;&amp;lt; 31 | exp &amp;lt;&amp;lt; 23 | frac; }</description></item><item><title>2.96</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.96/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.96/</guid><description>/* * float-f2i.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;float-f2i.h&amp;#34; /* * Compute (float) f * If conversion cause overflow or f is NaN, return 0x80000000 */ int float_f2i(float_bits f) { unsigned sig = f &amp;gt;&amp;gt; 31; unsigned exp = f &amp;gt;&amp;gt; 23 &amp;amp; 0xFF; unsigned frac = f &amp;amp; 0x7FFFFF; unsigned bias = 0x7F; int num; unsigned E; unsigned M; /* * consider positive numbers * * 0 00000000 00000000000000000000000 * ===&amp;gt; * 0 01111111 00000000000000000000000 * 0 &amp;lt;= f &amp;lt; 1 * get integer 0 * * 0 01111111 00000000000000000000000 * ===&amp;gt; * 0 (01111111+31) 00000000000000000000000 * 1 &amp;lt;= f &amp;lt; 2^31 * integer round to 0 * * 0 (01111111+31) 00000000000000000000000 * ===&amp;gt; * greater * 2^31 &amp;lt;= f &amp;lt; oo * return 0x80000000 */ if (exp &amp;gt;= 0 &amp;amp;&amp;amp; exp &amp;lt; 0 + bias) { /* number less than 1 */ num = 0; } else if (exp &amp;gt;= 31 + bias) { /* number overflow */ /* or f &amp;lt; 0 and (int)f == INT_MIN */ num = 0x80000000; } else { E = exp - bias; M = frac | 0x800000; if (E &amp;gt; 23) { num = M &amp;lt;&amp;lt; (E - 23); } else { /* whether sig is 1 or 0, round to zero */ num = M &amp;gt;&amp;gt; (23 - E); } } return sig ?</description></item><item><title>2.97</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.97/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.97/</guid><description>/* * float-i2f.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;float-i2f.h&amp;#34; /* * Assume i &amp;gt; 0 * calculate i&amp;#39;s bit length * * e.g. * 0x3 =&amp;gt; 2 * 0xFF =&amp;gt; 8 * 0x80 =&amp;gt; 8 */ int bits_length(int i) { if ((i &amp;amp; INT_MIN) != 0) { return 32; } unsigned u = (unsigned)i; int length = 0; while (u &amp;gt;= (1&amp;lt;&amp;lt;length)) { length++; } return length; } /* * generate mask * 00000.</description></item><item><title>3.58</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.58/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.58/</guid><description>/* * decode.c */ long decode(long x, long y, long z) { long tmp = y - z; return (tmp * x) ^ (tmp &amp;lt;&amp;lt; 63 &amp;gt;&amp;gt; 63); }</description></item><item><title>3.59</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.59/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.59/</guid><description>assume
multiple
2^128 overflows, so we don&amp;rsquo;t care about it
# void store_prod(int128_t* dest, int64_t x, int64_t y) # dest in %rdi, x in %rsi, y in %rdx store_prod: movq %rdx, %rax # %rax = y cqto # (int128_t)y, %rdx = (-1)y_63 movq %rsi, %rcx # %rcx = x # x &amp;gt;&amp;gt; 63, if x == 1, %rcx = -1; if x_63 == 0, %rcx = 0 # %rcx = (-1)x_63 sarq $63, %rcx # pay attention, imulq behaves differently according to param number(1/2) imulq %rax, %rcx # %rcx = y * -x_63 imulq %rsi, %rdx # %rdx = x * -y_63 addq %rdx, %rcx # %rcx = x * -y_63 + y * -x_63 mulq %rsi # %rdx:%rax &amp;lt;= ux * uy # lower 64 bits are same for x * y and ux * uy.</description></item><item><title>3.60</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.60/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.60/</guid><description>A.
val reg x %rdi n %esi result %rax mask %rdx B.
result = 0 mask = 1 C.
mask != 0 D.
mask = mask &amp;lt;&amp;lt; n E.
/* * loop2.c */ long loop2(long x, int n) { long result = 0; long mask; for (mask = 1; mask != 0; mask &amp;lt;&amp;lt;= n) { result |= (x &amp;amp; mask); } return result; }</description></item><item><title>3.61</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.61/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.61/</guid><description>function cread_alt should be
/* * cread-alt.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; long cread(long *xp) { return (xp ? *xp : 0); } long cread_alt(long *xp) { return (!xp ? 0 : *xp); } int main(int argc, char* argv[]) { long a = 0; assert(cread(&amp;amp;a) == cread_alt(&amp;amp;a)); assert(cread(NULL) == cread_alt(NULL)); return 0; } compile function cread in book sample and get
# long cread(long *xp) # xp in %rdi cread: movq (%rdi), %rax testq %rdi, %rdi movl $0, %edx cmove %rdx, %rax ret the result of compiling cread_alt may be</description></item><item><title>3.62</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.62/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.62/</guid><description>/* * 3.62.c */ /* Enumerated type creates set of contants numbered 0 and upward */ typedef enum { MODE_A, MODE_B, MODE_C, MODE_D, MODE_E } mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: *p1 = *p1 + *p2; result = *p1; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; result = 27; break; case MODE_E: result = 27; break; default: result = 12; break; } return result; }</description></item><item><title>3.63</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.63/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.63/</guid><description>/* * 3.63.c */ long switch_prob(long x, long n) { long result = x; switch(n) { /* Fill in code here */ case 60: case 62: result = x * 8; break; case 63: result = x &amp;gt;&amp;gt; 3; break; case 64: x = x &amp;lt;&amp;lt; 4 - x; case 65: x = x * x; default: result = x + 0x4B; } return result; }</description></item><item><title>3.64</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.64/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.64/</guid><description>A.
3.1 in book
T D[R][C]; &amp;amp;D[i][j] = Xd + L(C*i + j) T means type, D means data, R means row, C means column L means sizeof(T), Xd means address of D similarly, in 3d array
TYPE D[R][S][T] &amp;amp;D[i][j][k] = Xd + L(S*T*i + T*j + k) B.
.section .data .global A A: .fill 3640/8, 8, 121 # fill data 121 .section .text .global store_ele # long store_ele(long i, long j, long k, long *dest) # i in %rdi, j in %rsi, k in %rdx, dest in %rcx store_ele: leaq (%rsi, %rsi, 2), %rax # t1 = j*3 leaq (%rsi, %rax, 4), %rax # t1 = j*13 movq %rdi, %rsi # t2 = i salq $6, %rsi # t2 = i*64 addq %rsi, %rdi # t3 = i*65 addq %rax, %rdi # t3 = i*65 + j*13 addq %rdi, %rdx # t4 = i*65 + j*13 + k movq A(,%rdx,8), %rax # t1 = *(A + 8*t4) movq %rax, (%rcx) # *dest = t1 movl $3640, %eax # return 3640 ret base on comments,</description></item><item><title>3.65</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.65/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.65/</guid><description>A.
&amp;amp;A[i][j] in %rdx B.
&amp;amp;A[j][i] in %rax C.
addq $8, %rdx # means A[i][j] -&amp;gt; A[i][j+1] addq $120, %rax # means A[j][i] -&amp;gt; A[j+1][i], 120 == 8*M M = 15</description></item><item><title>3.66</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.66/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.66/</guid><description>.section .text .global sum_col # long sum_col(long n, long A[NR(n)][NC(n)], long j) # n in %rdi, A in %rsi, j in %rdx sum_col: leaq 1(,%rdi,4), %r8 # t1 = n*4 + 1 leaq (%rdi,%rdi,2), %rax # t2 = n*3 movq %rax, %rdi # t3 = n*3 testq %rax, %rax # test n*3 jle .L4 # n*3 &amp;lt;= 0, jump .L4 salq $3, %r8 # t1 = t1*8 = 8*(n*4 + 1) leaq (%rsi,%rdx,8), %rcx # t4 = j*8 + A movl $0, %eax # t2 = 0 movl $0, %edx # t5 = 0 .</description></item><item><title>3.67</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.67/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.67/</guid><description>3.67
/* * 3.67.c */ typedef struct { long a[2]; long *p; } strA; typedef struct { long u[2]; long q; } strB; strB process(strA a) { strB r; r.u[0] = s.a[1]; r.u[1] = s.a[0]; r.q = *s.p; return r; } long eval(long x, long y, long z) { strA s; s.a[0] = x; s.a[1] = y; s.p = &amp;amp;z; strB r = process(s); return r.u[0] + r.u[1] + r.q; } # strB process(strA s) # s in %rdi process: movq %rdi, %rax movq 24(%rsp), %rdx movq (%rdx), %rdx movq 16(%rsp), %rcx movq %rcx, (%rdi) movq 8(%rsp), %rcx movq %rcx, 8(%rdi) movq %rdx, 16(%rdi) ret # long eval(long x, long y, long z) # x in %rdi, y in %rsi, z in %rdx eval: subq $104, %rsp movq %rdx, 24(%rsp) leaq 24(%rsp), %rax movq %rdi, (%rsp) movq %rsi, 8(%rsp) movq %rax, 16(%rsp) leaq 64(%rsp), %rdi call process movq 72(%rsp), %rax addq 64(%rsp), %rax addq 80(%rsp), %rax addq $104, %rsp ret A.</description></item><item><title>3.68</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.68/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.68/</guid><description># void setVal(str1* p, str2* q) # p in %rdi, q in %rsi setVal: # 8(%rsi) fetch q-&amp;gt;t, int t is aligned by 4, so 4 &amp;lt; B &amp;lt;=8 movslq 8(%rsi), %rax # 32(%rsi) fetch q-&amp;gt;u, long u is aligned by 8 # offset q-&amp;gt;s is offset q-&amp;gt;t + 4, so 24 &amp;lt; 12 + A*2 &amp;lt;= 32 addq 32(%rsi), %rax # 184(%rdi) fetch p-&amp;gt;v, long y is aligned by 8, so 176 &amp;lt; A*B*4 &amp;lt;= 184 movq %rax, 184(%rdi) ret 4 &amp;lt; B &amp;lt;= 8 5 &amp;lt; A &amp;lt;= 10 44 &amp;lt; A*B &amp;lt;= 46 only</description></item><item><title>3.69</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.69/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.69/</guid><description>/* * 3.69.c */ typedef struct { int first; a_struct a[CNT]; int last; } b_struct; void test(long i, b_struct *bp) { int n = bp-&amp;gt;first + bp-&amp;gt;last; a_struct *ap = &amp;amp;bp-&amp;gt;a[i]; ap-&amp;gt;x[ap-&amp;gt;idx] = n; } # void test(long i, b_struct *bp) # i in %rdi, bp in %rsi test: mov 0x120(%rsi), %ecx # bp+0x120 fetch bp-&amp;gt;last add (%rsi), %ecx # bp-&amp;gt;first + bp-&amp;gt;last lea (%rdi,%rdi,4), %rax # i*5 lea (%rsi,%rax,8), %rax # bp+i*40 # ap = &amp;amp;bp-&amp;gt;a[i] = bp+i*40+8, +8 means skip int first # so a_struct is aligned by 8, size is 40 # check last instrction, %rdx here saves value ap-&amp;gt;idx!</description></item><item><title>3.70</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.70/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.70/</guid><description>A.
val offset e1.p 0 e1.y 8 e2.x 0 e2.next 8 B.
16
C.
# void proc(union ele *up) # up in %rdi proc: # %rax = *(up+8), don&amp;#39;t know it&amp;#39;s next or y movq 8(%rdi), %rax # %rdx = *( *(up+8) ), %rax stands for a pointer # so *( *(up+8) ) means *(up-&amp;gt;e2.</description></item><item><title>3.71</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.71/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.71/</guid><description>/* * good-echo.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#define BUF_SIZE 12 void good_echo(void) { char buf[BUF_SIZE]; while(1) { /* function fgets is interesting */ char* p = fgets(buf, BUF_SIZE, stdin); if (p == NULL) { break; } printf(&amp;#34;%s&amp;#34;, p); } return; } int main(int argc, char* argv[]) { good_echo(); return 0; }</description></item><item><title>3.72</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.72/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.72/</guid><description>/* * 3.72.c */ #include &amp;lt;alloca.h&amp;gt; long aframe(long n, long idx, long *q) { long i; long **p = alloca(n * sizeof(long*)); p[0] = &amp;amp;i; for (i = 1; i &amp;lt; n; i++) { p[i] = q; } return *p[idx]; } # long aframe(long n, long idx, long *q) # n in %rdi, idx in %rsi, q in %rdx aframe: pushq %rbp movq %rsp, %rbp subq $16, %rsp leaq 30(,%rdi,8), %rax andq $-16, %rax subq %rax, %rsp leaq 15(%rsp), %r8 andq $-16, %r8 A.</description></item><item><title>3.73</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.73/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.73/</guid><description>/* * 3.73.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x) { __asm__( &amp;#34;vxorps %xmm1, %xmm1, %xmm1\n\t&amp;#34; &amp;#34;vucomiss %xmm1, %xmm0\n\t&amp;#34; &amp;#34;jp .P\n\t&amp;#34; &amp;#34;ja .A\n\t&amp;#34; &amp;#34;jb .B\n\t&amp;#34; &amp;#34;je .E\n\t&amp;#34; &amp;#34;.A:\n\t&amp;#34; &amp;#34;movl $2, %eax\n\t&amp;#34; &amp;#34;jmp .Done\n\t&amp;#34; &amp;#34;.B:\n\t&amp;#34; &amp;#34;movl $0, %eax\n\t&amp;#34; &amp;#34;jmp .Done\n\t&amp;#34; &amp;#34;.E:\n\t&amp;#34; &amp;#34;movl $1, %eax\n\t&amp;#34; &amp;#34;jmp .Done\n\t&amp;#34; &amp;#34;.P:\n\t&amp;#34; &amp;#34;movl $3, %eax\n\t&amp;#34; &amp;#34;.Done:\n\t&amp;#34; ); } int main(int argc, char* argv[]) { range_t n = NEG, z = ZERO, p = POS, o = OTHER; assert(o == find_range(0.</description></item><item><title>3.74</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.74/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.74/</guid><description>/* * 3.74.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x) { __asm__( &amp;#34;vxorps %xmm1, %xmm1, %xmm1\n\t&amp;#34; &amp;#34;movq $1, %rax\n\t&amp;#34; &amp;#34;movq $2, %r8\n\t&amp;#34; &amp;#34;movq $0, %r9\n\t&amp;#34; &amp;#34;movq $3, %r10\n\t&amp;#34; &amp;#34;vucomiss %xmm1, %xmm0\n\t&amp;#34; &amp;#34;cmovaq %r8, %rax\n\t&amp;#34; &amp;#34;cmovbq %r9, %rax\n\t&amp;#34; &amp;#34;cmovpq %r10, %rax\n\t&amp;#34; ); } int main(int argc, char* argv[]) { range_t n = NEG, z = ZERO, p = POS, o = OTHER; assert(o == find_range(0.</description></item><item><title>3.75</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.75/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.75/</guid><description>A.
param n real img 1 %xmm0 %xmm1 2 %xmm2 %xmm3 3 %xmm4 %xmm5 n &amp;hellip; &amp;hellip; B.
return %xmm0 as real part, %xmm1 as img part</description></item><item><title>4.45</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.45/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.45/</guid><description>subq $8, %rsp movq REG, (%rsp) A.
No
if REG is %rsp, we push %rsp-8 instead of %rsp into stack
B.
movq REG, -8(%rsp) subq $8, %rsp</description></item><item><title>4.46</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.46/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.46/</guid><description>movq (%rsp), REG addq $8, %rsp A.
No
if REG is %rsp, movq (%rsp), REG pop the right value into %rsp, but addq $8, %rsp modify it
B.
addq $8, %rsp movq 8(%rsp), REG</description></item><item><title>4.47</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.47/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.47/</guid><description>A.
Change into pointer version
/* * bubble-sort-pointer.c */ void bubble_p(long* data, long count) { long *i, *last; for (last = data+count-1; last &amp;gt; data; last--) { for (i = data; i &amp;lt; last; i++) { if (*(i+1) &amp;lt; *i) { /* swap adjacent elements */ long t = *(i+1); *(i+1) = *i; *i = t; } } } } B.
Compile bubble-sort-pointer.c
gcc -S -Og bubble-sort-pointer.c get gas file</description></item><item><title>4.48</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.48/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.48/</guid><description>a little easy changes.
/* bubble-sort-pointer.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 data: .quad 0x0000000000000004 .quad 0x0000000000000003 .quad 0x0000000000000002 data_end: .quad 0x0000000000000001 main: irmovq data,%rdi irmovq data_end,%rsi call ysBubbleP ret # long ys_bubble_p(long *data, long *end) # data in %rdi, end in %rsi ysBubbleP: jmp L2 L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 ############################################################## # begin differences ############################################################## cmovl %r9, %r11 cmovl %r10, %r9 cmovl %r11, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax) ############################################################## # end ############################################################## irmovq $8, %r8 addq %r8, %rax jmp L5 L6: rrmovq %rdi, %rax L5: rrmovq %rsi, %r8 subq %rax, %r8 jg L4 irmovq $8, %r8 subq %r8, %rsi L2: rrmovq %rsi, %r8 subq %rdi, %r8 jg L6 ret .</description></item><item><title>4.49</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.49/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.49/</guid><description>it&amp;rsquo;s a brilliant idea, 3 xor is a normal swap
if x = 9, y = 10
x = x ^ y x:9^10; y:10 y = x ^ y x:9^10; y:9 x = x ^ y x:10; y:9 if change y after step 1
tmp = x x:9; y:10; tmp:9 # store x x = x ^ y x:9^10; y:10 y = tmp x:9^10; y:9 # set y to origin x y = x ^ y x:9^10; y:10 x = x ^ y x:9; y:10 no swap happens.</description></item><item><title>4.50</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.50/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.50/</guid><description>/* switch.ys */ .pos 0 irmovq stack, %rsp call main halt # Array of 4 elements .align 8 array: .quad 0x0000000000000000 .quad 0x0000000000000000 .quad 0x0000000000000000 .quad 0x0000000000000000 main: # test number 1, -1, 3, 5 irmovq array, %r10 irmovq $1,%rdi call switchv rmmovq %rax, (%r10) irmovq $-1,%rdi call switchv rmmovq %rax, 8(%r10) irmovq $3,%rdi call switchv rmmovq %rax, 16(%r10) irmovq $5,%rdi call switchv rmmovq %rax, 24(%r10) ret table: .quad LD # default branch .</description></item><item><title>4.51</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.51/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.51/</guid><description> phase iaddq V,rB F icode:ifun = M1[PC]; rA:rB = M1[PC+1]; valC = M8[PC+2]; valP = PC + 10; D valB = R[rB] E valE = valB + valC; set CC M W R[rB] = valE PC PC = valP</description></item><item><title>4.52</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.52/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.52/</guid><description>easy changes if you make 4.51 right.
check whole file ./chapter4/code/sim/seq/seq-full.hcl with iaddq functionality
only watch changes with origin seq-full.hcl file
(cd ./site/content/chapter4/code/sim/seq; diff -u origin-seq-full.hcl seq-full.hcl) --- origin-seq-full.hcl 2021-02-25 07:26:33.312592690 +0000 +++ seq-full.hcl 2021-02-25 07:26:33.312592690 +0000 @@ -107,16 +107,16 @@ bool instr_valid = icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, - IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; + IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ }; # Does fetched instruction require a regid byte?</description></item><item><title>4.53</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.53/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.53/</guid><description>1. data hazard something handled by data-forward must be handled by stall if no data-forward anymore. so when
d_srcA in { e_dstE, M_dstM, M_dstE, W_dstM, W_dstE } || d_srcB in { e_dstE, M_dstM, M_dstE, W_dstM, W_dstE } data hazard happens, we have to insert bubble in phase E and stall phase F&amp;amp;D
load/use hazard
load/use hazard only happens when we use data-forward. no load/use hazard if no data-forward.
pay attention</description></item><item><title>4.54</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.54/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.54/</guid><description>almost same like 4.51 seq-full.hcl
check file ./site/content/chapter4/code/sim/pipe/pipe-full.hcl with iaddq functionality
watch changes with origin pipe-full.hcl file
(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-full.hcl pipe-full.hcl) --- origin-pipe-full.hcl 2021-02-25 07:26:33.309259378 +0000 +++ pipe-full.hcl 2021-02-25 07:26:33.309259378 +0000 @@ -158,7 +158,7 @@ # Is instruction valid? bool instr_valid = f_icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, - IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; + IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ }; # Determine status code for fetched instruction word f_stat = [ @@ -171,11 +171,11 @@ # Does fetched instruction require a regid byte?</description></item><item><title>4.55</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.55/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.55/</guid><description>Problem mismatch with skeleton code, we follow the code here: change J_YES to UNCOND
one point is
M_icode == IJXX &amp;amp;&amp;amp; M_ifun != UNCOND means all jxx except jmp instruction
another important point is Mispredicted branch condition
origin
(E_icode == IJXX &amp;amp;&amp;amp; !e_Cnd) now
(E_icode == IJXX &amp;amp;&amp;amp; E_ifun != UNCOND &amp;amp;&amp;amp; e_Cnd) if e_Cnd means misprediction
check file ./site/content/chapter4/code/sim/pipe/pipe-nt.hcl
watch changes with origin pipe-nt.hcl
(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-nt.</description></item><item><title>4.56</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.56/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.56/</guid><description>Problem mismatch with skeleton code, we follow the code here: change J_YES to UNCOND
almost same like 4.55. main differences are
pay attention to whether valC is greater or lower than valP pass both valC and valP back by M registers because if misprediction happens we need judge jumping back to valC or valP check file ./site/content/chapter4/code/sim/pipe/pipe-btfnt.hcl
only watch changes with origin pipe-btfnt.hcl
(cd ./site/content/chapter4/code/sim/pipe; diff -u origin-pipe-btfnt.hcl pipe-btfnt.</description></item><item><title>4.57</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.57/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.57/</guid><description>A.
consider load/use hazard
E_icode in { IMRMOVQ, IPOPQ } &amp;amp;&amp;amp; E_dstM in { d_srcA, d_srcB }; situation 1 2 3 4 E_dstM == d_srcA 1 1 0 0 E_dstM == d_srcB 1 0 1 0 situation 4:
normal, no hazard happens
situation 1,2,3:
load/use hazard happens
if E_icode in { IMRMOVQ, IPOPQ }, then E_dstM must not be RNONE</description></item><item><title>4.58</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.58/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.58/</guid><description>it&amp;rsquo;s not a hard problem, focus on key points:
fetch popq instruction twice. first time fetch popq, works like iaddq; second time fetch popq2, works like mrmovq load/use condition should be popq2 not popq. phase popq rA popq2 rA works like iadd $8, %rsp mrmovq -8(%rsp), rA F valP = PC valP = PC + 2 D valB=R[rsp] valB=R[rsp] E valE=valB+8 valE=valB-8 M valM=M8[valE] W R[rsp]=valE R[rA]=valM check file .</description></item><item><title>4.59</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.59/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter4/4.59/</guid><description>4.47 is the better one
loop part in 4.47
L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 jge L3 rmmovq %r10, 8(%rax) rmmovq %r9, (%rax) 50% jge is right, run 5 instructions; 50% jge is wrong, run 7 instructions and 2 nop bubble. so Cycles Per Loop is 50% * 5 + (7 + 2) * 50% = 7
loop part in 4.48
L4: mrmovq 8(%rax), %r9 mrmovq (%rax), %r10 rrmovq %r9, %r8 subq %r10, %r8 cmovl %r9, %r11 cmovl %r10, %r9 cmovl %r11, %r10 rmmovq %r9, 8(%rax) rmmovq %r10, (%rax) Cycles Per Loop is 9</description></item><item><title>5.13</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.13/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.13/</guid><description>A.
+----+----+----+----+-----+-----+ |%rbp|%rcx|%rax|%rbx|%xmm1|%xmm0| +----+----+----+----+-----+-----++----+ +----|----|----|----------|---&amp;gt;| | | +----|----|----------|---&amp;gt;|load| vmovad 0(%rbp,%rcx,8),%xmm1 | | | | +-----|----| | | | | | | | +----+ | +----|----|----------|---&amp;gt;| | | | | | | | |load|---+ | | +----|----------|---&amp;gt;| | | | | | | | | +----+ | vmulsd (%rax,%rcx,8),%xmm1,%xmm0 | | | | | | | |&amp;lt;--+ | | | | +-----|---&amp;gt;|mul | | | | | +-----|----| | | | | | | | +----+ | | | | +-----|---&amp;gt;| | | | | | | +---&amp;gt;|add | vaddsd %xmm1,%xmm0,%xmm0 | | | | | +----| | | | | | | | +----+ | +----|----|----------|---&amp;gt;| | | | | | | |add | addq $1, %rcx | +----|----|----------|----| | | | | | | | +----+ | +----|----|----------|---&amp;gt;| | | | | | | | |cmp |---+ cmpq %rbx, %rcx | | | +----|-----|---&amp;gt;| | | | | | | | | +----+ | | | | | | | | | | | | | | | | |jne |&amp;lt;--+ jne .</description></item><item><title>5.14</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.14/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.14/</guid><description>+----+ +----+ |sum | | i | +----+ +----+ | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | v | +----+ +----+ +----+ | |add |&amp;lt;------|mul |&amp;lt;-|load|&amp;lt;------+ +----+ +----+ +----+ | | | | v | +----+ | |add | | &amp;lt;------- key path +----+ | | | | v v +----+ +-+--+ |sum | | i | +----+ +----+ A.</description></item><item><title>5.15</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.15/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.15/</guid><description>maybe
float mul capatity limit(less than 6) register renaming limit /* * 5.15.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;./lib/vec.h&amp;#34; #define LEN 24 /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; data_t sum1 = (data_t) 0; data_t sum2 = (data_t) 0; data_t sum3 = (data_t) 0; data_t sum4 = (data_t) 0; data_t sum5 = (data_t) 0; for (i = 0; i &amp;lt; length-6; i+=6) { sum = sum + udata[i] * vdata[i]; sum1 = sum1 + udata[i+1] * vdata[i+1]; sum2 = sum2 + udata[i+2] * vdata[i+2]; sum3 = sum3 + udata[i+3] * vdata[i+3]; sum4 = sum4 + udata[i+4] * vdata[i+4]; sum5 = sum5 + udata[i+5] * vdata[i+5]; } for(; i &amp;lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum + sum1 + sum2 + sum3 + sum4 + sum5; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[11] = 1; arr[2] = 2; arr[23] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, &amp;amp;res); assert(res == 1+4+9); return 0; }</description></item><item><title>5.16</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.16/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.16/</guid><description>/* * 5.16.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;./lib/vec.h&amp;#34; #define LEN 24 /* inner product. accumulate in temporary */ void inner4(vec_ptr u, vec_ptr v, data_t *dest) { long i; long length = vec_length(u); data_t *udata = get_vec_start(u); data_t *vdata = get_vec_start(v); data_t sum = (data_t) 0; for (i = 0; i &amp;lt; length-6; i+=6) { sum = sum + ( udata[i] * vdata[i] + udata[i+1] * vdata[i+1] + udata[i+2] * vdata[i+2] + udata[i+3] * vdata[i+3] + udata[i+4] * vdata[i+4] + udata[i+5] * vdata[i+5] ); } for(; i &amp;lt; length; i++) { sum = sum + udata[i] * vdata[i]; } *dest = sum; } int main(int argc, char* argv[]) { vec_ptr u = new_vec(LEN); vec_ptr v = new_vec(LEN); data_t *arr = (data_t*) malloc(sizeof(data_t) * LEN); memset(arr, 0, sizeof(data_t) * LEN); arr[0] = 0; arr[11] = 1; arr[2] = 2; arr[23] = 3; set_vec_start(u, arr); set_vec_start(v, arr); data_t res; inner4(u, v, &amp;amp;res); assert(res == 1+4+9); return 0; }</description></item><item><title>5.17</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.17/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.17/</guid><description>/* * 5.17.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;assert.h&amp;gt; void* basic_memset(void *s, int c, size_t n) { size_t cnt = 0; unsigned char *schar = s; while (cnt &amp;lt; n) { *schar++ = (unsigned char) c; cnt++; } return s; } /* * K = sizeof(unsigned long) * cs store K chars for memset */ void* effective_memset(void *s, unsigned long cs, size_t n) { /* align to K */ size_t K = sizeof(unsigned long); size_t cnt = 0; unsigned char *schar = s; while (cnt &amp;lt; n) { if ((size_t)schar % K == 0) { break; } *schar++ = (unsigned char)cs; cnt++; } /* set K chars one time */ unsigned long *slong = (unsigned long *)schar; size_t rest = n - cnt; size_t loop = rest / K; size_t tail = rest % K; for (size_t i = 0; i &amp;lt; loop; i++) { *slong++ = cs; } /* pad the tail part */ schar = (unsigned char *)slong; for (size_t i = 0; i &amp;lt; tail; i++) { *schar++ = (unsigned char)cs; } return s; } int main(int argc, char* argv[]) { size_t space = sizeof(char) * 65537; // careful!</description></item><item><title>5.18</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.18/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.18/</guid><description>try to write 6*3a version for function holy.
this solution is not fully tested on my machine, sorry for that :(
uname -p Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz
if your machine core is Intel Core i7 Haswell like book, you can try install google gperftools for profile
(cd ./site/content/chapter5/code; make 5.18.prof) loop more times is a good idea :)
/* * 5.18.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.</description></item><item><title>5.19</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.19/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter5/5.19/</guid><description>this solution&amp;rsquo;s performance is not fully meassured.
if you&amp;rsquo;re interested, you can try install google&amp;rsquo;s gperftools for profile
(cd ./site/content/chapter5/code; make 5.19.prof) loop more times is a good idea :)
/* * 5.19.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; void psum1a(float a[], float p[], long n) { long i; float last_val, val; last_val = p[0] = a[0]; for (i = 1; i &amp;lt; n; i++) { val = last_val + a[i]; p[i] = val; last_val = val; } } /* version 4*1a */ void psum_4_1a(float a[], float p[], long n) { long i; float val, last_val; float tmp, tmp1, tmp2, tmp3; last_val = p[0] = a[0]; for (i = 1; i &amp;lt; n - 4; i++) { tmp = last_val + a[i]; tmp1 = tmp + a[i+1]; tmp2 = tmp1 + a[i+2]; tmp3 = tmp2 + a[i+3]; p[i] = tmp; p[i+1] = tmp1; p[i+2] = tmp2; p[i+3] = tmp3; /* key point */ last_val = last_val + (a[i] + a[i+1] + a[i+2] + a[i+3]); } for (; i &amp;lt; n; i++) { last_val += a[i]; p[i] = last_val; } } #define LOOP 1000 #define LEN 1000 int main(int argc, char* argv[]) { float a[5] = { 1, 2, 3, 4, 5 }; float p[5]; psum1a(a, p, 5); assert(p[4] == 15); float q[5]; psum_4_1a(a, q, 5); assert(q[4] == 15); /* for prof */ for (int i = 0; i &amp;lt; LOOP; i++) { float s[LEN]; float d[LEN]; psum1a(s, d, LEN); psum_4_1a(s, d, LEN); } return 0; }</description></item><item><title>6.22</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.22/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.22/</guid><description>assume
Bits Per Track
bpt = x * r * K Track Count
tc = (1-x) * r * M M, K are constant
so
Bit Count
bc = K * M * r^2 * (1-x) * x when x == 1/2, bc is maximum</description></item><item><title>6.23</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.23/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.23/</guid><description>T_avg_seek = 4ms
T_avg_rotation = 1/2 * 1/15000 * 60s/min * 1000ms/s = 2ms
T_avg_transfer = 1/15000 * 1/800 * 60s/min * 1000ms/s = 0.005ms
so
T_access = 6.005ms</description></item><item><title>6.24</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.24/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.24/</guid><description>almost same like problem 6.4 on book
A.
best case: blocks are mapped sequential and on same cylinder. just seek data once.
T_avg_seek = 4ms T_avg_rotation = 2ms file size 2MB, block size 512B, block count 2MB/512B = 4000
Block Per Track = 1000, so we need rotate 4 loop to read all data
T_transfer = T_rotation = T_max_rotation * 4 = 16ms so
T_access = 22ms B.</description></item><item><title>6.25</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.25/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.25/</guid><description> m c B E S t s b 32 1024 4 4 64 24 6 2 32 1024 4 256 1 30 0 2 32 1024 8 1 128 22 7 3 32 1024 8 128 1 29 0 3 32 1024 32 1 32 22 5 5 32 1024 32 4 8 24 3 5</description></item><item><title>6.26</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.26/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.26/</guid><description> m c B E S t s b 32 2048 8 1 256 21 8 3 32 2048 4 4 128 23 7 2 32 1024 2 8 64 25 6 1 32 1024 32 2 16 23 4 5</description></item><item><title>6.27</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.27/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.27/</guid><description>A.
t = 0x45 = 0b01000101, s = 0b001, b = xx(xx is 00/01/10/11)
address may be
01000101 001 xx format 0 1000 1010 01xx address range: 0x08A4 - 0x08A7
t = 0x38
address range: 0x0704 - 0x0707
B.
0x1238 - 0x123B</description></item><item><title>6.28</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.28/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.28/</guid><description>same like 6.27
A.
None
B.
0x18F0 - 0x18F3
0x00B0 - 0x00B3
C.
0x0E34 - 0x0E37
D.
0x1BDC - 0x1BDF</description></item><item><title>6.29</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.29/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.29/</guid><description>A.
11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+ | CT | CT | CT | CT | CT | CT | CT | CT | CI | CI | CO | CO | +----+----+----+----+----+----+----+----+----+----+----+----+ B.
read/write addr hit? value(or unknown) read 0x834 No - write 0x836 Yes unknown read 0xFFD Yes 0xC0</description></item><item><title>6.30</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.30/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.30/</guid><description>A.
C = E * B * S = 128B
B.
12 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+----+ | CT | CT | CT | CT | CT | CT | CT | CT | CI | CI | CI | CO | CO | +----+----+----+----+----+----+----+----+----+----+----+----+----+</description></item><item><title>6.31</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.31/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.31/</guid><description>A.
12 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+----+ | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 0 | +----+----+----+----+----+----+----+----+----+----+----+----+----+ B.
param value CO 0x02 CI 0x06 CT 0x38 hit? Yes return 0xEB</description></item><item><title>6.32</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.32/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.32/</guid><description>A.
12 11 10 9 8 7 6 5 4 3 2 1 0 +----+----+----+----+----+----+----+----+----+----+----+----+----+ | 1 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | +----+----+----+----+----+----+----+----+----+----+----+----+----+ B.
param value CO 0x00 CI 0x02 CT 0xB7 hit? No return &amp;ndash;</description></item><item><title>6.33</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.33/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.33/</guid><description>same like 6.27
0x1788 - 0x178B
0x16C8 - 0x16CB</description></item><item><title>6.34</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.34/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.34/</guid><description>src:
c0 c1 c2 c3 r0 m m h m r1 m h m h r2 m m h m r3 m h m h dst:
c0 c1 c2 c3 r0 m m m m r1 m m m m r2 m m m m r3 m m m m</description></item><item><title>6.35</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.35/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.35/</guid><description>src:
c0 c1 c2 c3 r0 m h h h r1 m h h h r2 m h h h r3 m h h h dst:
c0 c1 c2 c3 r0 m h h h r1 m h h h r2 m h h h r3 m h h h</description></item><item><title>6.36</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.36/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.36/</guid><description>int x[2][128]; int i; int sum = 0; for (i = 0; i &amp;lt; 128; i++) { sum += x[0][i] * x[1][i]; } A.
C = 512, E = 1, B = 16, S = 32
total read count: 2 * 128
x[0][i] address: i*4
x[1][i] address: (128+i)4 = 512 + i4
so x[0][i] and x[1][i] are cached into same block.
miss rate 100%
B.
C = 1024, E = 1, B = 16, S = 64</description></item><item><title>6.37</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.37/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.37/</guid><description>/* * 6.37.c */ typedef int array_t[N][N]; int sumA(array_t a) { int i, j; int sum = 0; for (i = 0; i &amp;lt; N; i++) for (j = 0; j &amp;lt; N; j++) sum += a[i][j]; return sum; } int sumB(array_t a) { int i, j; int sum = 0; for (i = 0; i &amp;lt; N; i++) for (j = 0; j &amp;lt; N; j++) sum += a[j][i]; return sum; } int sumC(array_t a) { int i, j; int sum = 0; for (i = 0; i &amp;lt; N; i+=2) for (j = 0; j &amp;lt; N; j+=2) sum += (a[j][i] + a[j][i+1] + a[j+1][i] + a[j+1][i+1]) } C = 4096, B = 16, E = 1, S = 256</description></item><item><title>6.38</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.38/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.38/</guid><description>A.
4 * 16 * 16
B.
sizeof(point_color) == 16, B = 32
square[i][j].c = 0 miss, cache 2 point_color, then
square[i][j].m = 0 square[i][j].y = 0 square[i][j].k = 0 square[i][j+1].c = 0 square[i][j+1].m = 0 square[i][j+1].y = 0 square[i][j+1].k = 0 all hit
so miss count is 4 * 16 * 16 * 1/8
C.
1/8</description></item><item><title>6.39</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.39/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.39/</guid><description>A.
4 * 16 * 16
B.
sizeof(point_color) == 16, B = 32
square[j][i].c = 0 miss, cache 2 point_color, then
square[j][i].m = 0 square[j][i].y = 0 square[j][i].k = 0 all hit.
next loop
square[j+1][i] - square[j][i] == 16*16 == 256 square[j+1][i] miss, cache block not conflict with square[j][i]
square[j+8][i] - square[j][i] == 16*16*8 == 2048 square[j+8][i] miss, cache block overwrite square[j][i] block. so when we reach square[j][i+1], still miss.</description></item><item><title>6.40</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.40/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.40/</guid><description>A.
4 * 16 * 16
B.
first loop, same like 6.38, but
write count is 16*16, miss rate is 1/2.
second loop, same like 6.39, but
write count is 16163, miss rate is 1/6.
miss count is
16161/2 + 16163*1/6
C.
1/4</description></item><item><title>6.41</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.41/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.41/</guid><description>every loop
buffer[i][j].r = 0; always miss, then cache one piexl, so
buffer[i][j].g = 0; buffer[i][j].b = 0; buffer[i][j].a = 0; all hit
miss rate is 1/4</description></item><item><title>6.42</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.42/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.42/</guid><description>same like
for (i = 0; i &amp;lt; 640; i++) for (j = 0; j &amp;lt; 480; j++) buffer[i][j].r = 0; buffer[i][j].g = 0; buffer[i][j].b = 0; buffer[i][j].a = 0; C = 64KB, B = 4B, sizeof(piexl) = 4
buffer[i][j].r = 0; miss, cache one piexl, so
buffer[i][j].g = 0; buffer[i][j].b = 0; buffer[i][j].a = 0; all hit
miss rate is 1/4</description></item><item><title>6.43</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.43/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.43/</guid><description>same like
for (i = 0; i &amp;lt; 640; i++) for (j = 0; j &amp;lt; 480; j++) (int*)&amp;amp;buffer[i][j] = 0; every loop,
(int*)&amp;amp;buffer[i][j] = 0; always miss
miss rate 100%</description></item><item><title>6.44</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.44/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.44/</guid><description>download mountain program from here
I&amp;rsquo;ve download it into chapter6/code dir
run
(cd ./site/content/chapter6/code/mountain; ./mountain) see result
Clock frequency is approx. 2500.0 MHz Memory mountain (MB/sec) s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 128m 12824 7552 5119 3776 2981 2452 2080 1799 1663 1563 1483 1410 1372 1334 1304 64m 12880 7575 5121 3790 2976 2456 2079 1797 1663 1563 1489 1415 1366 1333 1302 32m 12849 7635 5137 3785 2996 2456 2075 1795 1671 1570 1486 1419 1372 1321 1299 16m 12906 7656 5174 3826 3000 2504 2090 1808 1700 1579 1506 1442 1397 1373 1357 8m 13045 7832 5321 4072 3121 2577 2194 1885 1787 1706 1663 1633 1622 1621 1703 4m 13303 8352 5602 4210 3326 2765 2352 2033 1931 1859 1824 1812 1817 1906 2076 2m 16265 11003 9150 7368 6024 5014 4310 3816 3795 3761 3848 3877 3909 3946 4044 1024k 16708 11597 10180 8150 6605 5544 4772 4169 4109 4150 4136 4127 4113 4127 4119 512k 16674 11613 10179 8160 6595 5543 4787 4182 4245 4242 4300 4360 4416 4508 4668 256k 16929 12872 11826 10661 8538 7360 6383 5724 6516 6951 7181 7297 7041 7634 7768 128k 16992 15381 14141 13145 12497 11444 10028 9734 9642 9638 9671 9696 9606 9438 9117 64k 17109 15238 14163 13563 12263 11302 9736 9412 9175 9162 9239 9200 9267 9229 12245 32k 18060 17655 17503 16954 16785 16489 16718 14382 16135 16512 16471 15799 14318 16250 15337 16k 17809 17534 17326 16516 16783 16406 16250 13333 14043 15280 13890 12546 13347 12394 17062</description></item><item><title>6.45</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.45/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.45/</guid><description>assume matrix size N = 4, cache block size B = 8Byte, sizeof(int) = 4
matrix size 4*4 +--+--+--+--+ |0 |1 |2 |3 | +--+--+--+--+ |4 |5 |6 |7 | +--+--+--+--+ |8 |9 |10|11| +--+--+--+--+ |12|13|14|15| +--+--+--+--+ function transponse
void transpose(int* dst, int* src, int N) { int i, j; for (i = 0; i &amp;lt;= N-1; i++) for (j = 0; j &amp;lt;= N-1; j++) dst[j*N+i] = src[i*N+j]; } every cache block can store 2 int numbers</description></item><item><title>6.46</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.46/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter6/6.46/</guid><description>same like 6.45, pay attention to brilliant comment :)
/* * convert.c */ #include &amp;lt;assert.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;time.h&amp;gt; // a large prime number #define MATRIX_N 9973 #define MEM_SIZE (sizeof(int) * MATRIX_N * MATRIX_N) #define LOOP 1000 #define BLOCK 16 void randomize(int *arr, int N) { srand(time(0)); int i, j; for (i = 0; i &amp;lt;= N - 1; i++) for (j = 0; j &amp;lt;= N - 1; j++) arr[i * N + j] = rand() % 2; } void convert(int *src, int N) { int i, j; for (i = 0; i &amp;lt;= N - 1; i++) for (j = 0; j &amp;lt;= N - 1; j++) src[j * N + i] = src[i * N + j] || src[j * N + i]; } void effective_convert(int *src, int N) { int i, j, a, b, tmp; for (i = 0; i &amp;lt;= N - BLOCK; i += BLOCK) /* not j = 0 here */ for (j = i; j &amp;lt;= N - BLOCK; j += BLOCK) for (a = i; a &amp;lt; i + BLOCK; a++) for (b = j; b &amp;lt; j + BLOCK; b++) { /* brilliant!</description></item><item><title>8.10</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.10/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.10/</guid><description>A. call once, return twice
fork
B. call once, never return
longjmp, execve
C. call once, return 1 or more times
setjmp</description></item><item><title>8.11</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.11/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.11/</guid><description>4 lines
c +-------+ | &amp;quot;hello&amp;quot; | c | p +-------+-------+ | fork &amp;quot;hello&amp;quot; | | c | +-------+ | | &amp;quot;hello&amp;quot; | | | p | p +------+-------+-------+ main fork fork &amp;quot;hello&amp;quot;</description></item><item><title>8.12</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.12/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.12/</guid><description>8 lines
c +-------+---------+ | &amp;quot;hello&amp;quot; &amp;quot;hello&amp;quot; | c | p +-------+-------+---------+ | fork &amp;quot;hello&amp;quot; &amp;quot;hello&amp;quot; | | c | +-------+---------+ | | &amp;quot;hello&amp;quot; &amp;quot;hello&amp;quot; | | | p | p +------+-------+-------+---------+ main fork fork &amp;quot;hello&amp;quot; &amp;quot;hello&amp;quot;</description></item><item><title>8.13</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.13/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.13/</guid><description>x=4 x=3 x=2 pay attention, parent process and child process don&amp;rsquo;t share global x, they have own private x.</description></item><item><title>8.14</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.14/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.14/</guid><description>3 lines
c +-------+ | &amp;quot;hello&amp;quot; | c | p +-------+-------+ | fork &amp;quot;hello&amp;quot; | | p +------+-------+-------+ main fork return &amp;quot;hello&amp;quot;</description></item><item><title>8.15</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.15/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.15/</guid><description>5 lines
c +-------+---------+ | &amp;quot;hello&amp;quot; &amp;quot;hello&amp;quot; | c | p +-------+-------+---------+ | fork &amp;quot;hello&amp;quot; &amp;quot;hello&amp;quot; | | | p +------+-------+-------+ main fork return &amp;quot;hello&amp;quot;</description></item><item><title>8.16</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.16/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.16/</guid><description>counter = 2 child process has its own counter.</description></item><item><title>8.17</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.17/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.17/</guid><description>hello 0 1 Bye 2 Bye hello 1 0 Bye 2 Bye hello 1 Bye 0 2 Bye</description></item><item><title>8.18</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.18/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.18/</guid><description>c +-------+---------+ | &amp;quot;0&amp;quot; exit &amp;quot;2&amp;quot; | c | p +-------+-------+---------+ | fork &amp;quot;1&amp;quot; exit &amp;quot;2&amp;quot; | (atexit) | c | +-------+---------+ | | &amp;quot;0&amp;quot; exit | | | p | p +------+-------+-------+---------+ main fork fork &amp;quot;1&amp;quot; exit 2 must be behind 0/1
B &amp;amp; D is impossible.</description></item><item><title>8.19</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.19/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.19/</guid><description>2^n</description></item><item><title>8.20</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.20/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.20/</guid><description>/* * 8.20.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; int main(int argc, char* argv[], char* env[]) { if (execve(&amp;#34;/bin/ls&amp;#34;, argv, env) == -1) { fprintf(stderr, &amp;#34;execve error: %s\n&amp;#34;, strerror(errno)); exit(1); } }</description></item><item><title>8.21</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.21/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.21/</guid><description>abc or
bac</description></item><item><title>8.22</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.22/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.22/</guid><description>/* * mysystem.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; int mysystem(char* command) { pid_t pid; int status; if ((pid = Fork()) == 0) { /* child process */ char* argv[4] = { &amp;#34;&amp;#34;, &amp;#34;-c&amp;#34;, command, NULL }; execve(&amp;#34;/bin/sh&amp;#34;, argv, environ); } /* print child pid so we can kill it */ printf(&amp;#34;child pid: %d\n&amp;#34;, pid); if (Waitpid(pid, &amp;amp;status, 0) &amp;gt; 0) { /* exit normally */ if (WIFEXITED(status)) return WEXITSTATUS(status); /* exit by signal */ if (WIFSIGNALED(status)) return WTERMSIG(status); } } int main(int argc, char* argv[]) { int code; code = mysystem(&amp;#34;.</description></item><item><title>8.23</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.23/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.23/</guid><description>SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR2 | | | | | being handled Pending Canceld Canceld Canceld need 1 sec there&amp;rsquo;s only one pending signal all the time. other same type signals will be canceled.
if you modify code
remove sleep
/* sleep(1); */ or
send more signals
for (i = 0; i &amp;lt; 500000; i++) you will get different counter output.</description></item><item><title>8.24</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.24/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.24/</guid><description>/* $begin waitpid1 */ #include &amp;#34;csapp.h&amp;#34;#define N 2 #define LEN 100 int main() { int status, i; pid_t pid; /* Parent creates N children */ for (i = 0; i &amp;lt; N; i++) if ((pid = Fork()) == 0) { /* access address 0, cause fault */ char* cptr = NULL; *cptr = &amp;#39;d&amp;#39;; } /* Parent reaps N children in no particular order */ while ((pid = waitpid(-1, &amp;amp;status, 0)) &amp;gt; 0) { if (WIFEXITED(status)) printf(&amp;#34;child %d terminated normally with exit status=%d\n&amp;#34;, pid, WEXITSTATUS(status)); else if (WIFSIGNALED(status)) { /* print signal that cause process exit */ char buf[LEN]; sprintf(buf, &amp;#34;child %d terminated by signal %d&amp;#34;, pid, WTERMSIG(status)); psignal(WTERMSIG(status), buf); } else printf(&amp;#34;child %d terminated abnormally\n&amp;#34;, pid); } /* The only normal termination is if there are no more children */ if (errno !</description></item><item><title>8.25</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.25/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.25/</guid><description>/* * 8.25.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;#34;csapp.h&amp;#34; sigjmp_buf buf; void handler(int sig) { /* jump */ siglongjmp(buf, 1); } char* tfgets(char* s, int size, FILE* stream) { char* result; if (!sigsetjmp(buf, 1)) { alarm(5); if (signal(SIGALRM, handler) == SIG_ERR) unix_error(&amp;#34;set alarm handler error&amp;#34;); return fgets(s, size, stream); } else { /* run out of time */ return NULL; } } #define LEN 100 int main(int argc, char* argv[]) { char buf[LEN]; char* input = tfgets(buf, LEN, stdin); if (input == NULL) { printf(&amp;#34;nothing input: NULL\n&amp;#34;); } else { printf(&amp;#34;%s&amp;#34;, input); } return 0; }</description></item><item><title>8.26</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.26/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter8/8.26/</guid><description>learn
origin shell code in pic 8-23, pic 8-24, pic 8-25 how to use waitpid in pic 8-18 how to wait child process in pic 8-42 and write a job management module
compose them and the little shell is born.
add bg fg jobs command to origin shell program
#include &amp;lt;assert.h&amp;gt;#include &amp;#34;../csapp.h&amp;#34;#include &amp;#34;shell.h&amp;#34;#include &amp;#34;job.h&amp;#34; void eval(char *cmdline) { char *argv[MAXARGS]; /* Argument list execve() */ char buf[MAXLINE]; /* Holds modified command line */ int bg; /* Should the job run in bg or fg?</description></item><item><title>9.11</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.11/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.11/</guid><description>VA: 0x027c
A.
13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 0| 0| 0| 1| 0| 0| 1| 1| 1| 1| 1| 0| 0| +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ B.
param value VPN 0x09 TLBI 0x01 TLBT 0x02 hit? No page falut? No PPN 0x17 C.</description></item><item><title>9.12</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.12/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.12/</guid><description>VA: 0x03a9
A.
13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 0| 0| 0| 1| 1| 1| 0| 1| 0| 1| 0| 0| 1| +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ B.
param value VPN 0x0E TLBI 0x02 TLBT 0x03 hit? No page falut? No PPN 0x11 C.</description></item><item><title>9.13</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.13/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.13/</guid><description>VA: 0x0040
A.
13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ | 0| 0| 0| 0| 0| 0| 0| 1| 0| 0| 0| 0| 0| 0| +--|--|--|--|--|--|--|--|--|--|--|--|--|--+ B.
param value VPN 0x01 TLBI 0x01 TLBT 0x00 hit? No page falut? Yes</description></item><item><title>9.14</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.14/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.14/</guid><description>/* * 9.14.c */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;#34;vm/csapp.h&amp;#34; void test(char* filename, char* content) { int fd; char buf[20]; fd = Open(filename, O_RDONLY, 0); Read(fd, buf, strlen(content)); assert( !strncmp(buf, content, strlen(content)) ); } int touch(char* filename, char* content) { int fd; umask(DEF_UMASK); fd = Open(filename, O_WRONLY|O_CREAT|O_TRUNC, DEF_MODE); Write(fd, content, strlen(content)); Close(fd); } int main(int argc, char* argv[]) { touch(&amp;#34;hello.txt&amp;#34;, &amp;#34;Hello, world!&amp;#34;); test(&amp;#34;hello.txt&amp;#34;, &amp;#34;Hello, world!&amp;#34;); struct stat stat; int fd; char* bufp; size_t size; fd = Open(&amp;#34;hello.</description></item><item><title>9.15</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.15/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.15/</guid><description> malloc size header malloc(3) 8 0x9 malloc(11) 16 0x11 malloc(20) 24 0x19 malloc(21) 24 0x19</description></item><item><title>9.16</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.16/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.16/</guid><description> alignment allocated block spare block min block size word Header &amp;amp; Footer Header &amp;amp; Footer 16 word Header Header &amp;amp; Footer 16 double word Header &amp;amp; Footer Header &amp;amp; Footer 16 double word Header Header &amp;amp; Footer 16</description></item><item><title>9.17</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.17/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.17/</guid><description>complete code in ./site/content/chapter9/code/vm/mm.9.17.c
--- mm.c 2021-02-25 07:26:33.315926002 +0000 +++ mm.9.17.c 2021-02-25 07:26:33.315926002 +0000 @@ -41,6 +41,7 @@ /* Global variables */ static char *heap_listp = 0; /* Pointer to first block */ +static char *rover; /* Next fit rover */ /* Function prototypes for internal helper routines */ static void *extend_heap(size_t words); @@ -69,6 +70,7 @@ heap_listp += (2*WSIZE); //line:vm:mm:endinit /* $end mminit */ + rover = heap_listp; /* $begin mminit */ /* Extend the empty heap with a free block of CHUNKSIZE bytes */ @@ -177,6 +179,10 @@ bp = PREV_BLKP(bp); } /* $end mmfree */ + /* Make sure the rover isn&amp;#39;t pointing into the free block */ + /* that we just coalesced */ + if ((rover &amp;gt; (char *)bp) &amp;amp;&amp;amp; (rover &amp;lt; NEXT_BLKP(bp))) + rover = bp; /* $begin mmfree */ return bp; } @@ -290,16 +296,20 @@ { /* $end mmfirstfit */ - /* $begin mmfirstfit */ - /* First-fit search */ - void *bp; - - for (bp = heap_listp; GET_SIZE(HDRP(bp)) &amp;gt; 0; bp = NEXT_BLKP(bp)) { - if (!</description></item><item><title>9.18</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.18/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.18/</guid><description>complete code in ./site/content/chapter9/code/vm/mm.9.18.c
--- mm.c 2021-02-25 07:26:33.315926002 +0000 +++ mm.9.18.c 2021-02-25 07:26:33.315926002 +0000 @@ -20,7 +20,7 @@ #define MAX(x, y) ((x) &amp;gt; (y)? (x) : (y)) /* Pack a size and allocated bit into a word */ -#define PACK(size, alloc) ((size) | (alloc)) //line:vm:mm:pack +#define PACK(size, alloc, prev_alloc) ((size) | (alloc) | (prev_alloc &amp;lt;&amp;lt; 1)) //line:vm:mm:pack /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) //line:vm:mm:get @@ -29,6 +29,7 @@ /* Read the size and allocated fields from address p */ #define GET_SIZE(p) (GET(p) &amp;amp; ~0x7) //line:vm:mm:getsize #define GET_ALLOC(p) (GET(p) &amp;amp; 0x1) //line:vm:mm:getalloc +#define GET_PREV_ALLOC(p) ((GET(p) &amp;gt;&amp;gt; 1) &amp;amp; 0x1) /* Given block ptr bp, compute address of its header and footer */ #define HDRP(bp) ((char *)(bp) - WSIZE) //line:vm:mm:hdrp @@ -63,9 +64,9 @@ if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1) //line:vm:mm:begininit return -1; PUT(heap_listp, 0); /* Alignment padding */ - PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); /* Prologue header */ - PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ - PUT(heap_listp + (3*WSIZE), PACK(0, 1)); /* Epilogue header */ + PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1, 1)); /* Prologue header */ + PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1, 1)); /* Prologue footer */ + PUT(heap_listp + (3*WSIZE), PACK(0, 1, 1)); /* Epilogue header */ heap_listp += (2*WSIZE); //line:vm:mm:endinit /* $end mminit */ @@ -98,10 +99,10 @@ return NULL; /* Adjust block size to include overhead and alignment reqs.</description></item><item><title>9.19</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.19/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.19/</guid><description>a: Right. 2^(k+1) block size for (2^k)+1 allocation request
b: wrong.
c: wrong. LIFO is also fast.
d: wrong. almost every strategy has external fragmentation problem.
a: wrong. first fit should be fast in this condition
b: wrong. should be order by block size
c: wrong. min spare size not max
d: Right.
b
ref 9.10.3</description></item><item><title>9.20</title><link>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.20/</link><pubDate>Fri, 26 Feb 2021 09:15:46 +0800</pubDate><guid>https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter9/9.20/</guid><description>using malloc lib code from csapp site
implicit idle list allocated block with header &amp;amp; footer idle block with header &amp;amp; footer no GC first fit strategy another modification to malloc lib file
mm.h
--- ../vm/mm.h 2021-02-25 07:26:33.315926002 +0000 +++ mm.h 2021-02-25 07:26:33.315926002 +0000 @@ -5,6 +5,9 @@ extern void mm_free (void *ptr); /* $end mallocinterface */ +#define malloc(size) mm_malloc(size) +#define free(ptr) mm_free(ptr) + extern void *mm_realloc(void *ptr, size_t size); extern void *mm_calloc (size_t nmemb, size_t size); extern void mm_checkheap(int verbose); memlib.</description></item></channel></rss>